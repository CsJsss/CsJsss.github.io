---
title: '[LeetCode]买卖股票合集'
toc: true
tags:
  - 状态机
  - 动态规划

categories:
  - - algo
    - LeetCode
    - 系列合集
date: 2021-11-23 20:18:18
updated:
---

简单整理一下LeetCode上`买卖股票`系列题目. 包含`买卖股票的最佳时机`、`买卖股票的最佳时机 II`、`买卖股票的最佳时机 III`、`买卖股票的最佳时机 IV`、`最佳买卖股票时机含冷冻期`和`买卖股票的最佳时机含手续费`共六题.

<!--more-->

## [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) 

### 题目描述

给出数组`price`, 其中`price[i]`表示第`i`天股票的价格. 只能选择某一天买入然后之后的某一天卖出, 求最大利润.

### 思路
- **贪心**. 如果在第`i`天卖出, 那么一定希望买入的时候价格最低, 因此使用维护一个前缀最小值即可.
- **状态机动态规划**
  - 状态机关心的时当前处于何种`状态`, 以及**所有可能的状态转移**和**条件**
  - 动态规划
    - 状态定义
      1. `f[i][0][0]`: 表示第`i`天没持有股票, 且没完成一次交易的最大利润(**一定为0**).
      2. `f[i][1][0]`: 表示第`i`天持有股票, 且没完成一次交易的最大利润.
      3. `f[i][0][1]`: 表示第`i`天没持有股票, 且完成一次交易的最大利润.
      4. `f[i][1][1]`: 表示第`i`天持有股票, 且完成一次交易的最大利润.
    - 状态转移
      1. $f[i][0][0] = f[i - 1][0][0] = 0$
      2. $f[i][1][0] = max(f[i - 1][1][0], -price[i])$, 表示要么是第`i - 1`天持有, 要么是第`i`天买入.
      3. $f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + price[i])$, 表示要么是第`i - 1`天完成一次交易, 要么是第`i`天卖出后完成了一次交易.
      4. $f[i][1][1] = max(f[i - 1][1][1], f[i - 1][0][1] - price[i])$, 表示要么是第`i - 1`天持有, 要么是第`i`天买入.
  - 使用**三维**的原因是必须保证**只能完成一次交易**, 因此需要**对状态进行拆分**.
  - **状态的表示**是持有股票或不持有股票, 而买入卖出是动作, 是**状态转移的条件**.
  - 状态初始化中, 由于第一天无法完成一次交易, 因此$f[1][0][1]=f[1][1][1]=-INF$.
  - 由于$f[i][1][1]$无法转移到其他任何状态, 而且其也不会是答案, 因此其为无效状态, 无需计算.

### Code
```cpp
/* 
  贪心思路, 记录前缀最小值即可.
    时间复杂度O(N)
    空间复杂度O(1)
*/
class Solution {
public:
    int maxProfit(vector<int>& p) {
        // ans至少为0, 即可以不买不卖
        int ans = 0, mn = p[0];
        for (int i = 1; i < (int)p.size(); i ++ ){
            ans = max(ans, p[i] - mn);
            mn = min(mn, p[i]);
        }
        return ans;
    }
};
```
```cpp
// 状态机动态规划
const int N = 1e5 + 5;
class Solution {
public:
    int f[N][2][2];
    int maxProfit(vector<int>& p) {
        int n = p.size();
        f[1][0][1] = f[1][1][1] = -1e9;
        f[1][1][0] = -p[0];
        for (int i = 2; i <= n; i ++ ) {
            f[i][0][0] = f[i - 1][0][0];
            f[i][1][0] = max(f[i - 1][1][0], -p[i - 1]);
            f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + p[i - 1]);
        }
        return max(f[n][0][1], f[n][0][0]);
    }
};
```

### 复杂度分析(状态机动态规划)

- 时间复杂度$O(N)$
- 空间复杂度$O(N)$
----

## [买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/) 

### 题目描述
基本题意与第一题相同, 只是多了个条件: 可以完成任意交易.

### 思路

- 本题无需关注交易次数, 只需关注在每个时间点所处的**状态**以及所有可能的转移及条件, 因此*简单修改*第一题状态机动态规划做法即可.
- **状态机动态规划**
  - 状态定义:
    1. `f[i][0]`: 表示第`i`天**没持有**股票时候的最大收益
    2. `f[i][1]`: 表示第`i`天**持有**股票时候的最大收益
  - 状态转移:
    1. $f[i][0] = max(f[i - 1][0], f[i - 1][1] + price[i])$, 表示第`i`天不持有可以从第`i - 1`天不持有或者第`i - 1`天持有但第`i`天*卖掉*转移而来.
    2. $f[i][1] = max(f[i - 1][1], f[i - 1][0] - price[i])$, 表示第`i`天持有可以从第`i - 1`天持有或者第`i - 1`天不持有但第`i`天*买入*转移而来.
- 最终答案: `f[n][0]`

### Code
```cpp
class Solution {
public:
    int maxProfit(vector<int>& p) {
        int n = p.size();
        vector<vector<int>> f(n, vector<int>(2, 0));
        f[0][0] = 0, f[0][1] = -p[0];
        for (int i = 1; i < n; i ++ ){
            f[i][0] = max(f[i - 1][0], f[i - 1][1] + p[i]);
            f[i][1] = max(f[i - 1][1], f[i - 1][0] - p[i]);
        }
        return f[n - 1][0];
    }
};
```

### 复杂度分析

- 时间复杂度$O(N)$
- 空间复杂度$O(N)$
----

## [买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/) 

### 题目描述

基本题意与第一题相同, 只是多了个条件: 最多完成两笔交易.

### 思路
- 第一题解法中使用**三维状态**来标记完成交易的次数, 本题只是第一题的简单扩展, 在第一题基础上稍加修改即可.
- **状态机动态规划**
  - 状态定义:
    1. $f[i][0][0]$: 表示第`i`天不持有股票, 且完成`0`笔交易时的最大收益(一定为0, 无效状态)
    2. $f[i][1][0]$: 表示第`i`天持有股票, 且完成`0`笔交易时的最大收益
    3. $f[i][0][1]$: 表示第`i`天不持有股票, 且完成`1`笔交易时的最大收益
    4. $f[i][0][2]$: 表示第`i`天不持有股票, 且完成`2`笔交易时的最大收益
    5. $f[i][1][1]$: 表示第`i`天持有股票, 且完成`1`笔交易时的最大收益
    6. $f[i][1][2]$: 表示第`i`天持有股票, 且完成`2`笔交易时的最大收益(无效状态)
  - 状态转移:
    2. $f[i][1][0] = max(f[i - 1][1][0], f[i - 1][0][0] - p[i])$, 表示第`i`天持有可以从第`i - 1`天持有或者第`i - 1`天不持有但第`i`天*买入*转移而来.
    3. $f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + p[i])$, 转移同上, 要么前一天同状态转移过来, 要么**前一天某状态**通过**买入/卖出**转移过来.
    4. $f[i][0][2] = max(f[i - 1][0][2], f[i - 1][1][1] + p[i])$
    5. $f[i][1][1] = max(f[i - 1][1][1], f[i - 1][0][1] - p[i])$
  - 由于第一天无法完成交易, 因此需要初始化第一天的某些状态为**非法状态**.
  

### Code
```cpp
const int N = 1e5 + 5;
class Solution {
public:
    int f[N][2][3];
    int maxProfit(vector<int>& p) {
        int n = p.size();
        // 初始化
        // 第一天持有股票
        f[1][1][0] = -p[0];
        // 第一天无法完成交易
        f[1][0][1] = f[1][0][2] = f[1][1][1] = f[1][1][2] = -1e9;
        for (int i = 2; i <= n; i ++ ) {
            int cur = p[i - 1];
            // 第i天有股票, 交易了0次
            f[i][1][0] = max(f[i - 1][1][0], - cur);
            // 第i天无股票, 交易了1次
            f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + cur);
            // 第i天无股票, 交易了2次
            f[i][0][2] = max(f[i - 1][0][2], f[i - 1][1][1] + cur);
            // 第i天有股票, 交易了1次
            f[i][1][1] = max(f[i - 1][1][1], f[i - 1][0][1] - cur);
        }
        return max({f[n][0][0], f[n][0][1], f[n][0][2]});
    }
};
```

### 复杂度分析

- 时间复杂度$O(N)$
- 空间复杂度$O(N)$
----

## [买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/) 

### 题目描述

基本题意与第一题相同, 只是多了个条件: 最多完成`k`笔交易.

### 思路

- 第一题状态机动态规划解法与第三题的推广版本, 完全一致的思路, 照抄即可.
- **状态机动态规划**
  - 状态定义:
    1. $f[i][0][j]$: 表示第`i`天不持有股票, 且完成`j`笔交易时的最大收益
    2. $f[i][1][j]$: 表示第`i`天持有股票, 且完成`j`笔交易时的最大收益
    
  - 状态转移: 
    1. $f[i][0][j] = max(f[i - 1][0][j], f[i - 1][1][j - 1] + p[i])$
    2. $f[i][1][j] = max(f[i - 1][1][j], f[i - 1][0][j] - p[i])$

### Code
```cpp
const int N = 1010, K = 110;
class Solution {
public:
    int f[N][2][K];
    int maxProfit(int k, vector<int>& p) {
        memset(f, -0x3f, sizeof(f));
        int n = p.size();
        for (int i = 0; i <= n; i ++ )
            f[n][0][0] = 0;
        for (int i = 1; i <= n; i ++ ) {
            int cur = p[i - 1];
            f[i][1][0] = max(f[i - 1][1][0], -cur);
            for (int j = 1; j <= k; j ++ ) {
                f[i][0][j] = max(f[i - 1][0][j], f[i - 1][1][j - 1] + cur);
                f[i][1][j] = max(f[i - 1][1][j], f[i - 1][0][j] - cur);
            }
        }
        int ans = 0;
        for (int i = 1; i <= k; i ++ )
            ans = max(ans, f[n][0][i]);
        return ans;
    }
};
```

### 复杂度分析

- 时间复杂度$O(N * K)$
- 空间复杂度$O(N * K)$
----

## [最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/) 

### 题目描述

基本题意与第一题相同, 只是多了条件: 可以买卖任意次, 但卖出股票后，无法在第二天买入股票 (即冷冻期为 1 天)。

### 思路
- 基本为第二题的扩展. 考虑如何将**冷冻期为 1 天**用状态表达出来即可.
- **状态机动态规划**
  - 状态定义:
    1. $f[i][0]$: 表示第`i`天不持有股票, **且无冷冻期**, 时候的最大收益.
    2. $f[i][1]$: 表示第`i`天不持有股票, **且在冷冻期**(第i - 1天卖出), 时候的最大收益.
    3. $f[i][2]$: 表示第`i`天持有股票时候的最大收益
    
  - 状态转移: 
    1. $f[i][0] = max(f[i - 1][0], f[i - 1][1])$
    2. $f[i][1] = f[i - 1][2] + p[i]$
    3. $f[i][2] = max(f[i - 1][2], f[i - 1][0] - p[i])$

### Code
```cpp
class Solution {
public:
    int maxProfit(vector<int>& p) {
        int n = p.size();
        vector<vector<int>> f(n + 1, vector<int>(3, 0));
        // 初始化:
        f[1][1] = -1e9;
        f[1][2] = -p[0];
        for (int i = 2; i <= n; i ++ ) {
            f[i][0] = max(f[i - 1][0], f[i - 1][1]);
            f[i][1] = f[i - 1][2] + p[i - 1];
            f[i][2] = max(f[i - 1][2], f[i - 1][0] - p[i - 1]);
        } 
        return max(f[n][0], f[n][1]);
    }
};
```

### 复杂度分析

- 时间复杂度$O(N)$
- 空间复杂度$O(N)$
----

## [买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/) 

### 题目描述

基本题意与第一题相同, 只是多了条件: 可以买卖任意次, 且一次买入卖出需要支付手续费。

### 思路
- 第二题的简单扩展. 卖出阶段支付手续费即可.
- **状态机动态规划**
  - 状态定义:
    1. $f[i][0]$: 表示第`i`天不持有股票时候的最大收益.
    2. $f[i][1]$: 表示第`i`天持有股票时候的最大收益.
    
  - 状态转移: 
    1. $f[i][0] = max(f[i - 1][0], f[i - 1][1] + p[i] - fee)$
    2. $f[i][1] = max(f[i - 1][1], f[i - 1][0] - p[i])$

### Code
```cpp
const int N = 1e5 + 5;
class Solution {
public:
    int f[N][2];
    int maxProfit(vector<int>& p, int fee) {
        int n = p.size();
        f[1][1] = -p[0];
        for (int i = 2; i <= n; i ++ ) {
            f[i][0] = max(f[i - 1][0], f[i - 1][1] + p[i - 1] - fee);
            f[i][1] = max(f[i - 1][1], f[i - 1][0] - p[i - 1]);
        }

        return f[n][0];
    }
};
```

### 复杂度分析

- 时间复杂度$O(N)$
- 空间复杂度$O(N)$
----

## 参考资料

- [B站yxc](https://space.bilibili.com/7836741?from=search&seid=17655252112390136376)

----
**欢迎讨论指正**