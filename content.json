{"pages":[{"title":"","text":"不积跬步, 无以至千里; 不积小流, 无以成江海。 本blog用来记录我自己的学习过程和感悟, 欢迎关注。","link":"/about/index.html"},{"title":"","text":"申请友链须知 本站友链信息如下，按如下格式提供申请信息： 网站图标：https://csjsss.github.io/img/tx.JPG 网站名称：Jsss 网站地址：https://csjsss.github.io/ 网站简介：BIT-CS硕士在读 加载中...","link":"/friend/index.html"},{"title":"有什么想对我说的, 就留个言吧~","text":"","link":"/message/index.html"}],"posts":[{"title":"Windows下实用工具软件合集","text":"整理分享一下平时我在Windows下使用的实用工具软件. Everything: 文件搜索神器Everything是一款简洁轻便的文件搜索软件. 特性 界面干净简洁 快速搜索 轻量级 使用示例 PowerToys: 微软开源实用工具PowerToys是Windows下一组实用工具的集合. 由微软官方发布的免费工具集合. 包含PowerToys Run、键盘管理器(键映射)和文件资源管理器(文件预览)等多种实用工具.官方文档与教程 特性 免费开源 微软官方开发维护 使用示例 Zeal: 离线文档浏览器Zeal是针对软件开发人员的离线文档浏览器. 特性 跨平台 多语言支持 使用示例 mathpix snipping tool: 公式识别软件通过mathpix snipping tool可以很方便的截图论文中的公式, 转化为LaTex可编辑文本, 能够显著提高读写论文效率. 特性 界面简约 快速高效 使用示例 WizTree: 磁盘空间分析器WiZTree是一款高效的磁盘空间扫描分析软件, 扫描速度极快, 界面简洁易操作. 特性 界面简约、中文界面 快速高效 文件名搜索 ScreenToGif: 高效的Gif制作器ScreenToGif是便捷的制作Gif软件的工具, 上述所有演示Gif均由该软件制作。选中屏幕上的指定区域, 轻松录制一段Gif, 并且编辑的功能完善强大. 功能强大 简洁高效","link":"/2021/11/18/Windows/Windows%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%90%88%E9%9B%86/"},{"title":"[cpp]便捷的字符串分割方法","text":"前言不像python的str提供的内置split方法一样方便的进行字符串分割，c++的string模板库没有直接提供分割字符串的成员方法。偶然在看《c++prime》时看到string模板库提供getline方法, 利用方法可以实现自定义分隔符分割字符串。 使用getline进行分割getline函数接受三个参数，分别是input(the stream to get data from), str(the string to put the data into), delim(the delimiter character) 。该函数返回值是input。 其中input是istream类型，比如cin, istringstream等继承自istream的类，分割符为char型字符。 为了获取带空格的字符串，一般使用getline(cin, str)进行读取字符串。读取待分割字串到str中后，我们需要用其实例化一个istringstream作为getline的input才能完成分割。 分割过程中需要注意一点: 若待分割字符串中包含连续的分割字符，这种情况会得到空字符串。多数情况下我们不期望得到空字符串，因此需要判断分割得到的字符串是否为空。 DemoCode123456789101112131415161718#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;int main() { string line, word; getline(cin, line); istringstream input(line); while (getline(input, word, ' ')) { if (!word.empty()) cout &lt;&lt; &quot;word : &quot; &lt;&lt; word &lt;&lt; endl; } return 0;} 结果 欢迎讨论指正","link":"/2021/10/27/cpp/%5Bcpp%5D%E4%BE%BF%E6%8D%B7%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95/"},{"title":"[LeetCode-周赛]266","text":"Rank : 152/4384Solved: 4/4 竞赛链接 统计字符串中的元音子字符串思路 注意到数据范围很小, 直接$O(n^2)$枚举所有子串, 然后$O(n)$判断该子串是否符合要求即可 Code1234567891011121314151617181920212223class Solution {public: int countVowelSubstrings(string s) { int ans = 0, n = s.size(); for (int i = 0; i &lt; n; i ++ ) for (int j = i; j &lt; n; j ++ ) { string tmp = s.substr(i, j - i + 1); int cnt = 0; bool flag = true; for (auto&amp; c : {'a', 'e' ,'i' ,'o', 'u'}) { int cur = count(tmp.begin(), tmp.end(), c); cnt += cur; // 子串不含某个元音字母则不满足条件 if (cur == 0) flag = false; } // cnt记录字符串中所有元音字符的数量 if (flag) ans += cnt == tmp.size(); } return ans; }}; 复杂度分析 时间复杂度$O(n^3)$ 空间复杂度$O(1)$ 所有子字符串中的元音思路 遍历字符串, 枚举每个元音字符对答案的贡献 某个i位置的元音字符贡献为包含i位置的所有子串的个数 由乘法原理, 子串的个数为$(i + 1) * (n - i)$ Code1234567891011121314151617using LL = long long;class Solution {public: long long countVowels(string s) { set&lt;int&gt; str = {'a', 'e' ,'i' ,'o', 'u'}; LL ans = 0, n = s.size(); for (int i = 0; i &lt; n; i ++ ) { char cur = s[i]; int l = i; int r = n - i - 1; if (str.count(cur)) ans += 1ll * (l + 1) * (r + 1); } return ans; }}; 复杂度分析 时间复杂度$O(n)$ 空间复杂度$O(1)$ 分配给商店的最多商品的最小值思路 看到最大值最小立马想到二分 二分答案: 对于答案x, 所有的商店的上界不超过x 枚举所有商品, i号商品至少需要$\\lceil \\frac{quantities[i]}{x} \\rceil$ 个商店 Code1234567891011121314151617181920class Solution {public: int minimizedMaximum(int n, vector&lt;int&gt;&amp; nums) { int m = nums.size(); int l = 1, r = 1e5; while (l &lt; r) { int mid = (r - l) / 2 + l; int cnt = 0; // cpp上取整方式之一 for (auto&amp; num : nums) cnt += (num + mid - 1) / mid; if (cnt &lt;= n) r = mid; else l = mid + 1; } return r; }}; 复杂度分析 时间复杂度$O(N * log1e5)$ 空间复杂度$O(1)$ 最大化一张图中的路径价值思路 动态规划: $dist[i][j][k]$: 表示当前在i点, 还剩余j时间，走过的点的状态是k时候的最大价值 由于只能按照时间递减的顺序走, 因此从大到小遍历时间 状态转移: 若当前状态是$dist[i][j][k]$, 枚举i号点的所有邻接点u, 更新$dist[u][j - costTime][k’]$ 若已经走过了u点, 即k[u] = true, 则$dist[u][j - costTime][k] = max(dist[u][j - costTime][k], dist[i][j][k])$ 若没有走过u点, 即k[u] = false, 则$dist[u][j - costTime][k’] = max(dist[u][j - costTime][k’], dist[i][j][k] + value[u])$, 其中$k’ = k | (1 &lt;&lt; u)$ 实现细节:用二进制表示状态k, 但无法用int或者long long等基础数据类型存储, 这里我使用了bitset存储状态 Code123456789101112131415161718192021222324252627282930313233343536373839404142const int N = 1005, M = 105;using PII = pair&lt;int, int&gt;;class Solution {public: unordered_map&lt;bitset&lt;N&gt;, int&gt; dist[N][M]; int maximalPathQuality(vector&lt;int&gt;&amp; val, vector&lt;vector&lt;int&gt;&gt;&amp; edge, int Mx) { int n = val.size(); vector&lt;vector&lt;PII&gt;&gt; g(n); for (auto&amp; e : edge) { int a = e[0], b = e[1], c = e[2]; g[a].emplace_back(b, c); g[b].emplace_back(a, c); } dist[0][Mx][bitset&lt;N&gt;(1)] = val[0]; for (int Time = Mx; Time &gt;= 0; Time -- ) { for (int i = 0; i &lt; n; i ++ ) for (auto&amp; [st, v] : dist[i][Time]) for (auto&amp; [nxt, cost] : g[i]) { if (Time &lt; cost) continue; if (st[nxt] == 0) { bitset&lt;N&gt; tmp = st; tmp[nxt] = 1; dist[nxt][Time - cost][tmp] = max(dist[nxt][Time - cost][tmp], dist[i][Time][st] + val[nxt]); } else dist[nxt][Time - cost][st] = max(dist[nxt][Time - cost][st], dist[i][Time][st]); } } // 最后答案枚举0号点的状态即可 int ans = val[0]; for (int r = Mx; r &gt;= 0; r -- ) for (auto&amp; [_, v] : dist[0][r]) ans = max(ans, v); return ans; }}; 复杂度分析 时间复杂度$O(M * N * C)$: M为maxTime, N为点数, C为有效状态数 空间复杂度$O(M * N * C)$: M为maxTime, N为点数, C为有效状态数 欢迎讨论指正","link":"/2021/11/07/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D266/"},{"title":"[LeetCode-周赛]267","text":"Rank : 131/4360Solved : 4/4 竞赛链接 买票需要的时间思路注意到数据范围均很小, 因此直接使用双端队列(deque)模拟题意即可. Code1234567891011121314151617181920212223using PII = pair&lt;int, int&gt;;class Solution {public: int timeRequiredToBuy(vector&lt;int&gt;&amp; nums, int k) { deque&lt;PII&gt; dq; int n = nums.size(), ans = 0; for (int i = 0; i &lt; n; i ++ ) dq.emplace_back(nums[i], i); int cnt = 0; while (true) { auto [t, idx] = dq.front(); dq.pop_front(); cnt ++ ; if (t == 1 and idx == k) return cnt; if (t &gt; 1) dq.emplace_back(t - 1, idx); } return -1; }}; 复杂度分析 时间复杂度$O(N * Max(nums))$ 空间复杂度$O(N)$ 反转偶数长度组的节点思路使用vector模拟题意, 注意反转的是偶数长度的组(错看成偶数编号的组, 白WA了两次) Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseEvenLengthGroups(ListNode* head) { ListNode* p = head; vector&lt;int&gt; nums; while (p) { nums.push_back(p -&gt; val); p = p -&gt; next; } int n = nums.size(); vector&lt;int&gt; ans; // cnt是index, id是组的编号(1, 2, 3...) int cnt = 0, id = 1; while (cnt &lt; n) { if (id &amp; 1) { int len = min(n - 1, cnt + id - 1) - cnt + 1; if (len &amp; 1) { for (int k = cnt; k &lt;= min(n - 1, cnt + id - 1); k ++ ) ans.push_back(nums[k]); } else { for (int k = min(n - 1, cnt + id - 1); k &gt;= cnt; k --) ans.push_back(nums[k]); } cnt = min(n, cnt + id); } else { int len = min(n - 1, cnt + id - 1) - cnt + 1; if (len &amp; 1) { for (int k = cnt; k &lt;= min(n - 1, cnt + id - 1); k ++ ) ans.push_back(nums[k]); } else for (int k = min(n - 1, cnt + id - 1); k &gt;= cnt; k --) ans.push_back(nums[k]); cnt = min(n, cnt + id); } id += 1; } ListNode* ret = new ListNode(); p = nullptr; for (auto&amp; c : ans) { if (p == nullptr) { ret -&gt; val = c; p = ret; } else { ListNode* nxt = new ListNode(c); p -&gt; next = nxt; p = p -&gt; next; } } return ret; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 解码斜向换位密码思路模拟题意, 按照矩阵的方式填充好字符后. 遍历每条主对角线, 依次添加字符, 最后把末尾的空格去掉. Code123456789101112131415161718192021222324252627class Solution {public: string decodeCiphertext(string str, int row) { int len = str.size(); int col = len / row; vector&lt;vector&lt;char&gt;&gt; mat(row, vector&lt;char&gt;(col, ' ')); int x = 0, y = 0; for (auto&amp; c : str) { mat[x][y] = c; y ++ ; if (y == col) y = 0, x ++ ; } string ans; for (int i = 0; i &lt; col; i ++ ) { int x = 0, y = i; while (x &lt; row and y &lt; col) { ans.push_back(mat[x][y]); x ++, y ++; } } while (ans.size() and ans.back() == ' ') ans.pop_back(); return ans; }}; 复杂度分析 时间复杂度$O(N)$, N为str的长度 空间复杂度$O(N)$ 处理含限制条件的好友请求思路使用并查集维护连通性. 每次处理请求时, 若已经在一个联通块中则结果为True; 否则暴力判断是否有一条限制边连接了这两个连通块中的两个点. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344const int N = 1010;int p[N];class Solution {public: int find(int x) { return x == p[x] ? x : p[x] = find(p[x]); } vector&lt;bool&gt; friendRequests(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edge, vector&lt;vector&lt;int&gt;&gt;&amp; qu) { int m = edge.size(); for (int i = 0; i &lt; n; i ++ ) p[i] = i; vector&lt;bool&gt; ans; for (auto&amp; q : qu) { int x = q[0], y = q[1]; x = find(x), y = find(y); if (x == y) { ans.push_back(true); continue; } // x != y unordered_set&lt;int&gt; sx, sy; for (int i = 0; i &lt; n; i ++ ) { if (find(i) == x) sx.insert(i); if (find(i) == y) sy.insert(i); } bool flag = true; for (auto&amp; e : edge) { int u = e[0], v = e[1]; if ((sx.count(u) and sy.count(v)) or (sx.count(v) and sy.count(u))) flag = false; } ans.push_back(flag); if (flag) p[y] = x; } return ans; }}; 复杂度分析 时间复杂度$O(N * M)$, N为点数, M为请求数. 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2021/11/14/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D267/"},{"title":"[LeetCode-周赛]268","text":"Rank : 228/4397Solved : 4/4 竞赛链接 两栋颜色不同且距离最远的房子思路注意到数据范围很小, 两重循环枚举即可. Code123456789101112131415161718class Solution {public: int maxDistance(vector&lt;int&gt;&amp; c) { unordered_map&lt;int, int&gt; mp; int n = c.size(); int ans = 0; for (int i = 0; i &lt; n; i ++ ) { int col = c[i]; for (auto&amp; [cc, idx] : mp) { if (cc != col) ans = max(ans, i - idx); } if (mp.count(col) == 0) mp[col] = i; } return ans; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(N)$ 给植物浇水思路按照题意模拟即可. Code1234567891011121314151617181920class Solution {public: int wateringPlants(vector&lt;int&gt;&amp; nums, int cap) { int n = nums.size(); // all : 当前剩余 int ret = 0, all = cap; for (int i = 0; i &lt; n; i ++ ) { int cur = nums[i]; if (all &gt;= cur) { all -= cur; ret += 1; } else { all = cap; ret += i + i + 1; all -= cur; } } return ret; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(1)$ 区间内查询数字的频率思路以值作为key, 以下标作为val, 构建哈希表.每次查询在递增的下标上二分搜索即可 Code123456789101112131415161718192021class RangeFreqQuery {public: unordered_map&lt;int, vector&lt;int&gt;&gt; mp; RangeFreqQuery(vector&lt;int&gt;&amp; arr) { int n = arr.size(); for (int i = 0; i &lt; n; i ++ ) mp[arr[i]].push_back(i); } int query(int l, int r, int val) { auto L = lower_bound(mp[val].begin(), mp[val].end(), l) - mp[val].begin(); auto R = upper_bound(mp[val].begin(), mp[val].end(), r) - mp[val].begin(); return R - L; }};/** * Your RangeFreqQuery object will be instantiated and called as such: * RangeFreqQuery* obj = new RangeFreqQuery(arr); * int param_1 = obj-&gt;query(left,right,value); */ 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(Q * logN)$ k 镜像数字的和思路打表. 由于数据范围很小, 考虑枚举长度不超过12的十进制回文数(复杂度为1e6), 然后暴力判断每个10进制下的回文数是否在2-9进制下也回文. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const int M = 30;using LL = long long;vector&lt;vector&lt;LL&gt;&gt; nums;class Solution {public: void dfs(int len, int cur, string&amp; num) { int R = (len + 1) / 2; if (cur == R + 1) { string ss = num; if (len &amp; 1) { for (int idx = R - 1; idx &gt;= 1; idx -- ) ss.push_back(num[idx - 1]); } else { for (int idx = R; idx &gt;= 1; idx -- ) ss.push_back(num[idx - 1]); } LL val = stoll(ss); for (int k = 2; k &lt;= 9; k ++ ) { if (nums[k].size() == M) continue; LL cv = val; string s; while (cv) { s.push_back(char(cv % k + '0')); cv /= k; } string rs = s; reverse(rs.begin(), rs.end()); if (s == rs and rs[0] != '0') nums[k].push_back(val); } return ; } for (int i = 0; i &lt;= 9; i ++ ) { num.push_back(char(i + '0')); dfs(len, cur + 1, num); num.pop_back(); } } void init() { if (nums.size()) return ; nums.resize(10); for (int len = 1; len &lt;= 12; len ++ ) { for (int i = 1; i &lt;= 9; i ++ ) { string s = to_string(i); dfs(len, 2, s); } } } long long kMirror(int k, int n) { init(); LL ret = 0ll; for (int i = 0; i &lt; n; i ++ ) ret += nums[k][i]; return ret; }}; 复杂度分析 时间复杂度$O(1e6)$ 空间复杂度$O(N * K)$ 欢迎讨论指正","link":"/2021/11/23/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D268/"},{"title":"[LeetCode-周赛]271","text":"Rank : 201/4561Solved : 4/4 竞赛链接 环和杆思路对每个杆使用哈希表记录出现的环种类即可. Code123456789101112131415161718class Solution {public: int countPoints(string s) { unordered_map&lt;int, unordered_set&lt;char&gt;&gt; cnt; int n = s.size(); for (int i = 0; i &lt; n; i += 2) { char col = s[i]; int idx = s[i + 1]; cnt[idx].insert(col); } int ans = 0; for (auto&amp; [k, v] : cnt) if (v.size() == 3) ans += 1; return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 子数组范围和思路由于数据范围很小, 因此使用暴力的方法即可.可以使用单调栈分开统计最小和最大值的贡献, 时间和空间复杂度均为$O(N)$. Code12345678910111213141516171819using LL = long long;class Solution {public: long long subArrayRanges(vector&lt;int&gt;&amp; nums) { int n = nums.size(); LL ans = 0; for (int i = 0; i &lt; n; i ++ ) { int Mn = INT_MAX, Mx = INT_MIN; for (int j = i; j &lt; n; j ++ ) { Mn = min(Mn, nums[j]); Mx = max(Mx, nums[j]); ans += Mx - Mn; } } return ans; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(N)$ 给植物浇水 II思路阅读理解模拟题. 按题意模拟即可. Code1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: int minimumRefill(vector&lt;int&gt;&amp; nums, int a, int b) { int n = nums.size(); int L = 0, R = n - 1; // cA cB 灌水次数 int cA = 0, cB = 0; // curA curB 当前水量 int curA = a, curB = b; while (L &lt;= R) { if (L == R) { // Bob if (curB &gt; curA) { if (curB &lt; nums[L]) cB += 1; } else { // Alice if (curA &lt; nums[L]) cA += 1; } break; } if (curA &gt;= nums[L]) { curA -= nums[L]; } else { curA = a - nums[L]; cA += 1; } if (curB &gt;= nums[R]) { curB -= nums[R]; } else { curB = b - nums[R]; cB += 1; } L += 1, R -= 1; } return cA + cB; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 摘水果思路没看清楚题目范围, 还写了个离散化, 小亏. 具体思路使用前缀和的技巧, 暴力枚举所有的方案, 求这些方案的最大值即可. 我的方法是枚举终点. 特殊计算一直往左走和一直往右走. 若终点小于等于starPos, 则先往右走, 然后再折回到终点最优. 若终点大于等于starPos, 则先往左走, 然后掉头往右走最优. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using LL = long long;class Solution {public: vector&lt;int&gt; all; int get(int x) { return lower_bound(all.begin(), all.end(), x) - all.begin() + 1; } int maxTotalFruits(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int stP, int k) { int n = nums.size(); for (int i = 0; i &lt; n; i ++ ) all.push_back(nums[i][0]); for (int i = stP - k; i &lt;= stP + k; i ++ ) all.push_back(i); sort(all.begin(), all.end()); all.erase(unique(all.begin(), all.end()), all.end()); int M = all.size(); vector&lt;LL&gt; sum(M + 1, 0ll); for (int i = 0; i &lt; n; i ++ ) { int idx = get(nums[i][0]); sum[idx] = nums[i][1]; } for (int i = 1; i &lt;= M; i ++ ) sum[i] += sum[i - 1]; LL ans = 0; // Left int curIdx = get(stP), leftIdx = get(stP - k), rightIdx = get(stP + k); ans = sum[curIdx] - sum[leftIdx - 1]; // Right ans = max(ans, sum[rightIdx] - sum[curIdx - 1]); for (int ed = stP - k + 1; ed &lt; stP + k; ed ++ ) { int start; if (ed &lt;= stP) { start = stP + (k - (stP - ed)) / 2; ans = max(ans, sum[get(start)] - sum[get(ed) - 1]); // cout &lt;&lt; ed &lt;&lt; ' ' &lt;&lt; start &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; } if (ed &gt;= stP) { start = stP - (k - (ed - stP)) / 2; ans = max(ans, sum[get(ed)] - sum[get(start) - 1]); // cout &lt;&lt; ed &lt;&lt; ' ' &lt;&lt; start &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; } } return ans; }}; 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2021/12/15/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D271/"},{"title":"[LeetCode-周赛]273","text":"Rank : 301/4367Solved : 4/4 竞赛链接 反转两次的数字思路模拟题意. cpp可以使用to_string和stoi函数方便的进行字符串和int之间的转换. Code12345678910111213class Solution {public: bool isSameAfterReversals(int num) { string nums = to_string(num); reverse(nums.begin(), nums.end()); int r1 = stoi(nums); string r2 = to_string(r1); reverse(r2.begin(), r2.end()); if (num == stoi(r2)) return true; return false; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 执行所有后缀指令思路由于数据范围很小, 因此直接按照题意模拟. Code1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;int&gt; executeInstructions(int n, vector&lt;int&gt;&amp; st, string s) { int sx = st[0], sy = st[1]; int m = s.size(); vector&lt;int&gt; ans; for (int i = 0; i &lt; m; i ++ ) { int x = sx, y = sy, cur = 0; for (int j = i; j &lt; m; j ++ ) { if (s[j] == 'L') y -= 1; if (s[j] == 'R') y += 1; if (s[j] == 'U') x -= 1; if (s[j] == 'D') x += 1; if (x &gt;= 0 and x &lt; n and y &gt;= 0 and y &lt; n) cur ++ ; else break; } ans.push_back(cur); } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 相同元素的间隔之和思路首先可以将问题一分为二: 分别统计左边和右边, 最后两者相加即可.以左边为例. 我们可以使用前缀和的思想完成统计. 具体思路为: 记left[i]为nums[i]左边与其的间隔之和. cnt[nums[i]]为i极其左边与nums[i]值相等的个数. 若当前枚举到下标i, 其值为nums[i], 若其左边最后一个与其值相同的下标为j, 则有:$$sum[i] = sum[j] + cnt[nums[i]] * (i - j) $$ 上式表示所有所有与nums[i]相同的下标, 先考虑其到j处的距离距离之和(由sum的定义可知为sum[j]); 然后再统计j到i处的距离之和, 其为(i - j) * cnt[nums[i]]. 主要思想是利用历史信息, 分两步部分统计(先到j, 再到i), 其中使用前缀和进行优化. 最后将left和right相加即可. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546using LL = long long;class Solution {public: vector&lt;long long&gt; getDistances(vector&lt;int&gt;&amp; arr) { int n = arr.size(); vector&lt;LL&gt; sum(n + 1, 0L); unordered_map&lt;int, int&gt; mp; // 记录每个数最后一次出现的位置 unordered_map&lt;int, int&gt; cnt; // Left for (int i = 1; i &lt;= n; i ++ ) { int cur = arr[i - 1]; if (mp.count(cur) == 0) { mp[cur] = i; cnt[cur] ++ ; continue; } int idx = mp[cur], num = cnt[cur]; sum[i] = sum[idx] + 1ll * num * (i - idx); mp[cur] = i; cnt[cur] ++ ; } // Right mp.clear(); cnt.clear(); vector&lt;LL&gt; ans(n, 0L); // 先把左边的加到答案里, 然后算右边的 for (int i = 0; i &lt; n; i ++ ) ans[i] += sum[i + 1]; sum = vector&lt;LL&gt;(n + 1, 0L); for (int i = n; i &gt;= 1; i -- ) { int cur = arr[i - 1]; if (mp.count(cur) == 0) { mp[cur] = i; cnt[cur] ++ ; continue; } int idx = mp[cur], num = cnt[cur]; sum[i] = sum[idx] + 1ll * num * (idx - i); mp[cur] = i; cnt[cur] ++ ; } for (int i = 0; i &lt; n; i ++ ) ans[i] += sum[i + 1]; return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 还原原数组思路首先观察数据范围可知, 可以使用$O(N^2)$的算法解决.由于将原数组左右k和右移k后, 对应位置的数差值固定为2k.因此如果我们知道k的具体值的话, 问题就转化成: 给定k值的情况下, 判断数组能否还原出原数组. 判断可以从贪心的小到大考虑: 若考虑到x了, 则将x放入lower数组, 将x + 2k放入higher数组, 若无x + 2k则失败。使用map或者multiset判断的时间复杂度为$O(NlogN)$ 对于k值, 可以考虑枚举所有可能的k值. 由于数组的最大值必定为higher的最大值, 最小值必定为lower的最小值. 因此可以枚举higher的最小值或者lower的最大值, 从而计算出k. 时间复杂度$O(N)$. 最后算法整体时间复杂度为$O(N^2logN)$. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution {public: vector&lt;int&gt; recoverArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); n /= 2; // Max -&gt; higher, Min -&gt; lower int HMx = *max_element(nums.begin(), nums.end()); int LMn = *min_element(nums.begin(), nums.end()); if (n == 1) return {LMn + (HMx - LMn) / 2}; set&lt;int&gt; st(nums.begin(), nums.end()); map&lt;int, int&gt; cnt; for (auto&amp; num : nums) cnt[num] ++ ; // 从大到小枚举LMx, 计算k for (auto it = st.rbegin(); it != st.rend(); it ++ ) { int LMx = *it; if (LMx == HMx) continue; int d = HMx - LMx; if (d % 2 or cnt[HMx] &gt; cnt[LMx]) continue; int k = d / 2; bool flag = true; // lower map&lt;int, int&gt; exist; // map&lt;int, int&gt; cur = cnt; for (auto&amp; [_k, _v] : cnt) { if (_v == 0) continue; if (cnt.count(_k + 2 * k) == 0 or cnt[_k + 2 * k] &lt; _v) { flag = false; break; } else { cnt[_k + 2 * k] -= _v; exist[_k] = _v; } } // 复原全局的cnt for (auto&amp; [_k, _v] : exist) cnt[_k + 2 * k] += _v; if (flag) { // cout &lt;&lt; &quot;find &quot; &lt;&lt; k &lt;&lt; ' ' &lt;&lt; HMx &lt;&lt; ' ' &lt;&lt; LMx &lt;&lt; endl; vector&lt;int&gt; ans; // lower exist[LMn] = cnt[LMn]; for (auto&amp; [l, time] : exist) ans.insert(ans.end(), time, l + k); return ans; } } return {}; }}; 实现的过程中使用exist来存储lower数组, 如果没有找到答案, 则将exist的内容复原到原来的mapcnt中, 这样可以减少cnt的重复拷贝, 将运行时间从超时边缘(1972ms)优化成28ms. 复杂度分析 时间复杂度$O(N^2logN)$ 空间复杂度$O(N^2)$ 欢迎讨论指正","link":"/2021/12/27/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D273/"},{"title":"[LeetCode-周赛]276","text":"Rank : 273/5243Solved : 4/4 竞赛链接 https://leetcode-cn.com/contest/weekly-contest-276/problems/divide-a-string-into-groups-of-size-k/思路模拟题意, 如果最后一段的长度不足就补齐. Code123456789101112131415161718class Solution {public: vector&lt;string&gt; divideString(string s, int k, char fill) { vector&lt;string&gt; ans; string cur; int n = s.size(); for (int i = 0; i &lt; n; i ++ ) { cur.push_back(s[i]); if (cur.size() == k) ans.push_back(cur), cur = &quot;&quot;; } while (cur.size() and cur.size() &lt; k) cur.push_back(fill); if (cur.size() == k) ans.push_back(cur); return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 得到目标值的最少行动次数思路写完记忆化才发现其实是贪心. 首先倒着做, 求从target变成1的最小花费. 然后贪心的做 当前数能被2整除且有整除次数, 则整除 否则就减一 (无整除次数直接可以返回答案) Code1234567891011121314151617181920212223242526272829const int INF = 1e9;class Solution {public: unordered_map&lt;int, unordered_map&lt;int,int&gt;&gt; f; int dfs(int x, int cnt) { if (cnt == 0) return x - 1; if (f.count(x) and f[x].count(cnt)) return f[x][cnt]; int&amp; v = f[x][cnt]; // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; endl; v = INF; if ((x % 2) == 0 and cnt) v = min(v, dfs(x / 2, cnt - 1) + 1); else v = min(v, dfs(x - 1, cnt) + 1); return v; } int minMoves(int tar, int cnt) { if (cnt == 0) return tar - 1; int ans = INF; for (int i = 0; i &lt;= cnt; i ++ ) f[1][i] = 0; ans = dfs(tar, cnt); return ans; }}; 复杂度分析 时间复杂度$O(logN)$ 空间复杂度$O(logN * maxDoubles)$ 解决智力问题思路首先可以想到使用动态规划, 因为选的方式无法穷举, 而且选与不选之间的状态转移也比较清楚.麻烦的是如果正向做, 求f[i]的时候, 计算选择i的时候, 我们要找一个j, 使得在j处选择后可以在i处选择, 且f[j]最大.反向做就比较友好, 避免了找j的过程. 动态规划: 状态定义: f[i]表示考虑$i ~ n - 1$之间物品时候的最大价值. 状态转移: - 可以不拿i处的或只拿i处的: $f[i] = max(f[i + 1], cur)$ - 可以拿了i处后继续拿后面的: $f[i] = max(f[i], f[i + questions[i][1] + 1] + cur)$ Code123456789101112131415161718using LL = long long;class Solution {public: long long mostPoints(vector&lt;vector&lt;int&gt;&gt;&amp; qu) { int n = qu.size(); vector&lt;LL&gt; f(n); f[n - 1] = qu[n - 1][0]; for (int i = n - 2; i &gt;= 0; i -- ) { int r = i + qu[i][1] + 1; LL cur = qu[i][0]; f[i] = max(f[i + 1], cur); // 不越界才可以拿后面的 if (r &lt; n) f[i] = max(f[i], f[r] + cur); } return f[0]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 同时运行 N 台电脑的最长时间思路没有思路的时候就想想二分 哈哈!答案具有二段性, 如果答案为k, 则所有小于等于k的都能被凑出来, 而大于k的无法凑出来.因此可以二分答案, 然后判断这个数组能否凑出n个mid. 判断过程中, 如果某个值大于等于mid, 则凑出个数 + 1;否则双指针连续求和, 求出一段之和大于等于mid, 然后关键是这一段之和大于mid的部分可以被其他电脑所使用. 因此大于mid的部分的可以继续使用. Code123456789101112131415161718192021222324252627282930313233343536373839404142using LL = long long;class Solution {public: long long maxRunTime(int n, vector&lt;int&gt;&amp; nums) { int m = nums.size(); if (m &lt; n) return 0; sort(nums.begin(), nums.end()); LL sum = 0; for (auto&amp; c : nums) sum += c; LL L = 0, R = sum; while (L &lt; R) { LL mid = (L + R + 1) &gt;&gt; 1; LL cur = 0, cnt = 0; for (int i = 0; i &lt; m; ) { if (nums[i] &gt;= mid) { cnt ++ ; i ++ ; continue; } int j = i; while (j &lt; m and cur &lt; mid) { cur += nums[j]; j ++ ; } if (cur &gt;= mid) { cnt ++ ; cur -= mid; } i = j; } if (cnt &gt;= n) L = mid; else R = mid - 1; } return R; }}; 复杂度分析 时间复杂度$O(NlogN)$ 空间复杂度$O(1)$ 欢迎讨论指正","link":"/2022/01/16/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D276/"},{"title":"[LeetCode-周赛]第65场双周赛","text":"Rank : 235/2676Solved : 3/4 竞赛链接 检查两个字符串是否几乎相等思路模拟题意. 使用哈希表或数组统计词频, 然后比较词频之差的绝对值是否超过3. Code12345678910111213141516class Solution {public: bool checkAlmostEquivalent(string w1, string w2) { unordered_map&lt;char, int&gt; m1, m2; for (auto&amp; c : w1) m1[c] ++ ; for (auto&amp; c : w2) m2[c] ++ ; for (char c = 'a'; c &lt;= 'z'; c ++ ) { int d = abs(m1[c] - m2[c]); if (d &gt; 3) return false; } return true; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(\\vert S\\vert)$, $\\vert S\\vert$为字符集大小 模拟行走机器人 II思路模拟. 一开始眼瞎没注意到数据范围, 每一步都按照题目要求模拟, 然后TLE了. 接着优化, 优化的方式写了两点。 一种是步长对周长取余, 因为每次都是绕外圈走, 因此可以认为余数是真正移动了的步数, 这种优化要注意移动方向的改变, 在四个角上移动了k圈后, 可能会发生移动方向的改变. 比如在左下角(0, 0), 只有初始朝北的时候, 绕k圈后会朝西; 其他朝向绕k圈后都会朝南. 还有一种是一次走好几步, 比如当前向北, 算一下向北最多能走几步. 若可以走完, 就一次走完. 若向北走不完, 则走到上界后修改方向, 递归走剩下的步数。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};class Robot {public: map&lt;int, string&gt; mp; int idx; int x, y; int W, H; // 周长 int all; Robot(int width, int height) { W = width, H = height; x = 0, y = 0; idx = 1; mp[0] = &quot;North&quot;; mp[1] = &quot;East&quot;; mp[2] = &quot;South&quot;; mp[3] = &quot;West&quot;; all = 2 * (W + H) - 4; } bool check(int x, int y) { return x &gt;= 0 and x &lt; W and y &gt;= 0 and y &lt; H; } void move(int num) { num %= all; if (num == 0) { if (x == 0 and y == 0) { if (getDir() == &quot;North&quot;) idx = 3; else idx = 2; } if (x == 0 and y == H - 1) { if (getDir() == &quot;East&quot;) idx = 0; else idx = 3; } if (x == W - 1 and y == 0) { if (getDir() == &quot;West&quot;) idx = 2; else idx = 1; } if (x == W - 1 and y == H - 1) { if (getDir() == &quot;South&quot;) idx = 1; else idx = 0; } } string c = getDir(); if (c == &quot;North&quot;) { int Mx = H - 1 - y; if (Mx &gt;= num) { y += num; return ; } else { y = H - 1; idx = 3; return move(num - Mx); } } if (c == &quot;South&quot;) { int Mx = y; if (Mx &gt;= num) { y -= num; return ; } else { y = 0; idx = 1; return move(num - Mx); } } if (c == &quot;West&quot;) { int Mx = x; if (Mx &gt;= num) { x -= num; return ; } else { x = 0; idx = 2; return move(num - Mx); } } if (c == &quot;East&quot;) { int Mx = W - x - 1; if (Mx &gt;= num) { x += num; return ; } else { x = W - 1; idx = 0; return move(num - Mx); } } for (int i = 1; i &lt;= num; ) { int nx = x + dx[idx], ny = y + dy[idx]; if (check(nx, ny)) { i += 1; x = nx, y = ny; continue; } idx -= 1; if (idx == -1) idx = 3; } } vector&lt;int&gt; getPos() { return {x, y}; } string getDir() { return mp[idx]; }};/** * Your Robot object will be instantiated and called as such: * Robot* obj = new Robot(width, height); * obj-&gt;move(num); * vector&lt;int&gt; param_2 = obj-&gt;getPos(); * string param_3 = obj-&gt;getDir(); */ 复杂度分析 时间复杂度$O(N)$, N次调用move, 每次最多走三个阶段(自身递归的次数不超过3) 空间复杂度$O(1)$ 每一个查询的最大美丽值思路经典题. 可以使用树状数组在线算法做, 也可以使用递推等离线算法做. 在线算法(树状数组): 离散化查询点和价格点后, 需要查询每一个查询点之前的前缀最大值, 可以使用树状数组维护前缀最大值. 离散算法(递推):将查询点和价格点放在一起排序, 相同价格的话查询点放在后面. 这样每个查询点之前的价格点是确定的, 使用一个变量遍历递推一下即可. Code1234567891011121314151617181920212223242526272829// 离线算法: 排序 + 递推using TII = tuple&lt;int, int, int&gt;;class Solution {public: vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; nums, vector&lt;int&gt;&amp; qu) { vector&lt;TII&gt; all; for (auto&amp; c : nums) all.emplace_back(c[0], c[1], 0); int m = qu.size(); for (int i = 0; i &lt; m; i ++ ) all.emplace_back(qu[i], INT_MAX, i); sort(all.begin(), all.end()); int Mx = 0; vector&lt;int&gt; ans(m); for (auto&amp; [c, t, idx] : all) { // t 指示类型 if (t == INT_MAX) { ans[idx] = Mx; } else { Mx = max(Mx, t); } } return ans; }}; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 在线算法. 注意树状数组的范围要开到题目范围的两倍(查询点 + 价格点).const int N = 2e5 + 5;class Solution {public: int tr[N], M; int lowbit(int x) { return x &amp; -x; } void add(int x, int c) { for (int i = x; i &lt;= M; i += lowbit(i)) tr[i] = max(tr[i], c); } int query(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res = max(res, tr[i]); return res; } vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; nums, vector&lt;int&gt;&amp; qu) { int n = nums.size(); vector&lt;int&gt; all = qu; for (auto&amp; c : nums) all.push_back(c[0]); sort(all.begin(), all.end()); all.erase(unique(all.begin(), all.end()), all.end()); M = all.size(); auto get = [&amp;] (int x) { return lower_bound(all.begin(), all.end(), x) - all.begin() + 1; }; for (auto&amp; c : nums) { int idx = get(c[0]), val = c[1]; add(idx, val); } vector&lt;int&gt; ans; for (auto&amp; q : qu) { int idx = get(q); int cur = query(idx); ans.push_back(cur); } return ans; }}; 复杂度分析 时间复杂度$O(N * logN)$, 树状数组的查询和更新操作均为$logN$, 最多执行$N次$. 空间复杂度$O(N)$ 你可以安排的最多任务数目思路首先可以发现答案具有二段性. 若答案为k, 则所有小于等于k的任务数都能完成, 所有大于k的任务数均不能完成. 因此考虑二分答案. 这样问题转化成判断能否完成mid个任务.首先贪心的选择最强的mid个工人和最弱的mid个任务. 我们需要找到一种方式, 使得工人和任务一一匹配. 这里贪心的从小到大考虑每个工人, 若当前工人可以完成当前最弱工作, 则让工人去完成它; 若无法完成, 则这位工人需要吃药, 吃完药后我们二分的找到小于等于他体力值的最大任务, 贪心的选择这个任务给他完成. 最后判断吃药次数cnt是否不超过mid. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344// 上述贪心方式class Solution {public: int maxTaskAssign(vector&lt;int&gt;&amp; task, vector&lt;int&gt;&amp; work, int cnt, int sth) { sort(task.begin(), task.end()); sort(work.begin(), work.end()); int n = task.size(), m = work.size(); int l = 0, r = min(n, m); auto check = [&amp;] (int x) { int need = 0; multiset&lt;int&gt; st; for (int i = 0; i &lt; x; i ++ ) st.insert(task[i]); for (int i = m - x; i &lt; m; i ++ ) { int cur = work[i]; if (cur &gt;= *st.begin()) { st.erase(st.begin()); continue; } auto idx = st.lower_bound(cur + sth + 1); if (idx == st.begin()) return false; -- idx; st.erase(idx); need += 1; } return need &lt;= cnt; }; while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return r; }}; 12345678910111213141516171819202122232425262728293031323334353637383940414243// 题解区大佬的解法, 从大到小枚举任务, 贪心的选工人去完成它.class Solution {public: int maxTaskAssign(vector&lt;int&gt;&amp; task, vector&lt;int&gt;&amp; work, int cnt, int sth) { sort(task.begin(), task.end()); sort(work.begin(), work.end()); int n = task.size(), m = work.size(); int l = 0, r = min(n, m); auto check = [&amp;] (int x) { int need = 0; multiset&lt;int&gt; st; for (int i = m - x; i &lt; m; i ++ ) st.insert(work[i]); for (int i = x - 1; i &gt;= 0; i -- ) { auto it = st.lower_bound(task[i]); if (it != st.end()) { st.erase(it); continue; } need ++ ; it = st.lower_bound(task[i] - sth); if (it == st.end()) return false; st.erase(it); } return need &lt;= cnt; }; while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return r; }}; 复杂度分析 时间复杂度$O(N * log^{2}N)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2021/11/14/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D%E7%AC%AC65%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"[LeetCode-周赛]第67场双周赛","text":"Rank : 178/2923Solved : 4/4 竞赛链接 找到和最大的长度为 K 的子序列思路排序后可知最大的k个数是确定的(是哪些数以及其个数确定), 但是其相对位置是不定的. 因此需要使用某种数据结构确定后的k个值(必须选的)记录一下, 然后遍历原数组. 若当前值还可以出现, 则加入答案, 当前值出现几次减一. 若当前值不可以出现了, 跳过即可. 支持上述操作的数据结构可以是哈希表、multiset等. Code1234567891011121314151617181920class Solution {public: vector&lt;int&gt; maxSubsequence(vector&lt;int&gt;&amp; nums, int k) { vector&lt;int&gt; cc = nums; sort(cc.begin(), cc.end(), greater&lt;int&gt;()); unordered_map&lt;int, int&gt; cnt; int n = nums.size(); for (int i = 0; i &lt; k; i ++ ) cnt[cc[i]] += 1; vector&lt;int&gt; ret; for (int i = 0; i &lt; n; i ++ ) { if (cnt[nums[i]] &gt; 0) { cnt[nums[i]] -= 1; ret.push_back(nums[i]); } } return ret; }}; 复杂度分析 时间复杂度$O(N * logN)$(排序的时间复杂度) 空间复杂度$O(N)$ 适合打劫银行的日子思路很有特点的一类题型.这类题型通常求数组中满足条件限制的所有下标. 条件限制通常为该下标处左右两边的一些性质. 本题的限制在从i往左右两边看, 连续time天都必须是非递减的. 解决这类题型的通用方法一般是先将问题进行转化, 然后使用递推(动态规划), 最后遍历数组找符合要求的下标. 考虑到左右对称, 以下就以左边为例进行分析. 问题转化. i往坐看连续time天都是非递减的, 可以将问题转化成i往坐看, 最多多少天非递减. 通过将问题转化成一个最值问题, 使用最值进行判定. 递推. 记**L[i]**为在i处往左看, 非递减的最大长度. 简单动态规划即可~ 若$nums[i] &lt;= nums[i - 1]$. 则 $L[i] = L[i - 1] + 1$ 若$nums[i] &gt; nums[i - 1]$. 则 $L[i] = 0$ 遍历原数组使用 L 和 R 求解符合要求的下标即可. Code12345678910111213141516171819202122232425class Solution {public: vector&lt;int&gt; goodDaysToRobBank(vector&lt;int&gt;&amp; nums, int time){ int n = nums.size(); vector&lt;int&gt; L(n, 0), R(n, 0); for (int i = 1; i &lt; n; i ++ ) { if (nums[i] &lt;= nums[i - 1]) L[i] = L[i - 1] + 1; } for (int i = n - 2; i &gt;= 0; i -- ) { if (nums[i] &lt;= nums[i + 1]) R[i] = R[i + 1] + 1; } vector&lt;int&gt; ret; for (int i = 0; i &lt; n; i ++ ) { if (i - time &gt;= 0 and i + time &lt; n) { if (L[i] &gt;= time and R[i] &gt;= time) ret.push_back(i); } } return ret; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 引爆最多的炸弹思路做题的时候题意理解错了, 上来直接并查集求最大的联通分量. WA的很快啊! 仔细看样例1才发现, 引爆不具有对称性. A引爆B时, B不一定引爆A. 首先将问题转化成一个图论问题(有向图). 每个圆看作一个点, 每条引爆关系看作一条边. 若A能引爆B, 则从点A连出一条边指向B.考虑到数据范围很小, 构建完有向图后, 直接对每个点暴力使用DFS, 计算以该点出发最多能到的点的个数. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution {public: int vis[100005]; vector&lt;vector&lt;int&gt;&gt; g; void dfs(int u) { vis[u] = 1; for (auto&amp; v : g[u]) { if (vis[v] == 0) dfs(v); } } int maximumDetonation(vector&lt;vector&lt;int&gt;&gt;&amp; nums) { int n = nums.size(); g.resize(n); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) { if (i == j) continue; long long dist = 1ll *(nums[i][0] - nums[j][0]) * (nums[i][0] - nums[j][0]) + 1ll * (nums[i][1] - nums[j][1]) * (nums[i][1] - nums[j][1]); long long r = 1ll * nums[i][2] * nums[i][2]; if (dist &lt;= r) { g[i].push_back(j); // cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; endl; } } int ret = 1; for (int i = 0; i &lt; n; i ++ ) { memset(vis, 0, sizeof(vis)); dfs(i); int cur = 0; for (int j = 0; j &lt; n; j ++ ) if (vis[j] == 1) cur += 1; ret = max(ret, cur); } return ret; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(N)$ 序列顺序查询思路使用平衡树的Get Value By Rank即可完成, 比赛中使用了python的sortedcontainers第三方库偷鸡了. Code123456789101112131415161718192021from sortedcontainers import SortedListclass SORTracker: def __init__(self): self.sl = SortedList() self.idx = 0 def add(self, name: str, score: int) -&gt; None: self.sl.add((-score, name)) def get(self) -&gt; str: ret = self.sl[self.idx] self.idx += 1 return ret[1]# Your SORTracker object will be instantiated and called as such:# obj = SORTracker()# obj.add(name,score)# param_2 = obj.get() 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2021/12/15/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D%E7%AC%AC67%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"[LeetCode]买卖股票合集","text":"简单整理一下LeetCode上买卖股票系列题目. 包含买卖股票的最佳时机、买卖股票的最佳时机 II、买卖股票的最佳时机 III、买卖股票的最佳时机 IV、最佳买卖股票时机含冷冻期和买卖股票的最佳时机含手续费共六题. 买卖股票的最佳时机题目描述给出数组price, 其中price[i]表示第i天股票的价格. 只能选择某一天买入然后之后的某一天卖出, 求最大利润. 思路 贪心. 如果在第i天卖出, 那么一定希望买入的时候价格最低, 因此使用维护一个前缀最小值即可. 状态机动态规划 状态机关心的时当前处于何种状态, 以及所有可能的状态转移和条件 动态规划 状态定义 f[i][0][0]: 表示第i天没持有股票, 且没完成一次交易的最大利润(一定为0). f[i][1][0]: 表示第i天持有股票, 且没完成一次交易的最大利润. f[i][0][1]: 表示第i天没持有股票, 且完成一次交易的最大利润. f[i][1][1]: 表示第i天持有股票, 且完成一次交易的最大利润. 状态转移 $f[i][0][0] = f[i - 1][0][0] = 0$ $f[i][1][0] = max(f[i - 1][1][0], -price[i])$, 表示要么是第i - 1天持有, 要么是第i天买入. $f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + price[i])$, 表示要么是第i - 1天完成一次交易, 要么是第i天卖出后完成了一次交易. $f[i][1][1] = max(f[i - 1][1][1], f[i - 1][0][1] - price[i])$, 表示要么是第i - 1天持有, 要么是第i天买入. 使用三维的原因是必须保证只能完成一次交易, 因此需要对状态进行拆分. 状态的表示是持有股票或不持有股票, 而买入卖出是动作, 是状态转移的条件. 状态初始化中, 由于第一天无法完成一次交易, 因此$f[1][0][1]=f[1][1][1]=-INF$. 由于$f[i][1][1]$无法转移到其他任何状态, 而且其也不会是答案, 因此其为无效状态, 无需计算. Code1234567891011121314151617/* 贪心思路, 记录前缀最小值即可. 时间复杂度O(N) 空间复杂度O(1)*/class Solution {public: int maxProfit(vector&lt;int&gt;&amp; p) { // ans至少为0, 即可以不买不卖 int ans = 0, mn = p[0]; for (int i = 1; i &lt; (int)p.size(); i ++ ){ ans = max(ans, p[i] - mn); mn = min(mn, p[i]); } return ans; }}; 1234567891011121314151617// 状态机动态规划const int N = 1e5 + 5;class Solution {public: int f[N][2][2]; int maxProfit(vector&lt;int&gt;&amp; p) { int n = p.size(); f[1][0][1] = f[1][1][1] = -1e9; f[1][1][0] = -p[0]; for (int i = 2; i &lt;= n; i ++ ) { f[i][0][0] = f[i - 1][0][0]; f[i][1][0] = max(f[i - 1][1][0], -p[i - 1]); f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + p[i - 1]); } return max(f[n][0][1], f[n][0][0]); }}; 复杂度分析(状态机动态规划) 时间复杂度$O(N)$ 空间复杂度$O(N)$ 买卖股票的最佳时机 II题目描述基本题意与第一题相同, 只是多了个条件: 可以完成任意交易. 思路 本题无需关注交易次数, 只需关注在每个时间点所处的状态以及所有可能的转移及条件, 因此简单修改第一题状态机动态规划做法即可. 状态机动态规划 状态定义: f[i][0]: 表示第i天没持有股票时候的最大收益 f[i][1]: 表示第i天持有股票时候的最大收益 状态转移: $f[i][0] = max(f[i - 1][0], f[i - 1][1] + price[i])$, 表示第i天不持有可以从第i - 1天不持有或者第i - 1天持有但第i天卖掉转移而来. $f[i][1] = max(f[i - 1][1], f[i - 1][0] - price[i])$, 表示第i天持有可以从第i - 1天持有或者第i - 1天不持有但第i天买入转移而来. 最终答案: f[n][0] Code12345678910111213class Solution {public: int maxProfit(vector&lt;int&gt;&amp; p) { int n = p.size(); vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(2, 0)); f[0][0] = 0, f[0][1] = -p[0]; for (int i = 1; i &lt; n; i ++ ){ f[i][0] = max(f[i - 1][0], f[i - 1][1] + p[i]); f[i][1] = max(f[i - 1][1], f[i - 1][0] - p[i]); } return f[n - 1][0]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 买卖股票的最佳时机 III题目描述基本题意与第一题相同, 只是多了个条件: 最多完成两笔交易. 思路 第一题解法中使用三维状态来标记完成交易的次数, 本题只是第一题的简单扩展, 在第一题基础上稍加修改即可. 状态机动态规划 状态定义: $f[i][0][0]$: 表示第i天不持有股票, 且完成0笔交易时的最大收益(一定为0, 无效状态) $f[i][1][0]$: 表示第i天持有股票, 且完成0笔交易时的最大收益 $f[i][0][1]$: 表示第i天不持有股票, 且完成1笔交易时的最大收益 $f[i][0][2]$: 表示第i天不持有股票, 且完成2笔交易时的最大收益 $f[i][1][1]$: 表示第i天持有股票, 且完成1笔交易时的最大收益 $f[i][1][2]$: 表示第i天持有股票, 且完成2笔交易时的最大收益(无效状态) 状态转移: $f[i][1][0] = max(f[i - 1][1][0], f[i - 1][0][0] - p[i])$, 表示第i天持有可以从第i - 1天持有或者第i - 1天不持有但第i天买入转移而来. $f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + p[i])$, 转移同上, 要么前一天同状态转移过来, 要么前一天某状态通过买入/卖出转移过来. $f[i][0][2] = max(f[i - 1][0][2], f[i - 1][1][1] + p[i])$ $f[i][1][1] = max(f[i - 1][1][1], f[i - 1][0][1] - p[i])$ 由于第一天无法完成交易, 因此需要初始化第一天的某些状态为非法状态. Code12345678910111213141516171819202122232425const int N = 1e5 + 5;class Solution {public: int f[N][2][3]; int maxProfit(vector&lt;int&gt;&amp; p) { int n = p.size(); // 初始化 // 第一天持有股票 f[1][1][0] = -p[0]; // 第一天无法完成交易 f[1][0][1] = f[1][0][2] = f[1][1][1] = f[1][1][2] = -1e9; for (int i = 2; i &lt;= n; i ++ ) { int cur = p[i - 1]; // 第i天有股票, 交易了0次 f[i][1][0] = max(f[i - 1][1][0], - cur); // 第i天无股票, 交易了1次 f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + cur); // 第i天无股票, 交易了2次 f[i][0][2] = max(f[i - 1][0][2], f[i - 1][1][1] + cur); // 第i天有股票, 交易了1次 f[i][1][1] = max(f[i - 1][1][1], f[i - 1][0][1] - cur); } return max({f[n][0][0], f[n][0][1], f[n][0][2]}); }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 买卖股票的最佳时机 IV题目描述基本题意与第一题相同, 只是多了个条件: 最多完成k笔交易. 思路 第一题状态机动态规划解法与第三题的推广版本, 完全一致的思路, 照抄即可. 状态机动态规划 状态定义: $f[i][0][j]$: 表示第i天不持有股票, 且完成j笔交易时的最大收益 $f[i][1][j]$: 表示第i天持有股票, 且完成j笔交易时的最大收益 状态转移: $f[i][0][j] = max(f[i - 1][0][j], f[i - 1][1][j - 1] + p[i])$ $f[i][1][j] = max(f[i - 1][1][j], f[i - 1][0][j] - p[i])$ Code1234567891011121314151617181920212223const int N = 1010, K = 110;class Solution {public: int f[N][2][K]; int maxProfit(int k, vector&lt;int&gt;&amp; p) { memset(f, -0x3f, sizeof(f)); int n = p.size(); for (int i = 0; i &lt;= n; i ++ ) f[n][0][0] = 0; for (int i = 1; i &lt;= n; i ++ ) { int cur = p[i - 1]; f[i][1][0] = max(f[i - 1][1][0], -cur); for (int j = 1; j &lt;= k; j ++ ) { f[i][0][j] = max(f[i - 1][0][j], f[i - 1][1][j - 1] + cur); f[i][1][j] = max(f[i - 1][1][j], f[i - 1][0][j] - cur); } } int ans = 0; for (int i = 1; i &lt;= k; i ++ ) ans = max(ans, f[n][0][i]); return ans; }}; 复杂度分析 时间复杂度$O(N * K)$ 空间复杂度$O(N * K)$ 最佳买卖股票时机含冷冻期题目描述基本题意与第一题相同, 只是多了条件: 可以买卖任意次, 但卖出股票后，无法在第二天买入股票 (即冷冻期为 1 天)。 思路 基本为第二题的扩展. 考虑如何将冷冻期为 1 天用状态表达出来即可. 状态机动态规划 状态定义: $f[i][0]$: 表示第i天不持有股票, 且无冷冻期, 时候的最大收益. $f[i][1]$: 表示第i天不持有股票, 且在冷冻期(第i - 1天卖出), 时候的最大收益. $f[i][2]$: 表示第i天持有股票时候的最大收益 状态转移: $f[i][0] = max(f[i - 1][0], f[i - 1][1])$ $f[i][1] = f[i - 1][2] + p[i]$ $f[i][2] = max(f[i - 1][2], f[i - 1][0] - p[i])$ Code12345678910111213141516class Solution {public: int maxProfit(vector&lt;int&gt;&amp; p) { int n = p.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(3, 0)); // 初始化: f[1][1] = -1e9; f[1][2] = -p[0]; for (int i = 2; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][2] + p[i - 1]; f[i][2] = max(f[i - 1][2], f[i - 1][0] - p[i - 1]); } return max(f[n][0], f[n][1]); }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 买卖股票的最佳时机含手续费题目描述基本题意与第一题相同, 只是多了条件: 可以买卖任意次, 且一次买入卖出需要支付手续费。 思路 第二题的简单扩展. 卖出阶段支付手续费即可. 状态机动态规划 状态定义: $f[i][0]$: 表示第i天不持有股票时候的最大收益. $f[i][1]$: 表示第i天持有股票时候的最大收益. 状态转移: $f[i][0] = max(f[i - 1][0], f[i - 1][1] + p[i] - fee)$ $f[i][1] = max(f[i - 1][1], f[i - 1][0] - p[i])$ Code123456789101112131415const int N = 1e5 + 5;class Solution {public: int f[N][2]; int maxProfit(vector&lt;int&gt;&amp; p, int fee) { int n = p.size(); f[1][1] = -p[0]; for (int i = 2; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1] + p[i - 1] - fee); f[i][1] = max(f[i - 1][1], f[i - 1][0] - p[i - 1]); } return f[n][0]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 参考资料 B站yxc 欢迎讨论指正","link":"/2021/11/23/algo/LeetCode/%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/%5BLeetCode%5D%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E5%90%88%E9%9B%86/"},{"title":"[LeetCode]打家劫舍合集","text":"简单整理一下LeetCode上打家劫舍系列题目, 该系列作为状态机动态规划的入门题相当的好. 打家劫舍题目描述有一行非负数, 不能选连续两个数, 求选的数之和的最大值. 思路整体思路上使用状态机的思路解决. 状态机关心的是当前处于何种状态, 所有可能的状态转移方式与条件. 结合本题, 我们使用状态机动态规划解决本题. 动态规划 状态定义: $f[i][0]$表示考虑了前i个数, 且不拿i号位置的情况下取得的最大价值 $f[i][1]$表示考虑了前i个数, 且拿i号位置的情况下取得的最大价值 状态转移: 若不拿i号位置, 则i - 1位置可拿可不拿, 因此$f[i][0] = max(f[i - 1][0], f[i - 1][1])$ 若拿i号位置, 则i - 1位置必不能被拿, 因此$f[i][1] = f[i - 1][0] + nums[i]$ 最后的答案为$max(f[n][0], f[n][1])$ 任何一种拿与不拿的决策, 均对应于有限状态机中不同状态之间的一条转移边. Code12345678910111213// 上述解法class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(2, 0)); for (int i = 1; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][0] + nums[i - 1]; } return max(f[n][0], f[n][1]); }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$(注意到当前状态只依赖于上一位置状态, 因此可以使用两个变量保存上一位置状态, 优化成$O(1)$) 打家劫舍 II题目描述基本题意与第一题类型, 只不过多了一个限制: 首尾不能同时拿. 思路依照第一题的思路, 我们继续使用状态机动态规划解决. 只不过需要多一维的状态, 用于指示1号位置是否被拿, 因为这关系到最后一个位置的转移条件. 动态规划 状态定义: $f[i][0][0]$表示i号位1号位都没拿. $f[i][0][1]$表示i号位没拿, 1号位拿了. $f[i][1][0]$表示i号位拿了, 1号位没拿. $f[i][1][1]$表示i号位1号位都拿了. 状态转移： 对于$f[i][0][0]$, 则$i - 1$位无限制, 因此$f[i][0][0] = max(f[i - 1][1][0], f[i - 1][0][0])$. 对于$f[i][0][1]$, 则$i - 1$位无限制, 因此$f[i][0][1] = max(f[i - 1][1][1], f[i - 1][0][1])$. 对于$f[i][1][0]$, 则$i - 1$位不能选, 因此$f[i][1][0] = f[i - 1][0][0] + nums[i - 1]$. 对于$f[i][1][1]$, 则$i - 1$位不能选, 因此$f[i][1][1] = f[i - 1][0][1] + nums[i - 1]$.对于i = n: 由于1号位和n号位不能同时选, 因此转移需要单独考虑. Code12345678910111213141516171819class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n + 1, vector&lt;vector&lt;int&gt;&gt;(2, vector&lt;int&gt;(2, 0))); f[1][1][1] = nums[0]; for (int i = 2; i &lt; n; i ++ ) { f[i][0][0] = max(f[i - 1][1][0], f[i - 1][0][0]); f[i][0][1] = max(f[i - 1][1][1], f[i - 1][0][1]); f[i][1][0] = f[i - 1][0][0] + nums[i - 1]; f[i][1][1] = f[i - 1][0][1] + nums[i - 1]; } // 单独考虑n号位 f[n][0][0] = max(f[n - 1][1][0], f[n - 1][0][0]); f[n][0][1] = max(f[n - 1][1][1], f[n - 1][0][1]); f[n][1][0] = f[n - 1][0][0] + nums[n - 1]; return max({f[n][0][0], f[n][0][1], f[n][1][0]}); }}; 123456789101112131415161718192021222324252627282930/* 这里简单提一下另外一种做法, 类似于第一题. 考虑到 1 和 n 不能同时被拿, 因此最优解有以下可能 1. 拿1不拿n 2. 拿n不拿1 3. 1和n不拿 因此可以考虑在1 -&gt; n - 1上和 2 -&gt; n上分别使用第一题的解法做一遍. 因为求解的是最大值, 这两个子问题有所重复的无所谓的(他们都包含第三种情况), 只需不遗漏的计算所有可能即可.*/class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(), ans = 0; if (n == 1) return nums.back(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(2, 0)); // 1 -&gt; n - 1 for (int i = 1; i &lt; n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][0] + nums[i - 1]; } ans = max({ans, f[n - 1][0], f[n - 1][1]}); // 2 -&gt; n f[1][0] = f[1][1] = 0; for (int i = 2; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][0] + nums[i - 1]; } return max({ans, f[n][0], f[n][1]}); }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 打家劫舍 III思路状态机结合树形动态规划的题目.使用树形动态规划解决. 树形动态规划 状态定义: $f[u][0]$表示考虑以u为根的子树中, 且u没被选的情况下最大价值. $f[u][1]$表示考虑以u为根的子树中, 且u被选的情况下最大价值. 状态计算 对于$f[u][0]$, 由于没有拿父节点u, 因此对于任意子节点v, 都可以考虑拿他和不拿他, 因此有转移:$$ f[u][0] = \\sum_{v \\in son[u]}max(f[v][0], f[v][1])$$ 对于$f[u][1]$, 由于拿了父节点u, 因此对于任意子节点v, 都不能拿他, 因此有转移:$$ f[u][1] = \\sum_{v \\in son[u]} f[v][0]$$ Code123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: unordered_map&lt;TreeNode*, vector&lt;int&gt;&gt; f; void dfs(TreeNode* u) { f[u] = vector&lt;int&gt;(2, 0); f[u][1] = u -&gt; val; for (auto&amp; son : {u -&gt; left, u -&gt; right}) { if (son == nullptr) continue; dfs(son); f[u][0] += max(f[son][0], f[son][1]); f[u][1] += f[son][0]; } } int rob(TreeNode* root) { dfs(root); return max(f[root][0], f[root][1]); }}; 复杂度分析 时间复杂度$O(N)$: DFS过程中, 每个节点只会被遍历一次 空间复杂度$O(N)$ 参考资料 B站yxc 欢迎讨论指正","link":"/2021/11/19/algo/LeetCode/%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/%5BLeetCode%5D%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%90%88%E9%9B%86/"},{"title":"[LeetCode]跳跃游戏合集","text":"简单整理一下LeetCode上跳跃游戏系列题目. 包含跳跃游戏、跳跃游戏II、跳跃游戏III、跳跃游戏IV、跳跃游戏V、跳跃游戏VI、跳跃游戏VII共七题. 跳跃游戏题目描述开始位于1号点, 每次在i号点最远可以跳跃nums[i]单位距离, 判断能否跳到n号点. 思路 我们可以把每个下标看成一个点, 每次在i号点跳跃认为是从i连边到j, 且$j\\in [max(1, i - nums[i]),\\ min(n, i + nums[i])]$. 这样问题转化成判断是否存在至少一条从1号点到n号点的路径, 即1号点与n号点是否联通. 暴力使用BFS等算法求解的时候, 正确性是毫无疑问的, 但时间复杂度过高$O(N^2)$, 会TLE. 暴力时间复杂度高的原因是: 每个点会被遍历多次, 如果优化每个点被遍历的次数, 那么问题就得到了解决. 结合题意, 有以下观察: 如果当前位于i号点, 那么1 - i之间的所有点已经可达了(即被遍历过了). 假设是从j点跳到了i点($j &lt; i$), 那么j - i之间的所有点可以被j遍历到, 问题规模减小到1 - j, 归纳下去即可证明. 有了观察1, 当我们位于i号点的时候, 只需关心它向右能跳到的点. i向右最远能跳到$R = min(n, i + nums[i])$. 我们从R倒着向i遍历: 若该点没被访问过, 置为True, 继续向前遍历. 若该点已经被访问过了, 则可由观察1得到, 该点左边的点全被访问过, 退出循环即可. 最终对于每个点, 我们至多遍历一次. Code12345678910111213141516// 写法1class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;bool&gt; f(n, false); f[0] = true; for (int i = 0; i &lt; n; i ++ ) if (f[i]){ int j = min(n - 1, nums[i] + i); while (f[j] == false) f[j --] = true; } return f[n - 1]; }}; 123456789101112131415161718192021/* 写法2:稍微优化上述写法 记录可行的跳的最远的位置 Mx 是哪 利用观察1, 只要当前点i &lt;= Mx, 则当前点一定可达.*/class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;bool&gt; f(n, false); f[0] = true; int Mx = nums[0]; for (int i = 1; i &lt; n; i ++ ) { if (Mx &gt;= i) { f[i] = true; Mx = max(Mx, i + nums[i]); } } return f[n - 1]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 跳跃游戏 II题目描述开始位于1号点, 每次在i号点最远可以跳跃nums[i]单位距离, 判断跳到n号的最少跳跃次数(保证可以到达). 思路有了第一题的分析过程, 这题可以很自然的使用第一题的分析思路: 只需求1号点到n号点的最短路. 利用BFS的性质: 每个点第一次被遍历的时候一定是该点的最短距离. 用第一题思路实现即可. Code12345678910111213141516// 解法1: 上述思路的实现class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n, -1); f[0] = 0; for (int i = 0; i &lt; n; i ++ ) { int R = min(n - 1, i + nums[i]); while (f[R] == -1) f[R --] = f[i] + 1; } return f[n - 1]; }}; 12345678910111213141516171819202122232425262728293031/* 解法2： 简单提一下另外一种思路: dp或者最短路的想法 使用优先队列记录所有可达的点的信息: 最短距离以及它所能跳到的最远点 当遍历到i的时候, 贪心的从优先队列中取最短距离最小的点： 若它能到到达i, 则更新i 否则直接弹出优先队列, 因为它不可能更新i之后的任意一个点. 这样每个点最多 入/出 优先队列一次. 时间复杂度为 O(N * logN) 空间复杂度为 O(N)*/class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { int n = size(nums); vector&lt;int&gt; f(n, 1e9); priority_queue&lt;pair&lt;int, int&gt;&gt; heap; heap.emplace(0, nums[0]); f[0] = 0; for (int i = 1; i &lt; n; i ++ ){ auto [t, ed] = heap.top(); while (heap.size() &amp;&amp; ed &lt; i){ heap.pop(); t = heap.top().first; ed = heap.top().second; } f[i] = -t + 1; heap.emplace(-f[i], i + nums[i]); } return f[n - 1]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 跳跃游戏 III题目描述开始位于start号点, 每次在i号点可以跳到i + nums[i]或i - nums[i], 判断能否跳到nums[k] = 0的某个点. 思路有了前面题目的分析, 这题就是简单的BFS. 每个点最多出去两条边, 暴力BFS即可. Code1234567891011121314151617181920212223242526class Solution {public: bool canReach(vector&lt;int&gt;&amp; arr, int st) { int n = arr.size(); vector&lt;bool&gt; f(n, false); queue&lt;int&gt; qu; f[st] = true; qu.push(st); while (qu.size()) { auto t = qu.front(); qu.pop(); if (t + arr[t] &lt; n and t + arr[t] &gt;= 0 and f[t + arr[t]] == false) f[t + arr[t]] = true, qu.push(t + arr[t]); if (t - arr[t] &lt; n and t - arr[t] &gt;= 0 and f[t - arr[t]] == false) f[t - arr[t]] = true, qu.push(t - arr[t]); } bool flag = false; for (int i = 0; i &lt; n; i ++ ) { if (arr[i] == 0 and f[i]) flag = true; } return flag; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 跳跃游戏 IV题目描述开始位于1号点, 每次在i号点可以跳到i + 1、i - 1、j(满足nums[i] == nums[j]), 求解跳到n号点的最短步数. 思路题目求解的是最短路, 自然就往最短路算法上想(BFS、Dijkstra等). 由于本题边权均为1, 因此考虑使用BFS算法求解. 由题目可知, 所有值相同的点之间存在一条代价为1的边. 因此我们先使用哈希表得到所有值相同的点, 接着BFS即可. 注意优化的一点: BFS第一次遍历到的时候, 其最短路就已经确定了. 因此我们遍历了一遍某一个值相同的集合后, 直接从哈希表删除该集合即可. Code12345678910111213141516171819202122232425262728293031const int INF = 1e8;class Solution {public: int minJumps(vector&lt;int&gt;&amp; arr) { unordered_map&lt;int, vector&lt;int&gt;&gt; mp; int n = arr.size(); for (int i = 0; i &lt; n; i ++ ) { int c = arr[i]; mp[c].push_back(i); } vector&lt;int&gt; f(n, INF); queue&lt;int&gt; qu; f[0] = 0; qu.push(0); while (qu.size()) { auto t = qu.front(); qu.pop(); if (t + 1 &lt; n and f[t + 1] == INF) f[t + 1] = f[t] + 1, qu.push(t + 1); if (t - 1 &gt;= 0 and f[t - 1] == INF) f[t - 1] = f[t] + 1, qu.push(t - 1); for (auto&amp; c : mp[arr[t]]) { if (f[c] == INF) f[c] = f[t] + 1, qu.push(c); } mp.erase(arr[t]); } return f[n - 1]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 跳跃游戏 V题目描述在i号点可以跳到j号的要求是: arr[i] &gt; arr[j] $abs(i - j) &lt;= d$ $i - j$ 之间除i以外的点的值均小于$arr[i]$ 可以从任意点开始, 求解最多能跳多少个点. 思路 观察到数据范围为1000, 因此使用$O(N^2)$的算法求解即可. 依然利用前面题目的思路, 将每个下标视作一个点. i号点能跳到j号点, 则认为存在i指向j的一条有向边. 关键的约束条件为$arr[i] &gt; arr[j]$, 这样的话构建出的图一定为有向无环图(DAG). 问题转化成求有向无环图上的一条最长路径. 因为存在拓扑序, 因此按照序列递推(动态规划, DP)求解即可. 定义f[u]为走到u点时的最大值. 若存在有向边$v \\rightarrow u$, 则有: $$f[u] = max(f[u], f[v] + 1)$$ 因为按照拓扑序的顺序递推, 因此当计算u点时, 其所依赖的点v已经全部被计算过了, 保证了正确性. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {public: int maxJumps(vector&lt;int&gt;&amp; arr, int d) { int n = arr.size(); vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, 0)); vector&lt;int&gt; in(n, 0), f(n, 1); // O(n^2)预处理有向边 for (int i = 0; i &lt; n; i ++ ) { // L for (int j = i - 1, Mx = arr[i] - 1; j &gt;= max(0, i - d); j -- ) { Mx = max(Mx, arr[j]); if (Mx &gt;= arr[i]) break; g[i][j] = 1; in[j] ++ ; } // R for (int j = i + 1, Mx = arr[i] - 1; j &lt;= min(n - 1, i + d); j ++ ) { Mx = max(Mx, arr[j]); if (Mx &gt;= arr[i]) break; g[i][j] = 1; in[j] ++ ; } } // 拓扑排序 + 递推(DP) queue&lt;int&gt; qu; for (int i = 0; i &lt; n; i ++ ) { if (in[i] == 0) qu.push(i); } while (qu.size()) { auto t = qu.front(); qu.pop(); for (int i = 0; i &lt; n; i ++ ) { // t 能走到 i 点 if (g[t][i]) { f[i] = max(f[i], f[t] + 1); if (-- in[i] == 0) qu.push(i); } } } int ans = 0; for (int i = 0; i &lt; n; i ++ ) ans = max(ans, f[i]); return ans; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(N)$ 跳跃游戏 VI题目描述开始位于1号点, 每次最多往前跳k步, 求跳到n时的最大得分(最大数字之和). 思路 动态规划: 状态表示: 定义f[i]为走到i点时的最大得分. 答案即位f[n]. 状态计算：依据题目要求, 最多跳k步, 因此 $$ f[i] = max(f[j] + nums[i]), \\ j \\in [max(1, i - k), i - 1]$$ 朴素状态转移复杂度是$O(K)$, 会超时. 注意到转移要求的是滑动窗口内的最大值. 因此可以利用单调队列或优先队列(类似第二题解法2)优化. Code1234567891011121314151617181920class Solution {public: int maxResult(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;int&gt; f(n, 0); deque&lt;int&gt; dq; for (int i = 0; i &lt; n; i ++ ) { if (dq.size() and i - dq.front() &gt; k) dq.pop_front(); f[i] = nums[i]; if (dq.size()) f[i] = nums[i] + f[dq.front()]; while (dq.size() and f[dq.back()] &lt; f[i]) dq.pop_back(); dq.push_back(i); } return f[n - 1]; }}; 复杂度分析 时间复杂度$O(N)$(单调队列)、$O(N * logN)$(优先队列) 空间复杂度$O(N)$ 跳跃游戏 VII题目描述开始位于1号点, 每次向前跳的距离有限制, 判断能否跳到n号点. 思路 使用动态规划解决. 定义f[i]为是否能够跳到i位置, 只需判断是否存在$j \\in [i - maxJump, i - minJump]$, 使得$f[j] = True$成立. 为了快速判断是否存在j, 使用前缀和的思想. 记$s[i] = \\sum_{j = 0}^{i}f[i]$. 这样每次只需判断是否有$s[i - minJump] - s[i - maxJump - 1] &gt; 0$成立即可. Code12345678910111213141516class Solution {public: bool canReach(string str, int Mn, int Mx) { int n = str.size(); vector&lt;int&gt; f(n + 1, 0), s(n + 1, 0); f[1] = s[1] = 1; for (int i = 2; i &lt;= n; i ++ ) { if (str[i - 1] == '0') { if (s[max(0, i - Mn)] - s[max(0, i - Mx - 1)]) f[i] = 1; } s[i] = s[i - 1] + f[i]; } return f[n]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$","link":"/2021/11/17/algo/LeetCode/%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/%5BLeetCode%5D%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E5%90%88%E9%9B%86/"},{"title":"[LeetCode-1181]使数组严格递增","text":"原题链接 题目描述给定两个数组, 计算使得数组A严格递增的操作次数。 一次操作定义为: 选数组B任意一个数, 替换数组A任意一个数。 约定 arr1数组认为是数组A, 其长度为n arr2数组认为是数组B, 其包含不重复的元素个数为m 数组下标均从1开始 思路 一些观察: 数组B中的重复数是没有用的. 如果使用数组B中的重复数, 要么导致数组A不严格单调递增(操作到了不同位置), 要么导致操作次数增加(操作到了同一位置). 数组B的顺序是无所谓的. 问题转化 有了上述观察, 我们可以将问题首先进行转化. 首先将数组B中的重复元素去掉, 并对数组B排序, 记为$B’$. 这样问题可以转化成: 从数组$A$和数组$B’$(严格单调递增)中找到一条长度为$n$且严格单调递增的路线, 且路线上从A跳到B'的次数最少 转化后的问题可以使用动态规划来解决 动态规划 状态表示: $f[i][j][0]$:表示路线走了长度i, 考虑了数组$B’$的前j个数, 且最后走到数组$A$的i位置上. $f[i][j][1]$:表示路线走了长度i, 考虑了数组$B’$的前j个数, 且最后走到数组$B’$的j位置上. 状态计算: 根据定义首先有: $f[i][j][0]$ = $f[i][j - 1][0]$ 若$A[i] &gt; A[i - 1]$, 则有$f[i][j][0]$ = $f[i - 1][j][0]$ 若 $A[i] &gt; B’[j]$, 则有$f[i][j][0]$ = $f[i - 1][j][1]$ 对于$f[i][j][1]$: 若$B’[j] &gt; A[i - 1]$, 则有$f[i][j][1]$ = $f[i - 1][j - 1][0] + 1$. 表示第i步从$A$数组的i - 1位置跳到了$B’$的j位置 若$B’[j] &gt; B[j - 1]$, 则有$f[i][j][1]$ = $f[i - 1][j - 1][1] + 1$. 表示第i步从$B’$数组的j - 1位置跳到了$B’$的j位置 最后的答案 若最后一步在$A$数组上, 则答案为$f[n][m][0]$. 若最后一步在$B’$数组上, 枚举$f[n][j][1]$, 其中$j\\in[0, m)$. Code1234567891011121314151617181920212223242526272829303132333435363738const int N = 2010, INF = 0x3f3f3f3f;class Solution {public: int f[N][N][2]; int makeArrayIncreasing(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) { memset(f, 0x3f, sizeof(f)); sort(arr2.begin(), arr2.end()); arr2.resize(unique(arr2.begin(), arr2.end()) - arr2.begin()); int n = arr1.size(), m = arr2.size(); for (int i = 0; i &lt;= m; i ++ ) { f[0][i][0] = f[1][i][0] = 0; if (i) f[1][i][1] = 1; } for (int i = 2; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) { f[i][j][0] = f[i][j - 1][0]; if (arr1[i - 1] &gt; arr1[i - 2]) f[i][j][0] = min(f[i][j][0], f[i - 1][j][0]); if (arr1[i - 1] &gt; arr2[j - 1]) f[i][j][0] = min(f[i][j][0], f[i - 1][j][1]); if (arr2[j - 1] &gt; arr1[i - 2]) f[i][j][1] = f[i - 1][j - 1][0] + 1; if (j &gt;= 2 and arr2[j - 1] &gt; arr2[j - 2]) f[i][j][1] = min(f[i][j][1], f[i - 1][j - 1][1] + 1); } int ans = INF; for (int i = 1; i &lt;= m; i ++ ) ans = min({ans, f[n][i][0], f[n][i][1]}); if (ans == INF) ans = -1; return ans; }}; 复杂度分析 时间复杂度$O(n^2)$ 空间复杂度$O(n^2)$ 欢迎讨论指正","link":"/2021/11/11/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-1181%5D%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/"},{"title":"[LeetCode-1218]最长定差子序列","text":"原题链接 题目描述求数组中最长的等差子序列的长度, 且公差为定值 思路 因为公差为定值, 因此当子序列最后一个数确定时, 倒数第二个数一定是确定的, 我们可以使用一个数来代表所有以倒数第二个数为结尾的最长等差子序列. 使用动态规划解决： 状态表示: $f[i]$表示以i为结尾的最长的等差子序列 状态转移: $f[i] = f[i - d] + 1$ Code123456789101112class Solution {public: int longestSubsequence(vector&lt;int&gt;&amp; arr, int d) { unordered_map&lt;int, int&gt; f; int ans = 0; for (auto&amp; c : arr) { f[c] = 1 + f[c - d]; ans = max(ans, f[c]); } return ans; }}; 复杂度分析 时间复杂度$O(n)$ 空间复杂度$O(n)$ 欢迎讨论指正","link":"/2021/11/08/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-1218%5D%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"[LeetCode-237]删除链表中的节点","text":"原题链接 题目描述给出单链表的某个非尾节点, 删除该节点 思路 由于给出的是单链表, 所以我们无法得知被删除节点的前驱节点信息, 只能”曲线救国” 可以将值向前平移一个单位, 删除末尾节点即可 Code1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: void deleteNode(ListNode* node) { // 当前节点不为尾节点, 所以一定有后继节点 ListNode* Nxt = node -&gt; next; ListNode* cur = node; ListNode* prev = nullptr; // 还有后继节点的时候, 进行值前移 while (Nxt) { cur -&gt; val = Nxt -&gt; val; prev = cur; cur = Nxt; Nxt = Nxt -&gt; next; } // 最后删除尾节点即可（退出循环的时候, cur指向尾节点, Nxt为nullptr, 而prev指向尾节点之前的节点） prev -&gt; next = nullptr; }}; 复杂度分析 时间复杂度$O(N)$, 遍历一遍链表即可完成删除操作 空间复杂度$O(1)$, 只使用常数空间存储指针变量Nxt、cur、prev即可","link":"/2021/11/02/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-237%5D%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"title":"[LeetCode-319]灯泡开关","text":"原题链接 题目描述给出n个灯泡(初始全部熄灭)并且操作n次, 第i次把所有是i的倍数处的灯泡的开关状态取反. 求n次操作后亮着的灯泡数目. 思路 考虑某一个灯泡i在n次操作中被操作的次数, 可以发现该灯泡会被它的所有因子操作. 比如8会在第1、2、4、8次操作时操作. 若一个灯泡被操作k次, 那么该灯泡一定有k个不同的因子. 且该灯泡最后的状态唯一取决于k的奇偶. 即若k为偶数则灭, k为奇数则亮. 问题转化成求$1 - N$中含有奇数个不同因子的数的个数. 考虑到所有因子都是成对出现的, 若数K有奇数个不同的因子, 那么某个因子一定出现两次, 该因子一定是$\\sqrt K$, 即K必为完全平方数. 最后问题转化成求$1 - N$中完全平方数的个数. Code123456789101112using LL = long long;class Solution {public: int bulbSwitch(int n) { if (n == 0) return 0; int cnt = 0; for (LL i = 1; i * i &lt;= n; i ++ ) cnt ++ ; return cnt; }}; 复杂度分析 时间复杂度$O(\\sqrt N)$ 空间复杂度$O(1)$ 欢迎讨论指正","link":"/2021/11/15/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-319%5D%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3/"},{"title":"[LeetCode-575]分糖果","text":"原题链接 题目描述总共有偶数个数字, 从中选择一半的数字且数字的种类最多. 思路 贪心: 总共选的数字的个数是固定的, 对于每一种数字可以贪心的只选择一个, 这样后面可供选择的余地就越大. Code123456789101112class Solution {public: int distributeCandies(vector&lt;int&gt;&amp; nums) { // 哈希表统计每个数字的个数 unordered_map&lt;int, int&gt; mp; for (auto&amp; num : nums) mp[num] ++ ; int s = nums.size() / 2; return min(s, (int)mp.size()); }}; 复杂度分析 时间复杂度$O(n)$, 只需遍历数组统计类别 空间复杂度$O(n)$, 哈希表所需空间为$O(n)$ 欢迎讨论指正","link":"/2021/11/01/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-575%5D%E5%88%86%E7%B3%96%E6%9E%9C/"},{"title":"[LeetCode-598]范围求和II","text":"原题链接 题目描述多次给矩阵M的某个子矩阵全部加1, 求最后矩阵中最大值出现的次数 思路 注意到关键的一点: 每次加的子矩阵的左上角均为[0, 0], 因此n次操作后, 最大值一定全部出现在以[0, 0]为左上角的某个子矩阵中, 我们只需确定这个子矩阵的长宽即可 这个子矩阵其实是每次操作的交集, 只有这个交集中的位置才能保证每次都被加1 x和y操作的交集是独立的, 分开求解即可 Code1234567891011class Solution {public: int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) { int x = m, y = n; for (auto&amp; op : ops) { x = min(x, op[0]); y = min(y, op[1]); } return x * y; }}; 复杂度分析 时间复杂度$O(N * M)$: 遍历矩阵即可求出答案 空间复杂度$O(1)$: 仅需常数空间存储x和y的交集 欢迎讨论指正","link":"/2021/11/07/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-598%5D%E8%8C%83%E5%9B%B4%E6%B1%82%E5%92%8CII/"},{"title":"[LeetCode-629]K个逆序对数组","text":"原题链接 题目描述由 $1-n$ 组成的排列中, 有多少个排列的逆序对个数是 $k$ 思路看完题目和数据范围基本就能确定是动态规划. 因为可行方案可能很多很多, 无法枚举. 而从集合角度1(动态规划)进行计算, 会帮助我们省去很多不必要的枚举. 使用一个数来表示一类有共同点的方案, 是动态规划优化问题的特点. 动态规划 状态表示: $f[i][j]$ : 表示考虑前 $1 - i$ 个数, 且逆序对个数为 $j$ 时的方案数. 状态计算:状态计算的思路是枚举最后一个不同点1: 即考虑将数字i放在什么位置. 放置i位置的可能方式如下: 由上图可见, 若将 $i$ 放置在 $i - k$下标处, 这会造成 $k - 1$个逆序对(数 $i$与 下标$\\in[i - k + 1, i]$处的数构成逆序对) 因此可得: $f[i][j]$ = $\\sum_{k=0}^{i - 1} f[i - 1][j - k]$ 由上分析可见, 状态为$O(n^2)$, 转移为$O(n)$, 总时间复杂度为$O(n^3)$, 会超时. 利用前缀和优化状态转移: 记$s[i][j]$ = $\\sum_{k=0}^j f[i][k]$, 可得状态计算：$$ $$ Code1234567891011121314151617181920212223const int N = 1010, MOD = 1e9 + 7;class Solution {public: int f[N][N], s[N][N]; int kInversePairs(int n, int k) { for (int i = 0; i &lt;= n; i ++ ) f[i][0] = s[i][0] = 1; for (int i = 1; i &lt;= n; i ++ ) { for (int j = 1; j &lt;= k; j ++ ) s[i - 1][j] = (s[i - 1][j - 1] + f[i - 1][j]) % MOD; for (int j = 1; j &lt;= k; j ++ ) { if (i &gt; j) f[i][j] = s[i - 1][j]; else f[i][j] = (s[i - 1][j] - s[i - 1][j - i]) % MOD; } } int ans = f[n][k]; ans = (ans + MOD) % MOD; return ans; }}; 复杂度分析 时间复杂度$O(N * K)$ 空间复杂度$O(N * K)$ 参考资料 [1] B站yxc 欢迎讨论指正","link":"/2021/11/11/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-629%5DK%E4%B8%AA%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E7%BB%84/"},{"title":"[LeetCode-869]重新排序得到2的幂","text":"原题链接 题目描述判断一个数字重新排列后能否成为2的某个幂次. 思路 模拟: 考虑到数据范围很小, 我们可以暴力枚举该数的所有排列, 然后判断该数是否为2的幂次. 模拟: 考虑到2的幂次的个数很少, 我们可以首先预处理出来所有的2的幂次, 然后判断该数是否为某个2的幂次。由于数字可以重新排列, 因此只需记录词频, 即若两个数词频相同, 则一个数一定可以通过重新排列变成另外一个数. Code 解法一123456789101112131415161718192021222324252627282930class Solution {public: static const int M = 11; // 辅助函数: 获取x的十进制表示 vector&lt;int&gt; get(int x) { vector&lt;int&gt; ret; while (x) { ret.push_back(x % 10); x /= 10; } return ret; } bool reorderedPowerOf2(int n) { // 记录所有合法方案的十进制表示 set&lt;vector&lt;int&gt;&gt; st; for (int i = 0; i &lt; 31; i ++ ) st.insert(get(1 &lt;&lt; i)); vector&lt;int&gt; cur = get(n); sort(cur.begin(), cur.end()); int ret = 0; // cpp利用next_permutation()函数暴力枚举该数的所有排列 do { ret += st.count(cur); } while (next_permutation(cur.begin(), cur.end())) ; return ret; }}; 解法二123456789101112131415161718192021222324class Solution {public: static const int M = 11; // 辅助函数: 统计数x的词频 vector&lt;int&gt; get(int x) { vector&lt;int&gt; ret(M, 0); while (x) { ret[x % 10] ++ ; x /= 10; } return ret; } bool reorderedPowerOf2(int n) { // 预处理所有合法的方案的词频 set&lt;vector&lt;int&gt;&gt; st; for (int i = 0; i &lt; 31; i ++ ) st.insert(get(1 &lt;&lt; i)); // 获得当前数的词频 vector&lt;int&gt; cur = get(n); if (st.find(cur) != st.end()) return true; return false; }}; 复杂度分析(解法2)其中C为30, N为1e9. 时间复杂度$O(ClogN)$, 首先预处理所有合法方案$O(ClogN)$, 接着查set表$O(logC * logN)$ 空间复杂度$O(ClogN)$, 使用set存储所有合法的2的幂次的词频, 共有C个合法方案, 每个方案的长度不超过logN 欢迎讨论指正","link":"/2021/10/28/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-869%5D%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/"}],"tags":[{"name":"工具软件","slug":"工具软件","link":"/tags/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"字符串分割","slug":"字符串分割","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/"},{"name":"周赛","slug":"周赛","link":"/tags/%E5%91%A8%E8%B5%9B/"},{"name":"枚举","slug":"枚举","link":"/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"二分搜索","slug":"二分搜索","link":"/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"},{"name":"状态压缩","slug":"状态压缩","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"哈希表","slug":"哈希表","link":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"深度优先搜索","slug":"深度优先搜索","link":"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"平衡树","slug":"平衡树","link":"/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"状态机","slug":"状态机","link":"/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"优先队列","slug":"优先队列","link":"/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"}],"categories":[{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"cpp","slug":"cpp","link":"/categories/cpp/"},{"name":"algo","slug":"algo","link":"/categories/algo/"},{"name":"LeetCode","slug":"algo/LeetCode","link":"/categories/algo/LeetCode/"},{"name":"每日一题","slug":"algo/LeetCode/每日一题","link":"/categories/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"周赛","slug":"algo/LeetCode/周赛","link":"/categories/algo/LeetCode/%E5%91%A8%E8%B5%9B/"},{"name":"系列合集","slug":"algo/LeetCode/系列合集","link":"/categories/algo/LeetCode/%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/"}]}