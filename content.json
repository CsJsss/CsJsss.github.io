{"pages":[{"title":"","text":"不积跬步, 无以至千里; 不积小流, 无以成江海。 本blog用来记录我自己的学习过程和感悟, 欢迎关注。","link":"/about/index.html"},{"title":"","text":"申请友链须知 本站友链信息如下，按如下格式提供申请信息： 网站图标：https://csjsss.github.io/img/tx.JPG 网站名称：Jsss 网站地址：https://csjsss.github.io/ 网站简介：BIT-CS硕士在读 加载中...","link":"/friend/index.html"},{"title":"有什么想对我说的, 就留个言吧~","text":"","link":"/message/index.html"}],"posts":[{"title":"Windows下实用工具软件合集","text":"整理分享一下平时我在Windows下使用的实用工具软件. Everything: 文件搜索神器Everything是一款简洁轻便的文件搜索软件. 特性 界面干净简洁 快速搜索 轻量级 使用示例 PowerToys: 微软开源实用工具PowerToys是Windows下一组实用工具的集合. 由微软官方发布的免费工具集合. 包含PowerToys Run、键盘管理器(键映射)和文件资源管理器(文件预览)等多种实用工具.官方文档与教程 特性 免费开源 微软官方开发维护 使用示例 Zeal: 离线文档浏览器Zeal是针对软件开发人员的离线文档浏览器. 特性 跨平台 多语言支持 使用示例 mathpix snipping tool: 公式识别软件通过mathpix snipping tool可以很方便的截图论文中的公式, 转化为LaTex可编辑文本, 能够显著提高读写论文效率. 特性 界面简约 快速高效 使用示例 WizTree: 磁盘空间分析器WiZTree是一款高效的磁盘空间扫描分析软件, 扫描速度极快, 界面简洁易操作. 特性 界面简约、中文界面 快速高效 文件名搜索 ScreenToGif: 高效的Gif制作器ScreenToGif是便捷的制作Gif软件的工具, 上述所有演示Gif均由该软件制作。选中屏幕上的指定区域, 轻松录制一段Gif, 并且编辑的功能完善强大. 功能强大 简洁高效","link":"/2021/11/18/Windows/Windows%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%90%88%E9%9B%86/"},{"title":"[cpp]便捷的字符串分割方法","text":"前言不像python的str提供的内置split方法一样方便的进行字符串分割，c++的string模板库没有直接提供分割字符串的成员方法。偶然在看《c++prime》时看到string模板库提供getline方法, 利用方法可以实现自定义分隔符分割字符串。 使用getline进行分割getline函数接受三个参数，分别是input(the stream to get data from), str(the string to put the data into), delim(the delimiter character) 。该函数返回值是input。 其中input是istream类型，比如cin, istringstream等继承自istream的类，分割符为char型字符。 为了获取带空格的字符串，一般使用getline(cin, str)进行读取字符串。读取待分割字串到str中后，我们需要用其实例化一个istringstream作为getline的input才能完成分割。 分割过程中需要注意一点: 若待分割字符串中包含连续的分割字符，这种情况会得到空字符串。多数情况下我们不期望得到空字符串，因此需要判断分割得到的字符串是否为空。 DemoCode123456789101112131415161718#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;int main() { string line, word; getline(cin, line); istringstream input(line); while (getline(input, word, ' ')) { if (!word.empty()) cout &lt;&lt; &quot;word : &quot; &lt;&lt; word &lt;&lt; endl; } return 0;} 结果 欢迎讨论指正","link":"/2021/10/27/cpp/%5Bcpp%5D%E4%BE%BF%E6%8D%B7%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95/"},{"title":"[LeetCode]买卖股票合集","text":"简单整理一下LeetCode上买卖股票系列题目. 包含买卖股票的最佳时机、买卖股票的最佳时机 II、买卖股票的最佳时机 III、买卖股票的最佳时机 IV、最佳买卖股票时机含冷冻期和买卖股票的最佳时机含手续费共六题. 买卖股票的最佳时机题目描述给出数组price, 其中price[i]表示第i天股票的价格. 只能选择某一天买入然后之后的某一天卖出, 求最大利润. 思路 贪心. 如果在第i天卖出, 那么一定希望买入的时候价格最低, 因此使用维护一个前缀最小值即可. 状态机动态规划 状态机关心的时当前处于何种状态, 以及所有可能的状态转移和条件 动态规划 状态定义 f[i][0][0]: 表示第i天没持有股票, 且没完成一次交易的最大利润(一定为0). f[i][1][0]: 表示第i天持有股票, 且没完成一次交易的最大利润. f[i][0][1]: 表示第i天没持有股票, 且完成一次交易的最大利润. f[i][1][1]: 表示第i天持有股票, 且完成一次交易的最大利润. 状态转移 $f[i][0][0] = f[i - 1][0][0] = 0$ $f[i][1][0] = max(f[i - 1][1][0], -price[i])$, 表示要么是第i - 1天持有, 要么是第i天买入. $f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + price[i])$, 表示要么是第i - 1天完成一次交易, 要么是第i天卖出后完成了一次交易. $f[i][1][1] = max(f[i - 1][1][1], f[i - 1][0][1] - price[i])$, 表示要么是第i - 1天持有, 要么是第i天买入. 使用三维的原因是必须保证只能完成一次交易, 因此需要对状态进行拆分. 状态的表示是持有股票或不持有股票, 而买入卖出是动作, 是状态转移的条件. 状态初始化中, 由于第一天无法完成一次交易, 因此$f[1][0][1]=f[1][1][1]=-INF$. 由于$f[i][1][1]$无法转移到其他任何状态, 而且其也不会是答案, 因此其为无效状态, 无需计算. Code1234567891011121314151617/* 贪心思路, 记录前缀最小值即可. 时间复杂度O(N) 空间复杂度O(1)*/class Solution {public: int maxProfit(vector&lt;int&gt;&amp; p) { // ans至少为0, 即可以不买不卖 int ans = 0, mn = p[0]; for (int i = 1; i &lt; (int)p.size(); i ++ ){ ans = max(ans, p[i] - mn); mn = min(mn, p[i]); } return ans; }}; 1234567891011121314151617// 状态机动态规划const int N = 1e5 + 5;class Solution {public: int f[N][2][2]; int maxProfit(vector&lt;int&gt;&amp; p) { int n = p.size(); f[1][0][1] = f[1][1][1] = -1e9; f[1][1][0] = -p[0]; for (int i = 2; i &lt;= n; i ++ ) { f[i][0][0] = f[i - 1][0][0]; f[i][1][0] = max(f[i - 1][1][0], -p[i - 1]); f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + p[i - 1]); } return max(f[n][0][1], f[n][0][0]); }}; 复杂度分析(状态机动态规划) 时间复杂度$O(N)$ 空间复杂度$O(N)$ 买卖股票的最佳时机 II题目描述基本题意与第一题相同, 只是多了个条件: 可以完成任意交易. 思路 本题无需关注交易次数, 只需关注在每个时间点所处的状态以及所有可能的转移及条件, 因此简单修改第一题状态机动态规划做法即可. 状态机动态规划 状态定义: f[i][0]: 表示第i天没持有股票时候的最大收益 f[i][1]: 表示第i天持有股票时候的最大收益 状态转移: $f[i][0] = max(f[i - 1][0], f[i - 1][1] + price[i])$, 表示第i天不持有可以从第i - 1天不持有或者第i - 1天持有但第i天卖掉转移而来. $f[i][1] = max(f[i - 1][1], f[i - 1][0] - price[i])$, 表示第i天持有可以从第i - 1天持有或者第i - 1天不持有但第i天买入转移而来. 最终答案: f[n][0] Code12345678910111213class Solution {public: int maxProfit(vector&lt;int&gt;&amp; p) { int n = p.size(); vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(2, 0)); f[0][0] = 0, f[0][1] = -p[0]; for (int i = 1; i &lt; n; i ++ ){ f[i][0] = max(f[i - 1][0], f[i - 1][1] + p[i]); f[i][1] = max(f[i - 1][1], f[i - 1][0] - p[i]); } return f[n - 1][0]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 买卖股票的最佳时机 III题目描述基本题意与第一题相同, 只是多了个条件: 最多完成两笔交易. 思路 第一题解法中使用三维状态来标记完成交易的次数, 本题只是第一题的简单扩展, 在第一题基础上稍加修改即可. 状态机动态规划 状态定义: $f[i][0][0]$: 表示第i天不持有股票, 且完成0笔交易时的最大收益(一定为0, 无效状态) $f[i][1][0]$: 表示第i天持有股票, 且完成0笔交易时的最大收益 $f[i][0][1]$: 表示第i天不持有股票, 且完成1笔交易时的最大收益 $f[i][0][2]$: 表示第i天不持有股票, 且完成2笔交易时的最大收益 $f[i][1][1]$: 表示第i天持有股票, 且完成1笔交易时的最大收益 $f[i][1][2]$: 表示第i天持有股票, 且完成2笔交易时的最大收益(无效状态) 状态转移: $f[i][1][0] = max(f[i - 1][1][0], f[i - 1][0][0] - p[i])$, 表示第i天持有可以从第i - 1天持有或者第i - 1天不持有但第i天买入转移而来. $f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + p[i])$, 转移同上, 要么前一天同状态转移过来, 要么前一天某状态通过买入/卖出转移过来. $f[i][0][2] = max(f[i - 1][0][2], f[i - 1][1][1] + p[i])$ $f[i][1][1] = max(f[i - 1][1][1], f[i - 1][0][1] - p[i])$ 由于第一天无法完成交易, 因此需要初始化第一天的某些状态为非法状态. Code12345678910111213141516171819202122232425const int N = 1e5 + 5;class Solution {public: int f[N][2][3]; int maxProfit(vector&lt;int&gt;&amp; p) { int n = p.size(); // 初始化 // 第一天持有股票 f[1][1][0] = -p[0]; // 第一天无法完成交易 f[1][0][1] = f[1][0][2] = f[1][1][1] = f[1][1][2] = -1e9; for (int i = 2; i &lt;= n; i ++ ) { int cur = p[i - 1]; // 第i天有股票, 交易了0次 f[i][1][0] = max(f[i - 1][1][0], - cur); // 第i天无股票, 交易了1次 f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + cur); // 第i天无股票, 交易了2次 f[i][0][2] = max(f[i - 1][0][2], f[i - 1][1][1] + cur); // 第i天有股票, 交易了1次 f[i][1][1] = max(f[i - 1][1][1], f[i - 1][0][1] - cur); } return max({f[n][0][0], f[n][0][1], f[n][0][2]}); }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 买卖股票的最佳时机 IV题目描述基本题意与第一题相同, 只是多了个条件: 最多完成k笔交易. 思路 第一题状态机动态规划解法与第三题的推广版本, 完全一致的思路, 照抄即可. 状态机动态规划 状态定义: $f[i][0][j]$: 表示第i天不持有股票, 且完成j笔交易时的最大收益 $f[i][1][j]$: 表示第i天持有股票, 且完成j笔交易时的最大收益 状态转移: $f[i][0][j] = max(f[i - 1][0][j], f[i - 1][1][j - 1] + p[i])$ $f[i][1][j] = max(f[i - 1][1][j], f[i - 1][0][j] - p[i])$ Code1234567891011121314151617181920212223const int N = 1010, K = 110;class Solution {public: int f[N][2][K]; int maxProfit(int k, vector&lt;int&gt;&amp; p) { memset(f, -0x3f, sizeof(f)); int n = p.size(); for (int i = 0; i &lt;= n; i ++ ) f[n][0][0] = 0; for (int i = 1; i &lt;= n; i ++ ) { int cur = p[i - 1]; f[i][1][0] = max(f[i - 1][1][0], -cur); for (int j = 1; j &lt;= k; j ++ ) { f[i][0][j] = max(f[i - 1][0][j], f[i - 1][1][j - 1] + cur); f[i][1][j] = max(f[i - 1][1][j], f[i - 1][0][j] - cur); } } int ans = 0; for (int i = 1; i &lt;= k; i ++ ) ans = max(ans, f[n][0][i]); return ans; }}; 复杂度分析 时间复杂度$O(N * K)$ 空间复杂度$O(N * K)$ 最佳买卖股票时机含冷冻期题目描述基本题意与第一题相同, 只是多了条件: 可以买卖任意次, 但卖出股票后，无法在第二天买入股票 (即冷冻期为 1 天)。 思路 基本为第二题的扩展. 考虑如何将冷冻期为 1 天用状态表达出来即可. 状态机动态规划 状态定义: $f[i][0]$: 表示第i天不持有股票, 且无冷冻期, 时候的最大收益. $f[i][1]$: 表示第i天不持有股票, 且在冷冻期(第i - 1天卖出), 时候的最大收益. $f[i][2]$: 表示第i天持有股票时候的最大收益 状态转移: $f[i][0] = max(f[i - 1][0], f[i - 1][1])$ $f[i][1] = f[i - 1][2] + p[i]$ $f[i][2] = max(f[i - 1][2], f[i - 1][0] - p[i])$ Code12345678910111213141516class Solution {public: int maxProfit(vector&lt;int&gt;&amp; p) { int n = p.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(3, 0)); // 初始化: f[1][1] = -1e9; f[1][2] = -p[0]; for (int i = 2; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][2] + p[i - 1]; f[i][2] = max(f[i - 1][2], f[i - 1][0] - p[i - 1]); } return max(f[n][0], f[n][1]); }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 买卖股票的最佳时机含手续费题目描述基本题意与第一题相同, 只是多了条件: 可以买卖任意次, 且一次买入卖出需要支付手续费。 思路 第二题的简单扩展. 卖出阶段支付手续费即可. 状态机动态规划 状态定义: $f[i][0]$: 表示第i天不持有股票时候的最大收益. $f[i][1]$: 表示第i天持有股票时候的最大收益. 状态转移: $f[i][0] = max(f[i - 1][0], f[i - 1][1] + p[i] - fee)$ $f[i][1] = max(f[i - 1][1], f[i - 1][0] - p[i])$ Code123456789101112131415const int N = 1e5 + 5;class Solution {public: int f[N][2]; int maxProfit(vector&lt;int&gt;&amp; p, int fee) { int n = p.size(); f[1][1] = -p[0]; for (int i = 2; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1] + p[i - 1] - fee); f[i][1] = max(f[i - 1][1], f[i - 1][0] - p[i - 1]); } return f[n][0]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 参考资料 B站yxc 欢迎讨论指正","link":"/2021/11/23/algo/LeetCode/%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/%5BLeetCode%5D%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E5%90%88%E9%9B%86/"},{"title":"[LeetCode]打家劫舍合集","text":"简单整理一下LeetCode上打家劫舍系列题目, 该系列作为状态机动态规划的入门题相当的好. 打家劫舍题目描述有一行非负数, 不能选连续两个数, 求选的数之和的最大值. 思路整体思路上使用状态机的思路解决. 状态机关心的是当前处于何种状态, 所有可能的状态转移方式与条件. 结合本题, 我们使用状态机动态规划解决本题. 动态规划 状态定义: $f[i][0]$表示考虑了前i个数, 且不拿i号位置的情况下取得的最大价值 $f[i][1]$表示考虑了前i个数, 且拿i号位置的情况下取得的最大价值 状态转移: 若不拿i号位置, 则i - 1位置可拿可不拿, 因此$f[i][0] = max(f[i - 1][0], f[i - 1][1])$ 若拿i号位置, 则i - 1位置必不能被拿, 因此$f[i][1] = f[i - 1][0] + nums[i]$ 最后的答案为$max(f[n][0], f[n][1])$ 任何一种拿与不拿的决策, 均对应于有限状态机中不同状态之间的一条转移边. Code12345678910111213// 上述解法class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(2, 0)); for (int i = 1; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][0] + nums[i - 1]; } return max(f[n][0], f[n][1]); }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$(注意到当前状态只依赖于上一位置状态, 因此可以使用两个变量保存上一位置状态, 优化成$O(1)$) 打家劫舍 II题目描述基本题意与第一题类型, 只不过多了一个限制: 首尾不能同时拿. 思路依照第一题的思路, 我们继续使用状态机动态规划解决. 只不过需要多一维的状态, 用于指示1号位置是否被拿, 因为这关系到最后一个位置的转移条件. 动态规划 状态定义: $f[i][0][0]$表示i号位1号位都没拿. $f[i][0][1]$表示i号位没拿, 1号位拿了. $f[i][1][0]$表示i号位拿了, 1号位没拿. $f[i][1][1]$表示i号位1号位都拿了. 状态转移： 对于$f[i][0][0]$, 则$i - 1$位无限制, 因此$f[i][0][0] = max(f[i - 1][1][0], f[i - 1][0][0])$. 对于$f[i][0][1]$, 则$i - 1$位无限制, 因此$f[i][0][1] = max(f[i - 1][1][1], f[i - 1][0][1])$. 对于$f[i][1][0]$, 则$i - 1$位不能选, 因此$f[i][1][0] = f[i - 1][0][0] + nums[i - 1]$. 对于$f[i][1][1]$, 则$i - 1$位不能选, 因此$f[i][1][1] = f[i - 1][0][1] + nums[i - 1]$.对于i = n: 由于1号位和n号位不能同时选, 因此转移需要单独考虑. Code12345678910111213141516171819class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n + 1, vector&lt;vector&lt;int&gt;&gt;(2, vector&lt;int&gt;(2, 0))); f[1][1][1] = nums[0]; for (int i = 2; i &lt; n; i ++ ) { f[i][0][0] = max(f[i - 1][1][0], f[i - 1][0][0]); f[i][0][1] = max(f[i - 1][1][1], f[i - 1][0][1]); f[i][1][0] = f[i - 1][0][0] + nums[i - 1]; f[i][1][1] = f[i - 1][0][1] + nums[i - 1]; } // 单独考虑n号位 f[n][0][0] = max(f[n - 1][1][0], f[n - 1][0][0]); f[n][0][1] = max(f[n - 1][1][1], f[n - 1][0][1]); f[n][1][0] = f[n - 1][0][0] + nums[n - 1]; return max({f[n][0][0], f[n][0][1], f[n][1][0]}); }}; 123456789101112131415161718192021222324252627282930/* 这里简单提一下另外一种做法, 类似于第一题. 考虑到 1 和 n 不能同时被拿, 因此最优解有以下可能 1. 拿1不拿n 2. 拿n不拿1 3. 1和n不拿 因此可以考虑在1 -&gt; n - 1上和 2 -&gt; n上分别使用第一题的解法做一遍. 因为求解的是最大值, 这两个子问题有所重复的无所谓的(他们都包含第三种情况), 只需不遗漏的计算所有可能即可.*/class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(), ans = 0; if (n == 1) return nums.back(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(2, 0)); // 1 -&gt; n - 1 for (int i = 1; i &lt; n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][0] + nums[i - 1]; } ans = max({ans, f[n - 1][0], f[n - 1][1]}); // 2 -&gt; n f[1][0] = f[1][1] = 0; for (int i = 2; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][0] + nums[i - 1]; } return max({ans, f[n][0], f[n][1]}); }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 打家劫舍 III思路状态机结合树形动态规划的题目.使用树形动态规划解决. 树形动态规划 状态定义: $f[u][0]$表示考虑以u为根的子树中, 且u没被选的情况下最大价值. $f[u][1]$表示考虑以u为根的子树中, 且u被选的情况下最大价值. 状态计算 对于$f[u][0]$, 由于没有拿父节点u, 因此对于任意子节点v, 都可以考虑拿他和不拿他, 因此有转移:$$ f[u][0] = \\sum_{v \\in son[u]}max(f[v][0], f[v][1])$$ 对于$f[u][1]$, 由于拿了父节点u, 因此对于任意子节点v, 都不能拿他, 因此有转移:$$ f[u][1] = \\sum_{v \\in son[u]} f[v][0]$$ Code123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: unordered_map&lt;TreeNode*, vector&lt;int&gt;&gt; f; void dfs(TreeNode* u) { f[u] = vector&lt;int&gt;(2, 0); f[u][1] = u -&gt; val; for (auto&amp; son : {u -&gt; left, u -&gt; right}) { if (son == nullptr) continue; dfs(son); f[u][0] += max(f[son][0], f[son][1]); f[u][1] += f[son][0]; } } int rob(TreeNode* root) { dfs(root); return max(f[root][0], f[root][1]); }}; 复杂度分析 时间复杂度$O(N)$: DFS过程中, 每个节点只会被遍历一次 空间复杂度$O(N)$ 参考资料 B站yxc 欢迎讨论指正","link":"/2021/11/19/algo/LeetCode/%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/%5BLeetCode%5D%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%90%88%E9%9B%86/"},{"title":"[LeetCode]跳跃游戏合集","text":"简单整理一下LeetCode上跳跃游戏系列题目. 包含跳跃游戏、跳跃游戏II、跳跃游戏III、跳跃游戏IV、跳跃游戏V、跳跃游戏VI、跳跃游戏VII共七题. 跳跃游戏题目描述开始位于1号点, 每次在i号点最远可以跳跃nums[i]单位距离, 判断能否跳到n号点. 思路 我们可以把每个下标看成一个点, 每次在i号点跳跃认为是从i连边到j, 且$j\\in [max(1, i - nums[i]),\\ min(n, i + nums[i])]$. 这样问题转化成判断是否存在至少一条从1号点到n号点的路径, 即1号点与n号点是否联通. 暴力使用BFS等算法求解的时候, 正确性是毫无疑问的, 但时间复杂度过高$O(N^2)$, 会TLE. 暴力时间复杂度高的原因是: 每个点会被遍历多次, 如果优化每个点被遍历的次数, 那么问题就得到了解决. 结合题意, 有以下观察: 如果当前位于i号点, 那么1 - i之间的所有点已经可达了(即被遍历过了). 假设是从j点跳到了i点($j &lt; i$), 那么j - i之间的所有点可以被j遍历到, 问题规模减小到1 - j, 归纳下去即可证明. 有了观察1, 当我们位于i号点的时候, 只需关心它向右能跳到的点. i向右最远能跳到$R = min(n, i + nums[i])$. 我们从R倒着向i遍历: 若该点没被访问过, 置为True, 继续向前遍历. 若该点已经被访问过了, 则可由观察1得到, 该点左边的点全被访问过, 退出循环即可. 最终对于每个点, 我们至多遍历一次. Code12345678910111213141516// 写法1class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;bool&gt; f(n, false); f[0] = true; for (int i = 0; i &lt; n; i ++ ) if (f[i]){ int j = min(n - 1, nums[i] + i); while (f[j] == false) f[j --] = true; } return f[n - 1]; }}; 123456789101112131415161718192021/* 写法2:稍微优化上述写法 记录可行的跳的最远的位置 Mx 是哪 利用观察1, 只要当前点i &lt;= Mx, 则当前点一定可达.*/class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;bool&gt; f(n, false); f[0] = true; int Mx = nums[0]; for (int i = 1; i &lt; n; i ++ ) { if (Mx &gt;= i) { f[i] = true; Mx = max(Mx, i + nums[i]); } } return f[n - 1]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 跳跃游戏 II题目描述开始位于1号点, 每次在i号点最远可以跳跃nums[i]单位距离, 判断跳到n号的最少跳跃次数(保证可以到达). 思路有了第一题的分析过程, 这题可以很自然的使用第一题的分析思路: 只需求1号点到n号点的最短路. 利用BFS的性质: 每个点第一次被遍历的时候一定是该点的最短距离. 用第一题思路实现即可. Code12345678910111213141516// 解法1: 上述思路的实现class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n, -1); f[0] = 0; for (int i = 0; i &lt; n; i ++ ) { int R = min(n - 1, i + nums[i]); while (f[R] == -1) f[R --] = f[i] + 1; } return f[n - 1]; }}; 12345678910111213141516171819202122232425262728293031/* 解法2： 简单提一下另外一种思路: dp或者最短路的想法 使用优先队列记录所有可达的点的信息: 最短距离以及它所能跳到的最远点 当遍历到i的时候, 贪心的从优先队列中取最短距离最小的点： 若它能到到达i, 则更新i 否则直接弹出优先队列, 因为它不可能更新i之后的任意一个点. 这样每个点最多 入/出 优先队列一次. 时间复杂度为 O(N * logN) 空间复杂度为 O(N)*/class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { int n = size(nums); vector&lt;int&gt; f(n, 1e9); priority_queue&lt;pair&lt;int, int&gt;&gt; heap; heap.emplace(0, nums[0]); f[0] = 0; for (int i = 1; i &lt; n; i ++ ){ auto [t, ed] = heap.top(); while (heap.size() &amp;&amp; ed &lt; i){ heap.pop(); t = heap.top().first; ed = heap.top().second; } f[i] = -t + 1; heap.emplace(-f[i], i + nums[i]); } return f[n - 1]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 跳跃游戏 III题目描述开始位于start号点, 每次在i号点可以跳到i + nums[i]或i - nums[i], 判断能否跳到nums[k] = 0的某个点. 思路有了前面题目的分析, 这题就是简单的BFS. 每个点最多出去两条边, 暴力BFS即可. Code1234567891011121314151617181920212223242526class Solution {public: bool canReach(vector&lt;int&gt;&amp; arr, int st) { int n = arr.size(); vector&lt;bool&gt; f(n, false); queue&lt;int&gt; qu; f[st] = true; qu.push(st); while (qu.size()) { auto t = qu.front(); qu.pop(); if (t + arr[t] &lt; n and t + arr[t] &gt;= 0 and f[t + arr[t]] == false) f[t + arr[t]] = true, qu.push(t + arr[t]); if (t - arr[t] &lt; n and t - arr[t] &gt;= 0 and f[t - arr[t]] == false) f[t - arr[t]] = true, qu.push(t - arr[t]); } bool flag = false; for (int i = 0; i &lt; n; i ++ ) { if (arr[i] == 0 and f[i]) flag = true; } return flag; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 跳跃游戏 IV题目描述开始位于1号点, 每次在i号点可以跳到i + 1、i - 1、j(满足nums[i] == nums[j]), 求解跳到n号点的最短步数. 思路题目求解的是最短路, 自然就往最短路算法上想(BFS、Dijkstra等). 由于本题边权均为1, 因此考虑使用BFS算法求解. 由题目可知, 所有值相同的点之间存在一条代价为1的边. 因此我们先使用哈希表得到所有值相同的点, 接着BFS即可. 注意优化的一点: BFS第一次遍历到的时候, 其最短路就已经确定了. 因此我们遍历了一遍某一个值相同的集合后, 直接从哈希表删除该集合即可. Code12345678910111213141516171819202122232425262728293031const int INF = 1e8;class Solution {public: int minJumps(vector&lt;int&gt;&amp; arr) { unordered_map&lt;int, vector&lt;int&gt;&gt; mp; int n = arr.size(); for (int i = 0; i &lt; n; i ++ ) { int c = arr[i]; mp[c].push_back(i); } vector&lt;int&gt; f(n, INF); queue&lt;int&gt; qu; f[0] = 0; qu.push(0); while (qu.size()) { auto t = qu.front(); qu.pop(); if (t + 1 &lt; n and f[t + 1] == INF) f[t + 1] = f[t] + 1, qu.push(t + 1); if (t - 1 &gt;= 0 and f[t - 1] == INF) f[t - 1] = f[t] + 1, qu.push(t - 1); for (auto&amp; c : mp[arr[t]]) { if (f[c] == INF) f[c] = f[t] + 1, qu.push(c); } mp.erase(arr[t]); } return f[n - 1]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 跳跃游戏 V题目描述在i号点可以跳到j号的要求是: arr[i] &gt; arr[j] $abs(i - j) &lt;= d$ $i - j$ 之间除i以外的点的值均小于$arr[i]$ 可以从任意点开始, 求解最多能跳多少个点. 思路 观察到数据范围为1000, 因此使用$O(N^2)$的算法求解即可. 依然利用前面题目的思路, 将每个下标视作一个点. i号点能跳到j号点, 则认为存在i指向j的一条有向边. 关键的约束条件为$arr[i] &gt; arr[j]$, 这样的话构建出的图一定为有向无环图(DAG). 问题转化成求有向无环图上的一条最长路径. 因为存在拓扑序, 因此按照序列递推(动态规划, DP)求解即可. 定义f[u]为走到u点时的最大值. 若存在有向边$v \\rightarrow u$, 则有: $$f[u] = max(f[u], f[v] + 1)$$ 因为按照拓扑序的顺序递推, 因此当计算u点时, 其所依赖的点v已经全部被计算过了, 保证了正确性. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {public: int maxJumps(vector&lt;int&gt;&amp; arr, int d) { int n = arr.size(); vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, 0)); vector&lt;int&gt; in(n, 0), f(n, 1); // O(n^2)预处理有向边 for (int i = 0; i &lt; n; i ++ ) { // L for (int j = i - 1, Mx = arr[i] - 1; j &gt;= max(0, i - d); j -- ) { Mx = max(Mx, arr[j]); if (Mx &gt;= arr[i]) break; g[i][j] = 1; in[j] ++ ; } // R for (int j = i + 1, Mx = arr[i] - 1; j &lt;= min(n - 1, i + d); j ++ ) { Mx = max(Mx, arr[j]); if (Mx &gt;= arr[i]) break; g[i][j] = 1; in[j] ++ ; } } // 拓扑排序 + 递推(DP) queue&lt;int&gt; qu; for (int i = 0; i &lt; n; i ++ ) { if (in[i] == 0) qu.push(i); } while (qu.size()) { auto t = qu.front(); qu.pop(); for (int i = 0; i &lt; n; i ++ ) { // t 能走到 i 点 if (g[t][i]) { f[i] = max(f[i], f[t] + 1); if (-- in[i] == 0) qu.push(i); } } } int ans = 0; for (int i = 0; i &lt; n; i ++ ) ans = max(ans, f[i]); return ans; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(N)$ 跳跃游戏 VI题目描述开始位于1号点, 每次最多往前跳k步, 求跳到n时的最大得分(最大数字之和). 思路 动态规划: 状态表示: 定义f[i]为走到i点时的最大得分. 答案即位f[n]. 状态计算：依据题目要求, 最多跳k步, 因此 $$ f[i] = max(f[j] + nums[i]), \\ j \\in [max(1, i - k), i - 1]$$ 朴素状态转移复杂度是$O(K)$, 会超时. 注意到转移要求的是滑动窗口内的最大值. 因此可以利用单调队列或优先队列(类似第二题解法2)优化. Code1234567891011121314151617181920class Solution {public: int maxResult(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;int&gt; f(n, 0); deque&lt;int&gt; dq; for (int i = 0; i &lt; n; i ++ ) { if (dq.size() and i - dq.front() &gt; k) dq.pop_front(); f[i] = nums[i]; if (dq.size()) f[i] = nums[i] + f[dq.front()]; while (dq.size() and f[dq.back()] &lt; f[i]) dq.pop_back(); dq.push_back(i); } return f[n - 1]; }}; 复杂度分析 时间复杂度$O(N)$(单调队列)、$O(N * logN)$(优先队列) 空间复杂度$O(N)$ 跳跃游戏 VII题目描述开始位于1号点, 每次向前跳的距离有限制, 判断能否跳到n号点. 思路 使用动态规划解决. 定义f[i]为是否能够跳到i位置, 只需判断是否存在$j \\in [i - maxJump, i - minJump]$, 使得$f[j] = True$成立. 为了快速判断是否存在j, 使用前缀和的思想. 记$s[i] = \\sum_{j = 0}^{i}f[i]$. 这样每次只需判断是否有$s[i - minJump] - s[i - maxJump - 1] &gt; 0$成立即可. Code12345678910111213141516class Solution {public: bool canReach(string str, int Mn, int Mx) { int n = str.size(); vector&lt;int&gt; f(n + 1, 0), s(n + 1, 0); f[1] = s[1] = 1; for (int i = 2; i &lt;= n; i ++ ) { if (str[i - 1] == '0') { if (s[max(0, i - Mn)] - s[max(0, i - Mx - 1)]) f[i] = 1; } s[i] = s[i - 1] + f[i]; } return f[n]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$","link":"/2021/11/17/algo/LeetCode/%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/%5BLeetCode%5D%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E5%90%88%E9%9B%86/"},{"title":"[LeetCode-1181]使数组严格递增","text":"原题链接 题目描述给定两个数组, 计算使得数组A严格递增的操作次数。 一次操作定义为: 选数组B任意一个数, 替换数组A任意一个数。 约定 arr1数组认为是数组A, 其长度为n arr2数组认为是数组B, 其包含不重复的元素个数为m 数组下标均从1开始 思路 一些观察: 数组B中的重复数是没有用的. 如果使用数组B中的重复数, 要么导致数组A不严格单调递增(操作到了不同位置), 要么导致操作次数增加(操作到了同一位置). 数组B的顺序是无所谓的. 问题转化 有了上述观察, 我们可以将问题首先进行转化. 首先将数组B中的重复元素去掉, 并对数组B排序, 记为$B’$. 这样问题可以转化成: 从数组$A$和数组$B’$(严格单调递增)中找到一条长度为$n$且严格单调递增的路线, 且路线上从A跳到B'的次数最少 转化后的问题可以使用动态规划来解决 动态规划 状态表示: $f[i][j][0]$:表示路线走了长度i, 考虑了数组$B’$的前j个数, 且最后走到数组$A$的i位置上. $f[i][j][1]$:表示路线走了长度i, 考虑了数组$B’$的前j个数, 且最后走到数组$B’$的j位置上. 状态计算: 根据定义首先有: $f[i][j][0]$ = $f[i][j - 1][0]$ 若$A[i] &gt; A[i - 1]$, 则有$f[i][j][0]$ = $f[i - 1][j][0]$ 若 $A[i] &gt; B’[j]$, 则有$f[i][j][0]$ = $f[i - 1][j][1]$ 对于$f[i][j][1]$: 若$B’[j] &gt; A[i - 1]$, 则有$f[i][j][1]$ = $f[i - 1][j - 1][0] + 1$. 表示第i步从$A$数组的i - 1位置跳到了$B’$的j位置 若$B’[j] &gt; B[j - 1]$, 则有$f[i][j][1]$ = $f[i - 1][j - 1][1] + 1$. 表示第i步从$B’$数组的j - 1位置跳到了$B’$的j位置 最后的答案 若最后一步在$A$数组上, 则答案为$f[n][m][0]$. 若最后一步在$B’$数组上, 枚举$f[n][j][1]$, 其中$j\\in[0, m)$. Code1234567891011121314151617181920212223242526272829303132333435363738const int N = 2010, INF = 0x3f3f3f3f;class Solution {public: int f[N][N][2]; int makeArrayIncreasing(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) { memset(f, 0x3f, sizeof(f)); sort(arr2.begin(), arr2.end()); arr2.resize(unique(arr2.begin(), arr2.end()) - arr2.begin()); int n = arr1.size(), m = arr2.size(); for (int i = 0; i &lt;= m; i ++ ) { f[0][i][0] = f[1][i][0] = 0; if (i) f[1][i][1] = 1; } for (int i = 2; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) { f[i][j][0] = f[i][j - 1][0]; if (arr1[i - 1] &gt; arr1[i - 2]) f[i][j][0] = min(f[i][j][0], f[i - 1][j][0]); if (arr1[i - 1] &gt; arr2[j - 1]) f[i][j][0] = min(f[i][j][0], f[i - 1][j][1]); if (arr2[j - 1] &gt; arr1[i - 2]) f[i][j][1] = f[i - 1][j - 1][0] + 1; if (j &gt;= 2 and arr2[j - 1] &gt; arr2[j - 2]) f[i][j][1] = min(f[i][j][1], f[i - 1][j - 1][1] + 1); } int ans = INF; for (int i = 1; i &lt;= m; i ++ ) ans = min({ans, f[n][i][0], f[n][i][1]}); if (ans == INF) ans = -1; return ans; }}; 复杂度分析 时间复杂度$O(n^2)$ 空间复杂度$O(n^2)$ 欢迎讨论指正","link":"/2021/11/11/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-1181%5D%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/"},{"title":"[LeetCode-1218]最长定差子序列","text":"原题链接 题目描述求数组中最长的等差子序列的长度, 且公差为定值 思路 因为公差为定值, 因此当子序列最后一个数确定时, 倒数第二个数一定是确定的, 我们可以使用一个数来代表所有以倒数第二个数为结尾的最长等差子序列. 使用动态规划解决： 状态表示: $f[i]$表示以i为结尾的最长的等差子序列 状态转移: $f[i] = f[i - d] + 1$ Code123456789101112class Solution {public: int longestSubsequence(vector&lt;int&gt;&amp; arr, int d) { unordered_map&lt;int, int&gt; f; int ans = 0; for (auto&amp; c : arr) { f[c] = 1 + f[c - d]; ans = max(ans, f[c]); } return ans; }}; 复杂度分析 时间复杂度$O(n)$ 空间复杂度$O(n)$ 欢迎讨论指正","link":"/2021/11/08/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-1218%5D%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"[LeetCode-319]灯泡开关","text":"原题链接 题目描述给出n个灯泡(初始全部熄灭)并且操作n次, 第i次把所有是i的倍数处的灯泡的开关状态取反. 求n次操作后亮着的灯泡数目. 思路 考虑某一个灯泡i在n次操作中被操作的次数, 可以发现该灯泡会被它的所有因子操作. 比如8会在第1、2、4、8次操作时操作. 若一个灯泡被操作k次, 那么该灯泡一定有k个不同的因子. 且该灯泡最后的状态唯一取决于k的奇偶. 即若k为偶数则灭, k为奇数则亮. 问题转化成求$1 - N$中含有奇数个不同因子的数的个数. 考虑到所有因子都是成对出现的, 若数K有奇数个不同的因子, 那么某个因子一定出现两次, 该因子一定是$\\sqrt K$, 即K必为完全平方数. 最后问题转化成求$1 - N$中完全平方数的个数. Code123456789101112using LL = long long;class Solution {public: int bulbSwitch(int n) { if (n == 0) return 0; int cnt = 0; for (LL i = 1; i * i &lt;= n; i ++ ) cnt ++ ; return cnt; }}; 复杂度分析 时间复杂度$O(\\sqrt N)$ 空间复杂度$O(1)$ 欢迎讨论指正","link":"/2021/11/15/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-319%5D%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3/"},{"title":"[LeetCode-237]删除链表中的节点","text":"原题链接 题目描述给出单链表的某个非尾节点, 删除该节点 思路 由于给出的是单链表, 所以我们无法得知被删除节点的前驱节点信息, 只能”曲线救国” 可以将值向前平移一个单位, 删除末尾节点即可 Code1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: void deleteNode(ListNode* node) { // 当前节点不为尾节点, 所以一定有后继节点 ListNode* Nxt = node -&gt; next; ListNode* cur = node; ListNode* prev = nullptr; // 还有后继节点的时候, 进行值前移 while (Nxt) { cur -&gt; val = Nxt -&gt; val; prev = cur; cur = Nxt; Nxt = Nxt -&gt; next; } // 最后删除尾节点即可（退出循环的时候, cur指向尾节点, Nxt为nullptr, 而prev指向尾节点之前的节点） prev -&gt; next = nullptr; }}; 复杂度分析 时间复杂度$O(N)$, 遍历一遍链表即可完成删除操作 空间复杂度$O(1)$, 只使用常数空间存储指针变量Nxt、cur、prev即可","link":"/2021/11/02/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-237%5D%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"title":"[LeetCode-575]分糖果","text":"原题链接 题目描述总共有偶数个数字, 从中选择一半的数字且数字的种类最多. 思路 贪心: 总共选的数字的个数是固定的, 对于每一种数字可以贪心的只选择一个, 这样后面可供选择的余地就越大. Code123456789101112class Solution {public: int distributeCandies(vector&lt;int&gt;&amp; nums) { // 哈希表统计每个数字的个数 unordered_map&lt;int, int&gt; mp; for (auto&amp; num : nums) mp[num] ++ ; int s = nums.size() / 2; return min(s, (int)mp.size()); }}; 复杂度分析 时间复杂度$O(n)$, 只需遍历数组统计类别 空间复杂度$O(n)$, 哈希表所需空间为$O(n)$ 欢迎讨论指正","link":"/2021/11/01/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-575%5D%E5%88%86%E7%B3%96%E6%9E%9C/"},{"title":"[LeetCode-598]范围求和II","text":"原题链接 题目描述多次给矩阵M的某个子矩阵全部加1, 求最后矩阵中最大值出现的次数 思路 注意到关键的一点: 每次加的子矩阵的左上角均为[0, 0], 因此n次操作后, 最大值一定全部出现在以[0, 0]为左上角的某个子矩阵中, 我们只需确定这个子矩阵的长宽即可 这个子矩阵其实是每次操作的交集, 只有这个交集中的位置才能保证每次都被加1 x和y操作的交集是独立的, 分开求解即可 Code1234567891011class Solution {public: int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) { int x = m, y = n; for (auto&amp; op : ops) { x = min(x, op[0]); y = min(y, op[1]); } return x * y; }}; 复杂度分析 时间复杂度$O(N * M)$: 遍历矩阵即可求出答案 空间复杂度$O(1)$: 仅需常数空间存储x和y的交集 欢迎讨论指正","link":"/2021/11/07/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-598%5D%E8%8C%83%E5%9B%B4%E6%B1%82%E5%92%8CII/"},{"title":"[LeetCode-629]K个逆序对数组","text":"原题链接 题目描述由 $1-n$ 组成的排列中, 有多少个排列的逆序对个数是 $k$ 思路看完题目和数据范围基本就能确定是动态规划. 因为可行方案可能很多很多, 无法枚举. 而从集合角度1(动态规划)进行计算, 会帮助我们省去很多不必要的枚举. 使用一个数来表示一类有共同点的方案, 是动态规划优化问题的特点. 动态规划 状态表示: $f[i][j]$ : 表示考虑前 $1 - i$ 个数, 且逆序对个数为 $j$ 时的方案数. 状态计算:状态计算的思路是枚举最后一个不同点1: 即考虑将数字i放在什么位置. 放置i位置的可能方式如下: 由上图可见, 若将 $i$ 放置在 $i - k$下标处, 这会造成 $k - 1$个逆序对(数 $i$与 下标$\\in[i - k + 1, i]$处的数构成逆序对) 因此可得: $f[i][j]$ = $\\sum_{k=0}^{i - 1} f[i - 1][j - k]$ 由上分析可见, 状态为$O(n^2)$, 转移为$O(n)$, 总时间复杂度为$O(n^3)$, 会超时. 利用前缀和优化状态转移: 记$s[i][j]$ = $\\sum_{k=0}^j f[i][k]$, 可得状态计算：$$ $$ Code1234567891011121314151617181920212223const int N = 1010, MOD = 1e9 + 7;class Solution {public: int f[N][N], s[N][N]; int kInversePairs(int n, int k) { for (int i = 0; i &lt;= n; i ++ ) f[i][0] = s[i][0] = 1; for (int i = 1; i &lt;= n; i ++ ) { for (int j = 1; j &lt;= k; j ++ ) s[i - 1][j] = (s[i - 1][j - 1] + f[i - 1][j]) % MOD; for (int j = 1; j &lt;= k; j ++ ) { if (i &gt; j) f[i][j] = s[i - 1][j]; else f[i][j] = (s[i - 1][j] - s[i - 1][j - i]) % MOD; } } int ans = f[n][k]; ans = (ans + MOD) % MOD; return ans; }}; 复杂度分析 时间复杂度$O(N * K)$ 空间复杂度$O(N * K)$ 参考资料 [1] B站yxc 欢迎讨论指正","link":"/2021/11/11/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-629%5DK%E4%B8%AA%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E7%BB%84/"},{"title":"[LeetCode-869]重新排序得到2的幂","text":"原题链接 题目描述判断一个数字重新排列后能否成为2的某个幂次. 思路 模拟: 考虑到数据范围很小, 我们可以暴力枚举该数的所有排列, 然后判断该数是否为2的幂次. 模拟: 考虑到2的幂次的个数很少, 我们可以首先预处理出来所有的2的幂次, 然后判断该数是否为某个2的幂次。由于数字可以重新排列, 因此只需记录词频, 即若两个数词频相同, 则一个数一定可以通过重新排列变成另外一个数. Code 解法一123456789101112131415161718192021222324252627282930class Solution {public: static const int M = 11; // 辅助函数: 获取x的十进制表示 vector&lt;int&gt; get(int x) { vector&lt;int&gt; ret; while (x) { ret.push_back(x % 10); x /= 10; } return ret; } bool reorderedPowerOf2(int n) { // 记录所有合法方案的十进制表示 set&lt;vector&lt;int&gt;&gt; st; for (int i = 0; i &lt; 31; i ++ ) st.insert(get(1 &lt;&lt; i)); vector&lt;int&gt; cur = get(n); sort(cur.begin(), cur.end()); int ret = 0; // cpp利用next_permutation()函数暴力枚举该数的所有排列 do { ret += st.count(cur); } while (next_permutation(cur.begin(), cur.end())) ; return ret; }}; 解法二123456789101112131415161718192021222324class Solution {public: static const int M = 11; // 辅助函数: 统计数x的词频 vector&lt;int&gt; get(int x) { vector&lt;int&gt; ret(M, 0); while (x) { ret[x % 10] ++ ; x /= 10; } return ret; } bool reorderedPowerOf2(int n) { // 预处理所有合法的方案的词频 set&lt;vector&lt;int&gt;&gt; st; for (int i = 0; i &lt; 31; i ++ ) st.insert(get(1 &lt;&lt; i)); // 获得当前数的词频 vector&lt;int&gt; cur = get(n); if (st.find(cur) != st.end()) return true; return false; }}; 复杂度分析(解法2)其中C为30, N为1e9. 时间复杂度$O(ClogN)$, 首先预处理所有合法方案$O(ClogN)$, 接着查set表$O(logC * logN)$ 空间复杂度$O(ClogN)$, 使用set存储所有合法的2的幂次的词频, 共有C个合法方案, 每个方案的长度不超过logN 欢迎讨论指正","link":"/2021/10/28/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-869%5D%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/"},{"title":"[LeetCode-周赛]266","text":"Rank : 152/4384Solved: 4/4 竞赛链接 统计字符串中的元音子字符串思路 注意到数据范围很小, 直接$O(n^2)$枚举所有子串, 然后$O(n)$判断该子串是否符合要求即可 Code1234567891011121314151617181920212223class Solution {public: int countVowelSubstrings(string s) { int ans = 0, n = s.size(); for (int i = 0; i &lt; n; i ++ ) for (int j = i; j &lt; n; j ++ ) { string tmp = s.substr(i, j - i + 1); int cnt = 0; bool flag = true; for (auto&amp; c : {'a', 'e' ,'i' ,'o', 'u'}) { int cur = count(tmp.begin(), tmp.end(), c); cnt += cur; // 子串不含某个元音字母则不满足条件 if (cur == 0) flag = false; } // cnt记录字符串中所有元音字符的数量 if (flag) ans += cnt == tmp.size(); } return ans; }}; 复杂度分析 时间复杂度$O(n^3)$ 空间复杂度$O(1)$ 所有子字符串中的元音思路 遍历字符串, 枚举每个元音字符对答案的贡献 某个i位置的元音字符贡献为包含i位置的所有子串的个数 由乘法原理, 子串的个数为$(i + 1) * (n - i)$ Code1234567891011121314151617using LL = long long;class Solution {public: long long countVowels(string s) { set&lt;int&gt; str = {'a', 'e' ,'i' ,'o', 'u'}; LL ans = 0, n = s.size(); for (int i = 0; i &lt; n; i ++ ) { char cur = s[i]; int l = i; int r = n - i - 1; if (str.count(cur)) ans += 1ll * (l + 1) * (r + 1); } return ans; }}; 复杂度分析 时间复杂度$O(n)$ 空间复杂度$O(1)$ 分配给商店的最多商品的最小值思路 看到最大值最小立马想到二分 二分答案: 对于答案x, 所有的商店的上界不超过x 枚举所有商品, i号商品至少需要$\\lceil \\frac{quantities[i]}{x} \\rceil$ 个商店 Code1234567891011121314151617181920class Solution {public: int minimizedMaximum(int n, vector&lt;int&gt;&amp; nums) { int m = nums.size(); int l = 1, r = 1e5; while (l &lt; r) { int mid = (r - l) / 2 + l; int cnt = 0; // cpp上取整方式之一 for (auto&amp; num : nums) cnt += (num + mid - 1) / mid; if (cnt &lt;= n) r = mid; else l = mid + 1; } return r; }}; 复杂度分析 时间复杂度$O(N * log1e5)$ 空间复杂度$O(1)$ 最大化一张图中的路径价值思路 动态规划: $dist[i][j][k]$: 表示当前在i点, 还剩余j时间，走过的点的状态是k时候的最大价值 由于只能按照时间递减的顺序走, 因此从大到小遍历时间 状态转移: 若当前状态是$dist[i][j][k]$, 枚举i号点的所有邻接点u, 更新$dist[u][j - costTime][k’]$ 若已经走过了u点, 即k[u] = true, 则$dist[u][j - costTime][k] = max(dist[u][j - costTime][k], dist[i][j][k])$ 若没有走过u点, 即k[u] = false, 则$dist[u][j - costTime][k’] = max(dist[u][j - costTime][k’], dist[i][j][k] + value[u])$, 其中$k’ = k | (1 &lt;&lt; u)$ 实现细节:用二进制表示状态k, 但无法用int或者long long等基础数据类型存储, 这里我使用了bitset存储状态 Code123456789101112131415161718192021222324252627282930313233343536373839404142const int N = 1005, M = 105;using PII = pair&lt;int, int&gt;;class Solution {public: unordered_map&lt;bitset&lt;N&gt;, int&gt; dist[N][M]; int maximalPathQuality(vector&lt;int&gt;&amp; val, vector&lt;vector&lt;int&gt;&gt;&amp; edge, int Mx) { int n = val.size(); vector&lt;vector&lt;PII&gt;&gt; g(n); for (auto&amp; e : edge) { int a = e[0], b = e[1], c = e[2]; g[a].emplace_back(b, c); g[b].emplace_back(a, c); } dist[0][Mx][bitset&lt;N&gt;(1)] = val[0]; for (int Time = Mx; Time &gt;= 0; Time -- ) { for (int i = 0; i &lt; n; i ++ ) for (auto&amp; [st, v] : dist[i][Time]) for (auto&amp; [nxt, cost] : g[i]) { if (Time &lt; cost) continue; if (st[nxt] == 0) { bitset&lt;N&gt; tmp = st; tmp[nxt] = 1; dist[nxt][Time - cost][tmp] = max(dist[nxt][Time - cost][tmp], dist[i][Time][st] + val[nxt]); } else dist[nxt][Time - cost][st] = max(dist[nxt][Time - cost][st], dist[i][Time][st]); } } // 最后答案枚举0号点的状态即可 int ans = val[0]; for (int r = Mx; r &gt;= 0; r -- ) for (auto&amp; [_, v] : dist[0][r]) ans = max(ans, v); return ans; }}; 复杂度分析 时间复杂度$O(M * N * C)$: M为maxTime, N为点数, C为有效状态数 空间复杂度$O(M * N * C)$: M为maxTime, N为点数, C为有效状态数 欢迎讨论指正","link":"/2021/11/07/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D266/"},{"title":"[LeetCode-周赛]267","text":"Rank : 131/4360Solved : 4/4 竞赛链接 买票需要的时间思路注意到数据范围均很小, 因此直接使用双端队列(deque)模拟题意即可. Code1234567891011121314151617181920212223using PII = pair&lt;int, int&gt;;class Solution {public: int timeRequiredToBuy(vector&lt;int&gt;&amp; nums, int k) { deque&lt;PII&gt; dq; int n = nums.size(), ans = 0; for (int i = 0; i &lt; n; i ++ ) dq.emplace_back(nums[i], i); int cnt = 0; while (true) { auto [t, idx] = dq.front(); dq.pop_front(); cnt ++ ; if (t == 1 and idx == k) return cnt; if (t &gt; 1) dq.emplace_back(t - 1, idx); } return -1; }}; 复杂度分析 时间复杂度$O(N * Max(nums))$ 空间复杂度$O(N)$ 反转偶数长度组的节点思路使用vector模拟题意, 注意反转的是偶数长度的组(错看成偶数编号的组, 白WA了两次) Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseEvenLengthGroups(ListNode* head) { ListNode* p = head; vector&lt;int&gt; nums; while (p) { nums.push_back(p -&gt; val); p = p -&gt; next; } int n = nums.size(); vector&lt;int&gt; ans; // cnt是index, id是组的编号(1, 2, 3...) int cnt = 0, id = 1; while (cnt &lt; n) { if (id &amp; 1) { int len = min(n - 1, cnt + id - 1) - cnt + 1; if (len &amp; 1) { for (int k = cnt; k &lt;= min(n - 1, cnt + id - 1); k ++ ) ans.push_back(nums[k]); } else { for (int k = min(n - 1, cnt + id - 1); k &gt;= cnt; k --) ans.push_back(nums[k]); } cnt = min(n, cnt + id); } else { int len = min(n - 1, cnt + id - 1) - cnt + 1; if (len &amp; 1) { for (int k = cnt; k &lt;= min(n - 1, cnt + id - 1); k ++ ) ans.push_back(nums[k]); } else for (int k = min(n - 1, cnt + id - 1); k &gt;= cnt; k --) ans.push_back(nums[k]); cnt = min(n, cnt + id); } id += 1; } ListNode* ret = new ListNode(); p = nullptr; for (auto&amp; c : ans) { if (p == nullptr) { ret -&gt; val = c; p = ret; } else { ListNode* nxt = new ListNode(c); p -&gt; next = nxt; p = p -&gt; next; } } return ret; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 解码斜向换位密码思路模拟题意, 按照矩阵的方式填充好字符后. 遍历每条主对角线, 依次添加字符, 最后把末尾的空格去掉. Code123456789101112131415161718192021222324252627class Solution {public: string decodeCiphertext(string str, int row) { int len = str.size(); int col = len / row; vector&lt;vector&lt;char&gt;&gt; mat(row, vector&lt;char&gt;(col, ' ')); int x = 0, y = 0; for (auto&amp; c : str) { mat[x][y] = c; y ++ ; if (y == col) y = 0, x ++ ; } string ans; for (int i = 0; i &lt; col; i ++ ) { int x = 0, y = i; while (x &lt; row and y &lt; col) { ans.push_back(mat[x][y]); x ++, y ++; } } while (ans.size() and ans.back() == ' ') ans.pop_back(); return ans; }}; 复杂度分析 时间复杂度$O(N)$, N为str的长度 空间复杂度$O(N)$ 处理含限制条件的好友请求思路使用并查集维护连通性. 每次处理请求时, 若已经在一个联通块中则结果为True; 否则暴力判断是否有一条限制边连接了这两个连通块中的两个点. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344const int N = 1010;int p[N];class Solution {public: int find(int x) { return x == p[x] ? x : p[x] = find(p[x]); } vector&lt;bool&gt; friendRequests(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edge, vector&lt;vector&lt;int&gt;&gt;&amp; qu) { int m = edge.size(); for (int i = 0; i &lt; n; i ++ ) p[i] = i; vector&lt;bool&gt; ans; for (auto&amp; q : qu) { int x = q[0], y = q[1]; x = find(x), y = find(y); if (x == y) { ans.push_back(true); continue; } // x != y unordered_set&lt;int&gt; sx, sy; for (int i = 0; i &lt; n; i ++ ) { if (find(i) == x) sx.insert(i); if (find(i) == y) sy.insert(i); } bool flag = true; for (auto&amp; e : edge) { int u = e[0], v = e[1]; if ((sx.count(u) and sy.count(v)) or (sx.count(v) and sy.count(u))) flag = false; } ans.push_back(flag); if (flag) p[y] = x; } return ans; }}; 复杂度分析 时间复杂度$O(N * M)$, N为点数, M为请求数. 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2021/11/14/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D267/"},{"title":"[LeetCode-周赛]268","text":"Rank : 228/4397Solved : 4/4 竞赛链接 两栋颜色不同且距离最远的房子思路注意到数据范围很小, 两重循环枚举即可. Code123456789101112131415161718class Solution {public: int maxDistance(vector&lt;int&gt;&amp; c) { unordered_map&lt;int, int&gt; mp; int n = c.size(); int ans = 0; for (int i = 0; i &lt; n; i ++ ) { int col = c[i]; for (auto&amp; [cc, idx] : mp) { if (cc != col) ans = max(ans, i - idx); } if (mp.count(col) == 0) mp[col] = i; } return ans; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(N)$ 给植物浇水思路按照题意模拟即可. Code1234567891011121314151617181920class Solution {public: int wateringPlants(vector&lt;int&gt;&amp; nums, int cap) { int n = nums.size(); // all : 当前剩余 int ret = 0, all = cap; for (int i = 0; i &lt; n; i ++ ) { int cur = nums[i]; if (all &gt;= cur) { all -= cur; ret += 1; } else { all = cap; ret += i + i + 1; all -= cur; } } return ret; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(1)$ 区间内查询数字的频率思路以值作为key, 以下标作为val, 构建哈希表.每次查询在递增的下标上二分搜索即可 Code123456789101112131415161718192021class RangeFreqQuery {public: unordered_map&lt;int, vector&lt;int&gt;&gt; mp; RangeFreqQuery(vector&lt;int&gt;&amp; arr) { int n = arr.size(); for (int i = 0; i &lt; n; i ++ ) mp[arr[i]].push_back(i); } int query(int l, int r, int val) { auto L = lower_bound(mp[val].begin(), mp[val].end(), l) - mp[val].begin(); auto R = upper_bound(mp[val].begin(), mp[val].end(), r) - mp[val].begin(); return R - L; }};/** * Your RangeFreqQuery object will be instantiated and called as such: * RangeFreqQuery* obj = new RangeFreqQuery(arr); * int param_1 = obj-&gt;query(left,right,value); */ 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(Q * logN)$ k 镜像数字的和思路打表. 由于数据范围很小, 考虑枚举长度不超过12的十进制回文数(复杂度为1e6), 然后暴力判断每个10进制下的回文数是否在2-9进制下也回文. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const int M = 30;using LL = long long;vector&lt;vector&lt;LL&gt;&gt; nums;class Solution {public: void dfs(int len, int cur, string&amp; num) { int R = (len + 1) / 2; if (cur == R + 1) { string ss = num; if (len &amp; 1) { for (int idx = R - 1; idx &gt;= 1; idx -- ) ss.push_back(num[idx - 1]); } else { for (int idx = R; idx &gt;= 1; idx -- ) ss.push_back(num[idx - 1]); } LL val = stoll(ss); for (int k = 2; k &lt;= 9; k ++ ) { if (nums[k].size() == M) continue; LL cv = val; string s; while (cv) { s.push_back(char(cv % k + '0')); cv /= k; } string rs = s; reverse(rs.begin(), rs.end()); if (s == rs and rs[0] != '0') nums[k].push_back(val); } return ; } for (int i = 0; i &lt;= 9; i ++ ) { num.push_back(char(i + '0')); dfs(len, cur + 1, num); num.pop_back(); } } void init() { if (nums.size()) return ; nums.resize(10); for (int len = 1; len &lt;= 12; len ++ ) { for (int i = 1; i &lt;= 9; i ++ ) { string s = to_string(i); dfs(len, 2, s); } } } long long kMirror(int k, int n) { init(); LL ret = 0ll; for (int i = 0; i &lt; n; i ++ ) ret += nums[k][i]; return ret; }}; 复杂度分析 时间复杂度$O(1e6)$ 空间复杂度$O(N * K)$ 欢迎讨论指正","link":"/2021/11/23/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D268/"},{"title":"[LeetCode-周赛]271","text":"Rank : 201/4561Solved : 4/4 竞赛链接 环和杆思路对每个杆使用哈希表记录出现的环种类即可. Code123456789101112131415161718class Solution {public: int countPoints(string s) { unordered_map&lt;int, unordered_set&lt;char&gt;&gt; cnt; int n = s.size(); for (int i = 0; i &lt; n; i += 2) { char col = s[i]; int idx = s[i + 1]; cnt[idx].insert(col); } int ans = 0; for (auto&amp; [k, v] : cnt) if (v.size() == 3) ans += 1; return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 子数组范围和思路由于数据范围很小, 因此使用暴力的方法即可.可以使用单调栈分开统计最小和最大值的贡献, 时间和空间复杂度均为$O(N)$. Code12345678910111213141516171819using LL = long long;class Solution {public: long long subArrayRanges(vector&lt;int&gt;&amp; nums) { int n = nums.size(); LL ans = 0; for (int i = 0; i &lt; n; i ++ ) { int Mn = INT_MAX, Mx = INT_MIN; for (int j = i; j &lt; n; j ++ ) { Mn = min(Mn, nums[j]); Mx = max(Mx, nums[j]); ans += Mx - Mn; } } return ans; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(N)$ 给植物浇水 II思路阅读理解模拟题. 按题意模拟即可. Code1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: int minimumRefill(vector&lt;int&gt;&amp; nums, int a, int b) { int n = nums.size(); int L = 0, R = n - 1; // cA cB 灌水次数 int cA = 0, cB = 0; // curA curB 当前水量 int curA = a, curB = b; while (L &lt;= R) { if (L == R) { // Bob if (curB &gt; curA) { if (curB &lt; nums[L]) cB += 1; } else { // Alice if (curA &lt; nums[L]) cA += 1; } break; } if (curA &gt;= nums[L]) { curA -= nums[L]; } else { curA = a - nums[L]; cA += 1; } if (curB &gt;= nums[R]) { curB -= nums[R]; } else { curB = b - nums[R]; cB += 1; } L += 1, R -= 1; } return cA + cB; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 摘水果思路没看清楚题目范围, 还写了个离散化, 小亏. 具体思路使用前缀和的技巧, 暴力枚举所有的方案, 求这些方案的最大值即可. 我的方法是枚举终点. 特殊计算一直往左走和一直往右走. 若终点小于等于starPos, 则先往右走, 然后再折回到终点最优. 若终点大于等于starPos, 则先往左走, 然后掉头往右走最优. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using LL = long long;class Solution {public: vector&lt;int&gt; all; int get(int x) { return lower_bound(all.begin(), all.end(), x) - all.begin() + 1; } int maxTotalFruits(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int stP, int k) { int n = nums.size(); for (int i = 0; i &lt; n; i ++ ) all.push_back(nums[i][0]); for (int i = stP - k; i &lt;= stP + k; i ++ ) all.push_back(i); sort(all.begin(), all.end()); all.erase(unique(all.begin(), all.end()), all.end()); int M = all.size(); vector&lt;LL&gt; sum(M + 1, 0ll); for (int i = 0; i &lt; n; i ++ ) { int idx = get(nums[i][0]); sum[idx] = nums[i][1]; } for (int i = 1; i &lt;= M; i ++ ) sum[i] += sum[i - 1]; LL ans = 0; // Left int curIdx = get(stP), leftIdx = get(stP - k), rightIdx = get(stP + k); ans = sum[curIdx] - sum[leftIdx - 1]; // Right ans = max(ans, sum[rightIdx] - sum[curIdx - 1]); for (int ed = stP - k + 1; ed &lt; stP + k; ed ++ ) { int start; if (ed &lt;= stP) { start = stP + (k - (stP - ed)) / 2; ans = max(ans, sum[get(start)] - sum[get(ed) - 1]); // cout &lt;&lt; ed &lt;&lt; ' ' &lt;&lt; start &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; } if (ed &gt;= stP) { start = stP - (k - (ed - stP)) / 2; ans = max(ans, sum[get(ed)] - sum[get(start) - 1]); // cout &lt;&lt; ed &lt;&lt; ' ' &lt;&lt; start &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; } } return ans; }}; 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2021/12/15/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D271/"},{"title":"[LeetCode-周赛]273","text":"Rank : 301/4367Solved : 4/4 竞赛链接 反转两次的数字思路模拟题意. cpp可以使用to_string和stoi函数方便的进行字符串和int之间的转换. Code12345678910111213class Solution {public: bool isSameAfterReversals(int num) { string nums = to_string(num); reverse(nums.begin(), nums.end()); int r1 = stoi(nums); string r2 = to_string(r1); reverse(r2.begin(), r2.end()); if (num == stoi(r2)) return true; return false; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 执行所有后缀指令思路由于数据范围很小, 因此直接按照题意模拟. Code1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;int&gt; executeInstructions(int n, vector&lt;int&gt;&amp; st, string s) { int sx = st[0], sy = st[1]; int m = s.size(); vector&lt;int&gt; ans; for (int i = 0; i &lt; m; i ++ ) { int x = sx, y = sy, cur = 0; for (int j = i; j &lt; m; j ++ ) { if (s[j] == 'L') y -= 1; if (s[j] == 'R') y += 1; if (s[j] == 'U') x -= 1; if (s[j] == 'D') x += 1; if (x &gt;= 0 and x &lt; n and y &gt;= 0 and y &lt; n) cur ++ ; else break; } ans.push_back(cur); } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 相同元素的间隔之和思路首先可以将问题一分为二: 分别统计左边和右边, 最后两者相加即可.以左边为例. 我们可以使用前缀和的思想完成统计. 具体思路为: 记left[i]为nums[i]左边与其的间隔之和. cnt[nums[i]]为i极其左边与nums[i]值相等的个数. 若当前枚举到下标i, 其值为nums[i], 若其左边最后一个与其值相同的下标为j, 则有:$$sum[i] = sum[j] + cnt[nums[i]] * (i - j) $$ 上式表示所有所有与nums[i]相同的下标, 先考虑其到j处的距离距离之和(由sum的定义可知为sum[j]); 然后再统计j到i处的距离之和, 其为(i - j) * cnt[nums[i]]. 主要思想是利用历史信息, 分两步部分统计(先到j, 再到i), 其中使用前缀和进行优化. 最后将left和right相加即可. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546using LL = long long;class Solution {public: vector&lt;long long&gt; getDistances(vector&lt;int&gt;&amp; arr) { int n = arr.size(); vector&lt;LL&gt; sum(n + 1, 0L); unordered_map&lt;int, int&gt; mp; // 记录每个数最后一次出现的位置 unordered_map&lt;int, int&gt; cnt; // Left for (int i = 1; i &lt;= n; i ++ ) { int cur = arr[i - 1]; if (mp.count(cur) == 0) { mp[cur] = i; cnt[cur] ++ ; continue; } int idx = mp[cur], num = cnt[cur]; sum[i] = sum[idx] + 1ll * num * (i - idx); mp[cur] = i; cnt[cur] ++ ; } // Right mp.clear(); cnt.clear(); vector&lt;LL&gt; ans(n, 0L); // 先把左边的加到答案里, 然后算右边的 for (int i = 0; i &lt; n; i ++ ) ans[i] += sum[i + 1]; sum = vector&lt;LL&gt;(n + 1, 0L); for (int i = n; i &gt;= 1; i -- ) { int cur = arr[i - 1]; if (mp.count(cur) == 0) { mp[cur] = i; cnt[cur] ++ ; continue; } int idx = mp[cur], num = cnt[cur]; sum[i] = sum[idx] + 1ll * num * (idx - i); mp[cur] = i; cnt[cur] ++ ; } for (int i = 0; i &lt; n; i ++ ) ans[i] += sum[i + 1]; return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 还原原数组思路首先观察数据范围可知, 可以使用$O(N^2)$的算法解决.由于将原数组左右k和右移k后, 对应位置的数差值固定为2k.因此如果我们知道k的具体值的话, 问题就转化成: 给定k值的情况下, 判断数组能否还原出原数组. 判断可以从贪心的小到大考虑: 若考虑到x了, 则将x放入lower数组, 将x + 2k放入higher数组, 若无x + 2k则失败。使用map或者multiset判断的时间复杂度为$O(NlogN)$ 对于k值, 可以考虑枚举所有可能的k值. 由于数组的最大值必定为higher的最大值, 最小值必定为lower的最小值. 因此可以枚举higher的最小值或者lower的最大值, 从而计算出k. 时间复杂度$O(N)$. 最后算法整体时间复杂度为$O(N^2logN)$. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution {public: vector&lt;int&gt; recoverArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); n /= 2; // Max -&gt; higher, Min -&gt; lower int HMx = *max_element(nums.begin(), nums.end()); int LMn = *min_element(nums.begin(), nums.end()); if (n == 1) return {LMn + (HMx - LMn) / 2}; set&lt;int&gt; st(nums.begin(), nums.end()); map&lt;int, int&gt; cnt; for (auto&amp; num : nums) cnt[num] ++ ; // 从大到小枚举LMx, 计算k for (auto it = st.rbegin(); it != st.rend(); it ++ ) { int LMx = *it; if (LMx == HMx) continue; int d = HMx - LMx; if (d % 2 or cnt[HMx] &gt; cnt[LMx]) continue; int k = d / 2; bool flag = true; // lower map&lt;int, int&gt; exist; // map&lt;int, int&gt; cur = cnt; for (auto&amp; [_k, _v] : cnt) { if (_v == 0) continue; if (cnt.count(_k + 2 * k) == 0 or cnt[_k + 2 * k] &lt; _v) { flag = false; break; } else { cnt[_k + 2 * k] -= _v; exist[_k] = _v; } } // 复原全局的cnt for (auto&amp; [_k, _v] : exist) cnt[_k + 2 * k] += _v; if (flag) { // cout &lt;&lt; &quot;find &quot; &lt;&lt; k &lt;&lt; ' ' &lt;&lt; HMx &lt;&lt; ' ' &lt;&lt; LMx &lt;&lt; endl; vector&lt;int&gt; ans; // lower exist[LMn] = cnt[LMn]; for (auto&amp; [l, time] : exist) ans.insert(ans.end(), time, l + k); return ans; } } return {}; }}; 实现的过程中使用exist来存储lower数组, 如果没有找到答案, 则将exist的内容复原到原来的mapcnt中, 这样可以减少cnt的重复拷贝, 将运行时间从超时边缘(1972ms)优化成28ms. 复杂度分析 时间复杂度$O(N^2logN)$ 空间复杂度$O(N^2)$ 欢迎讨论指正","link":"/2021/12/27/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D273/"},{"title":"[LeetCode-周赛]276","text":"Rank : 273/5243Solved : 4/4 竞赛链接 将字符串拆分为若干长度为 k 的组思路模拟题意, 如果最后一段的长度不足就补齐. Code123456789101112131415161718class Solution {public: vector&lt;string&gt; divideString(string s, int k, char fill) { vector&lt;string&gt; ans; string cur; int n = s.size(); for (int i = 0; i &lt; n; i ++ ) { cur.push_back(s[i]); if (cur.size() == k) ans.push_back(cur), cur = &quot;&quot;; } while (cur.size() and cur.size() &lt; k) cur.push_back(fill); if (cur.size() == k) ans.push_back(cur); return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 得到目标值的最少行动次数思路写完记忆化才发现其实是贪心. 首先倒着做, 求从target变成1的最小花费. 然后贪心的做 当前数能被2整除且有整除次数, 则整除 否则就减一 (无整除次数直接可以返回答案) Code1234567891011121314151617181920212223242526272829const int INF = 1e9;class Solution {public: unordered_map&lt;int, unordered_map&lt;int,int&gt;&gt; f; int dfs(int x, int cnt) { if (cnt == 0) return x - 1; if (f.count(x) and f[x].count(cnt)) return f[x][cnt]; int&amp; v = f[x][cnt]; // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; endl; v = INF; if ((x % 2) == 0 and cnt) v = min(v, dfs(x / 2, cnt - 1) + 1); else v = min(v, dfs(x - 1, cnt) + 1); return v; } int minMoves(int tar, int cnt) { if (cnt == 0) return tar - 1; int ans = INF; for (int i = 0; i &lt;= cnt; i ++ ) f[1][i] = 0; ans = dfs(tar, cnt); return ans; }}; 复杂度分析 时间复杂度$O(logN)$ 空间复杂度$O(logN * maxDoubles)$ 解决智力问题思路首先可以想到使用动态规划, 因为选的方式无法穷举, 而且选与不选之间的状态转移也比较清楚.麻烦的是如果正向做, 求f[i]的时候, 计算选择i的时候, 我们要找一个j, 使得在j处选择后可以在i处选择, 且f[j]最大.反向做就比较友好, 避免了找j的过程. 动态规划: 状态定义: f[i]表示考虑$i到n - 1$之间物品时候的最大价值. 状态转移: 可以不拿i处的或只拿i处的: $f[i] = max(f[i + 1], cur)$ 可以拿了i处后继续拿后面的(如果可以): $f[i] = max(f[i], f[i + questions[i][1] + 1] + cur)$ Code123456789101112131415161718using LL = long long;class Solution {public: long long mostPoints(vector&lt;vector&lt;int&gt;&gt;&amp; qu) { int n = qu.size(); vector&lt;LL&gt; f(n); f[n - 1] = qu[n - 1][0]; for (int i = n - 2; i &gt;= 0; i -- ) { int r = i + qu[i][1] + 1; LL cur = qu[i][0]; f[i] = max(f[i + 1], cur); // 不越界才可以拿后面的 if (r &lt; n) f[i] = max(f[i], f[r] + cur); } return f[0]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 同时运行 N 台电脑的最长时间思路没有思路的时候就想想二分 哈哈!答案具有二段性, 如果答案为k, 则所有小于等于k的都能被凑出来, 而大于k的无法凑出来.因此可以二分答案, 然后判断这个数组能否凑出n个mid. 判断过程中, 如果某个值大于等于mid, 则凑出个数 + 1;否则双指针连续求和, 求出一段之和大于等于mid, 然后关键是这一段之和大于mid的部分可以被其他电脑所使用. 因此大于mid的部分的可以继续使用. Code123456789101112131415161718192021222324252627282930313233343536373839404142using LL = long long;class Solution {public: long long maxRunTime(int n, vector&lt;int&gt;&amp; nums) { int m = nums.size(); if (m &lt; n) return 0; sort(nums.begin(), nums.end()); LL sum = 0; for (auto&amp; c : nums) sum += c; LL L = 0, R = sum; while (L &lt; R) { LL mid = (L + R + 1) &gt;&gt; 1; LL cur = 0, cnt = 0; for (int i = 0; i &lt; m; ) { if (nums[i] &gt;= mid) { cnt ++ ; i ++ ; continue; } int j = i; while (j &lt; m and cur &lt; mid) { cur += nums[j]; j ++ ; } if (cur &gt;= mid) { cnt ++ ; cur -= mid; } i = j; } if (cnt &gt;= n) L = mid; else R = mid - 1; } return R; }}; 复杂度分析 时间复杂度$O(NlogN)$ 空间复杂度$O(1)$ 欢迎讨论指正","link":"/2022/01/16/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D276/"},{"title":"[LeetCode-周赛]第65场双周赛","text":"Rank : 235/2676Solved : 3/4 竞赛链接 检查两个字符串是否几乎相等思路模拟题意. 使用哈希表或数组统计词频, 然后比较词频之差的绝对值是否超过3. Code12345678910111213141516class Solution {public: bool checkAlmostEquivalent(string w1, string w2) { unordered_map&lt;char, int&gt; m1, m2; for (auto&amp; c : w1) m1[c] ++ ; for (auto&amp; c : w2) m2[c] ++ ; for (char c = 'a'; c &lt;= 'z'; c ++ ) { int d = abs(m1[c] - m2[c]); if (d &gt; 3) return false; } return true; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(\\vert S\\vert)$, $\\vert S\\vert$为字符集大小 模拟行走机器人 II思路模拟. 一开始眼瞎没注意到数据范围, 每一步都按照题目要求模拟, 然后TLE了. 接着优化, 优化的方式写了两点。 一种是步长对周长取余, 因为每次都是绕外圈走, 因此可以认为余数是真正移动了的步数, 这种优化要注意移动方向的改变, 在四个角上移动了k圈后, 可能会发生移动方向的改变. 比如在左下角(0, 0), 只有初始朝北的时候, 绕k圈后会朝西; 其他朝向绕k圈后都会朝南. 还有一种是一次走好几步, 比如当前向北, 算一下向北最多能走几步. 若可以走完, 就一次走完. 若向北走不完, 则走到上界后修改方向, 递归走剩下的步数。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};class Robot {public: map&lt;int, string&gt; mp; int idx; int x, y; int W, H; // 周长 int all; Robot(int width, int height) { W = width, H = height; x = 0, y = 0; idx = 1; mp[0] = &quot;North&quot;; mp[1] = &quot;East&quot;; mp[2] = &quot;South&quot;; mp[3] = &quot;West&quot;; all = 2 * (W + H) - 4; } bool check(int x, int y) { return x &gt;= 0 and x &lt; W and y &gt;= 0 and y &lt; H; } void move(int num) { num %= all; if (num == 0) { if (x == 0 and y == 0) { if (getDir() == &quot;North&quot;) idx = 3; else idx = 2; } if (x == 0 and y == H - 1) { if (getDir() == &quot;East&quot;) idx = 0; else idx = 3; } if (x == W - 1 and y == 0) { if (getDir() == &quot;West&quot;) idx = 2; else idx = 1; } if (x == W - 1 and y == H - 1) { if (getDir() == &quot;South&quot;) idx = 1; else idx = 0; } } string c = getDir(); if (c == &quot;North&quot;) { int Mx = H - 1 - y; if (Mx &gt;= num) { y += num; return ; } else { y = H - 1; idx = 3; return move(num - Mx); } } if (c == &quot;South&quot;) { int Mx = y; if (Mx &gt;= num) { y -= num; return ; } else { y = 0; idx = 1; return move(num - Mx); } } if (c == &quot;West&quot;) { int Mx = x; if (Mx &gt;= num) { x -= num; return ; } else { x = 0; idx = 2; return move(num - Mx); } } if (c == &quot;East&quot;) { int Mx = W - x - 1; if (Mx &gt;= num) { x += num; return ; } else { x = W - 1; idx = 0; return move(num - Mx); } } for (int i = 1; i &lt;= num; ) { int nx = x + dx[idx], ny = y + dy[idx]; if (check(nx, ny)) { i += 1; x = nx, y = ny; continue; } idx -= 1; if (idx == -1) idx = 3; } } vector&lt;int&gt; getPos() { return {x, y}; } string getDir() { return mp[idx]; }};/** * Your Robot object will be instantiated and called as such: * Robot* obj = new Robot(width, height); * obj-&gt;move(num); * vector&lt;int&gt; param_2 = obj-&gt;getPos(); * string param_3 = obj-&gt;getDir(); */ 复杂度分析 时间复杂度$O(N)$, N次调用move, 每次最多走三个阶段(自身递归的次数不超过3) 空间复杂度$O(1)$ 每一个查询的最大美丽值思路经典题. 可以使用树状数组在线算法做, 也可以使用递推等离线算法做. 在线算法(树状数组): 离散化查询点和价格点后, 需要查询每一个查询点之前的前缀最大值, 可以使用树状数组维护前缀最大值. 离散算法(递推):将查询点和价格点放在一起排序, 相同价格的话查询点放在后面. 这样每个查询点之前的价格点是确定的, 使用一个变量遍历递推一下即可. Code1234567891011121314151617181920212223242526272829// 离线算法: 排序 + 递推using TII = tuple&lt;int, int, int&gt;;class Solution {public: vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; nums, vector&lt;int&gt;&amp; qu) { vector&lt;TII&gt; all; for (auto&amp; c : nums) all.emplace_back(c[0], c[1], 0); int m = qu.size(); for (int i = 0; i &lt; m; i ++ ) all.emplace_back(qu[i], INT_MAX, i); sort(all.begin(), all.end()); int Mx = 0; vector&lt;int&gt; ans(m); for (auto&amp; [c, t, idx] : all) { // t 指示类型 if (t == INT_MAX) { ans[idx] = Mx; } else { Mx = max(Mx, t); } } return ans; }}; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 在线算法. 注意树状数组的范围要开到题目范围的两倍(查询点 + 价格点).const int N = 2e5 + 5;class Solution {public: int tr[N], M; int lowbit(int x) { return x &amp; -x; } void add(int x, int c) { for (int i = x; i &lt;= M; i += lowbit(i)) tr[i] = max(tr[i], c); } int query(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res = max(res, tr[i]); return res; } vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; nums, vector&lt;int&gt;&amp; qu) { int n = nums.size(); vector&lt;int&gt; all = qu; for (auto&amp; c : nums) all.push_back(c[0]); sort(all.begin(), all.end()); all.erase(unique(all.begin(), all.end()), all.end()); M = all.size(); auto get = [&amp;] (int x) { return lower_bound(all.begin(), all.end(), x) - all.begin() + 1; }; for (auto&amp; c : nums) { int idx = get(c[0]), val = c[1]; add(idx, val); } vector&lt;int&gt; ans; for (auto&amp; q : qu) { int idx = get(q); int cur = query(idx); ans.push_back(cur); } return ans; }}; 复杂度分析 时间复杂度$O(N * logN)$, 树状数组的查询和更新操作均为$logN$, 最多执行$N次$. 空间复杂度$O(N)$ 你可以安排的最多任务数目思路首先可以发现答案具有二段性. 若答案为k, 则所有小于等于k的任务数都能完成, 所有大于k的任务数均不能完成. 因此考虑二分答案. 这样问题转化成判断能否完成mid个任务.首先贪心的选择最强的mid个工人和最弱的mid个任务. 我们需要找到一种方式, 使得工人和任务一一匹配. 这里贪心的从小到大考虑每个工人, 若当前工人可以完成当前最弱工作, 则让工人去完成它; 若无法完成, 则这位工人需要吃药, 吃完药后我们二分的找到小于等于他体力值的最大任务, 贪心的选择这个任务给他完成. 最后判断吃药次数cnt是否不超过mid. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344// 上述贪心方式class Solution {public: int maxTaskAssign(vector&lt;int&gt;&amp; task, vector&lt;int&gt;&amp; work, int cnt, int sth) { sort(task.begin(), task.end()); sort(work.begin(), work.end()); int n = task.size(), m = work.size(); int l = 0, r = min(n, m); auto check = [&amp;] (int x) { int need = 0; multiset&lt;int&gt; st; for (int i = 0; i &lt; x; i ++ ) st.insert(task[i]); for (int i = m - x; i &lt; m; i ++ ) { int cur = work[i]; if (cur &gt;= *st.begin()) { st.erase(st.begin()); continue; } auto idx = st.lower_bound(cur + sth + 1); if (idx == st.begin()) return false; -- idx; st.erase(idx); need += 1; } return need &lt;= cnt; }; while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return r; }}; 12345678910111213141516171819202122232425262728293031323334353637383940414243// 题解区大佬的解法, 从大到小枚举任务, 贪心的选工人去完成它.class Solution {public: int maxTaskAssign(vector&lt;int&gt;&amp; task, vector&lt;int&gt;&amp; work, int cnt, int sth) { sort(task.begin(), task.end()); sort(work.begin(), work.end()); int n = task.size(), m = work.size(); int l = 0, r = min(n, m); auto check = [&amp;] (int x) { int need = 0; multiset&lt;int&gt; st; for (int i = m - x; i &lt; m; i ++ ) st.insert(work[i]); for (int i = x - 1; i &gt;= 0; i -- ) { auto it = st.lower_bound(task[i]); if (it != st.end()) { st.erase(it); continue; } need ++ ; it = st.lower_bound(task[i] - sth); if (it == st.end()) return false; st.erase(it); } return need &lt;= cnt; }; while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return r; }}; 复杂度分析 时间复杂度$O(N * log^{2}N)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2021/11/14/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D%E7%AC%AC65%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"[LeetCode-周赛]第67场双周赛","text":"Rank : 178/2923Solved : 4/4 竞赛链接 找到和最大的长度为 K 的子序列思路排序后可知最大的k个数是确定的(是哪些数以及其个数确定), 但是其相对位置是不定的. 因此需要使用某种数据结构确定后的k个值(必须选的)记录一下, 然后遍历原数组. 若当前值还可以出现, 则加入答案, 当前值出现几次减一. 若当前值不可以出现了, 跳过即可. 支持上述操作的数据结构可以是哈希表、multiset等. Code1234567891011121314151617181920class Solution {public: vector&lt;int&gt; maxSubsequence(vector&lt;int&gt;&amp; nums, int k) { vector&lt;int&gt; cc = nums; sort(cc.begin(), cc.end(), greater&lt;int&gt;()); unordered_map&lt;int, int&gt; cnt; int n = nums.size(); for (int i = 0; i &lt; k; i ++ ) cnt[cc[i]] += 1; vector&lt;int&gt; ret; for (int i = 0; i &lt; n; i ++ ) { if (cnt[nums[i]] &gt; 0) { cnt[nums[i]] -= 1; ret.push_back(nums[i]); } } return ret; }}; 复杂度分析 时间复杂度$O(N * logN)$(排序的时间复杂度) 空间复杂度$O(N)$ 适合打劫银行的日子思路很有特点的一类题型.这类题型通常求数组中满足条件限制的所有下标. 条件限制通常为该下标处左右两边的一些性质. 本题的限制在从i往左右两边看, 连续time天都必须是非递减的. 解决这类题型的通用方法一般是先将问题进行转化, 然后使用递推(动态规划), 最后遍历数组找符合要求的下标. 考虑到左右对称, 以下就以左边为例进行分析. 问题转化. i往坐看连续time天都是非递减的, 可以将问题转化成i往坐看, 最多多少天非递减. 通过将问题转化成一个最值问题, 使用最值进行判定. 递推. 记**L[i]**为在i处往左看, 非递减的最大长度. 简单动态规划即可~ 若$nums[i] &lt;= nums[i - 1]$. 则 $L[i] = L[i - 1] + 1$ 若$nums[i] &gt; nums[i - 1]$. 则 $L[i] = 0$ 遍历原数组使用 L 和 R 求解符合要求的下标即可. Code12345678910111213141516171819202122232425class Solution {public: vector&lt;int&gt; goodDaysToRobBank(vector&lt;int&gt;&amp; nums, int time){ int n = nums.size(); vector&lt;int&gt; L(n, 0), R(n, 0); for (int i = 1; i &lt; n; i ++ ) { if (nums[i] &lt;= nums[i - 1]) L[i] = L[i - 1] + 1; } for (int i = n - 2; i &gt;= 0; i -- ) { if (nums[i] &lt;= nums[i + 1]) R[i] = R[i + 1] + 1; } vector&lt;int&gt; ret; for (int i = 0; i &lt; n; i ++ ) { if (i - time &gt;= 0 and i + time &lt; n) { if (L[i] &gt;= time and R[i] &gt;= time) ret.push_back(i); } } return ret; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 引爆最多的炸弹思路做题的时候题意理解错了, 上来直接并查集求最大的联通分量. WA的很快啊! 仔细看样例1才发现, 引爆不具有对称性. A引爆B时, B不一定引爆A. 首先将问题转化成一个图论问题(有向图). 每个圆看作一个点, 每条引爆关系看作一条边. 若A能引爆B, 则从点A连出一条边指向B.考虑到数据范围很小, 构建完有向图后, 直接对每个点暴力使用DFS, 计算以该点出发最多能到的点的个数. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution {public: int vis[100005]; vector&lt;vector&lt;int&gt;&gt; g; void dfs(int u) { vis[u] = 1; for (auto&amp; v : g[u]) { if (vis[v] == 0) dfs(v); } } int maximumDetonation(vector&lt;vector&lt;int&gt;&gt;&amp; nums) { int n = nums.size(); g.resize(n); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) { if (i == j) continue; long long dist = 1ll *(nums[i][0] - nums[j][0]) * (nums[i][0] - nums[j][0]) + 1ll * (nums[i][1] - nums[j][1]) * (nums[i][1] - nums[j][1]); long long r = 1ll * nums[i][2] * nums[i][2]; if (dist &lt;= r) { g[i].push_back(j); // cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; endl; } } int ret = 1; for (int i = 0; i &lt; n; i ++ ) { memset(vis, 0, sizeof(vis)); dfs(i); int cur = 0; for (int j = 0; j &lt; n; j ++ ) if (vis[j] == 1) cur += 1; ret = max(ret, cur); } return ret; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(N)$ 序列顺序查询思路使用平衡树的Get Value By Rank即可完成, 比赛中使用了python的sortedcontainers第三方库偷鸡了. Code123456789101112131415161718192021from sortedcontainers import SortedListclass SORTracker: def __init__(self): self.sl = SortedList() self.idx = 0 def add(self, name: str, score: int) -&gt; None: self.sl.add((-score, name)) def get(self) -&gt; str: ret = self.sl[self.idx] self.idx += 1 return ret[1]# Your SORTracker object will be instantiated and called as such:# obj = SORTracker()# obj.add(name,score)# param_2 = obj.get() 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2021/12/15/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D%E7%AC%AC67%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"[LeetCode-周赛]第70场双周赛","text":"Rank : 302/3638Solved : 4/4 竞赛链接 打折购买糖果的最小开销思路贪心. 还没有买到的糖果中, 最大和次大无法通过免费的方式获得, 必须通过买的方式, 买最大和次大的话贪心选择拿第三大作为免费的即可. Code123456789101112131415class Solution {public: int minimumCost(vector&lt;int&gt;&amp; cost) { sort(cost.begin(), cost.end(), greater&lt;int&gt;()); int ans = 0, n = cost.size(); for (int i = 0; i &lt; n; i += 3) { ans += cost[i]; if (i + 1 &lt; n) ans += cost[i + 1]; } return ans; }}; 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(1)$ 统计隐藏数组数目思路差分的运用. 通过对差分数组求其前缀和, 我们可以得到原数组中每个数与hidden[0]的差值. 然后通过枚举所有可能的hidden[0], 判断hidden[0]在某个取值下是否符合题意. 判断的方法是判断这种情况下最大值和最小值是否在合法范围内. Code1234567891011121314151617181920using LL = long long;class Solution {public: int numberOfArrays(vector&lt;int&gt;&amp; d, int L, int R) { int n = d.size(); vector&lt;LL&gt; sb(n); sb[0] = d[0]; for (int i = 1; i &lt; n; i ++ ) sb[i] = sb[i - 1] + d[i]; LL Mx = *max_element(begin(sb), end(sb)), Mn = *min_element(begin(sb), end(sb)); int ans = 0; for (int i = L; i &lt;= R; i ++ ) { LL curL = Mn + i, curR = Mx + i; if (curL &gt;= L and curL &lt;= R and curR &gt;= L and curR &lt;= R) ans += 1; } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 价格范围内最高排名的 K 样物品思路先求起点到每个点的最短路. 可以通过BFS算法求解. 接着按照题目的要求对合法点进行排序即可. cpp中可以使用set搭配使用tuple(结构化绑定, 写法简洁)或者vector实现. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using PII = pair&lt;int, int&gt;;using TII = tuple&lt;int, int, int, int&gt;;const int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};const int INF = 1e9;class Solution {public: vector&lt;vector&lt;int&gt;&gt; highestRankedKItems(vector&lt;vector&lt;int&gt;&gt;&amp; g, vector&lt;int&gt;&amp; p, vector&lt;int&gt;&amp; start, int k) { int L = p[0], R = p[1]; int n = g.size(), m = g[0].size(); int sx = start[0], sy = start[1]; vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(m, INF)); dist[sx][sy] = 0; queue&lt;PII&gt; qu; qu.emplace(sx, sy); while (qu.size()) { auto [x, y] = qu.front(); qu.pop(); for (int i = 0; i &lt; 4; i ++ ) { int nx = x + dx[i], ny = y + dy[i]; if (nx &gt;= 0 and nx &lt; n and ny &gt;= 0 and ny &lt; m and g[nx][ny]) { if (dist[nx][ny] == INF) { dist[nx][ny] = dist[x][y] + 1; qu.emplace(nx, ny); } } } } set&lt;TII&gt; st; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) { if (dist[i][j] == INF or g[i][j] &gt; R or g[i][j] &lt; L or g[i][j] == 1) continue; st.emplace(dist[i][j], g[i][j], i, j); } vector&lt;vector&lt;int&gt;&gt; ans; for (auto&amp; [d, p, i, j] : st) { if (ans.size() &lt; k) ans.push_back({i, j}); else break; } return ans; }}; 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ 分隔长廊的方案数思路前缀和优化动态规划. 首先将S看成1, P看成0, 对原数组求其前缀和. 并将前缀和存入map中.接着定义f[i]表示考虑前i个位置且在下标i的右边放屏风的方案数。为了求解f[i], 需要考虑上一个屏风所放的位置.若i之前有k个座位, 则第一个可以放屏风的位置是$L = mp[k - 2]$, 最后一个可以放屏风的位置是$R = mp[k - 1] - 1$.则有$f[i] = \\sum_{j=L}^{R}f[j]$, 由于其是一段连续的区间和, 因此可以使用前缀和的技巧进行优化. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int MOD = 1e9 + 7;using LL = long long;class Solution {public: int numberOfWays(string str) { int n = str.size(); vector&lt;int&gt; s(n + 1, 0); unordered_map&lt;int, int&gt; mp; mp[0] = 0; for (int i = 1; i &lt;= n; i ++ ) { int cur = (str[i - 1] == 'S'); s[i] = s[i - 1] + cur; // 哈希表记录每个前缀和出现的坐标 if (!mp.count(s[i])) mp[s[i]] = i; } int all = s[n]; if (all % 2) return 0; int ans = 0; vector&lt;LL&gt; f(n + 1); // 注：根据定义, f[0] = 1. f[0] = 1; for (int i = 1; i &lt;= n; i ++ ) { int cur = s[i]; f[i] = f[i - 1]; if (cur &lt; 2) continue; int L = mp[cur - 2], R = mp[cur - 1] - 1; int val; // 会存在下标越界的情况, 根据定义L可以去到0 if (L - 1 &lt;= 0) val = f[R]; else val = f[R] - f[L - 1]; if (i == n) ans = val % MOD; // f数组自身当作其前缀和数组 f[i] = (f[i] + val) % MOD; } // MOD成非负数 ans = (ans + MOD) % MOD; return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2022/01/22/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D%E7%AC%AC70%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"[LeetCode-周赛]277","text":"Rank : 859/5059Solved : 4/4 竞赛链接 元素计数思路模拟.统计严格大于最小值且严格小于最大值的数的个数. Code123456789101112class Solution {public: int countElements(vector&lt;int&gt;&amp; nums) { int Mx = *max_element(begin(nums), end(nums)), Mn = *min_element(begin(nums), end(nums)); int ans = 0; for (auto&amp; c : nums) { if (c != Mx and c != Mn) ans ++ ; } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(1)$ 按符号重排数组思路模拟. 将正数和负数分开存入数组, 然后按序构造答案. Code12345678910111213141516171819class Solution {public: vector&lt;int&gt; rearrangeArray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; neg, pos; for (auto&amp; c : nums) if (c &gt; 0) pos.push_back(c); else neg.push_back(c); vector&lt;int&gt; ans; int n = pos.size(); for (int i = 0; i &lt; n; i ++ ) { ans.push_back(pos[i]); ans.push_back(neg[i]); } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 找出数组中的所有孤独数字思路模拟. 使用哈希表计数并且判断x + 1和x - 1是否存在. Code12345678910111213141516class Solution {public: vector&lt;int&gt; findLonely(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; mp; for (auto&amp; c : nums) mp[c] ++ ; vector&lt;int&gt; ans; for (auto&amp; [k, v] : mp) { if (v &gt; 1) continue; if (mp.count(k + 1) == 0 and mp.count(k - 1) == 0) ans.push_back(k); } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 基于陈述统计最多好人数思路枚举. 使用二进制枚举好人可能的方案, 然后判断好人的陈述是否存在矛盾。坏人的陈述是不需要判断的, 因为他可能说真, 也可能说假, 即陈述对好坏划分是没有影响的。(比赛的时候理解错题了, 以为要么全真, 要么全假, 搞晕了) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: int maximumGood(vector&lt;vector&lt;int&gt;&gt;&amp; nums) { int n = nums.size(); int ans = 0; vector&lt;vector&lt;int&gt;&gt; state(n); for (int i = 0; i &lt; n; i ++ ) { int good = 0, bad = 0; for (int j = 0; j &lt; n; j ++ ) { if (nums[i][j] == 1) good |= (1 &lt;&lt; j); if (nums[i][j] == 0) bad |= (1 &lt;&lt; j); } state[i].push_back(good); state[i].push_back(bad); } for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ) { int cnt = __builtin_popcount(i); int good = 0, bad = 0; for (int j = 0; j &lt; n; j ++ ) { if (i &gt;&gt; j &amp; 1) good |= (1 &lt;&lt; j); else bad |= (1 &lt;&lt; j); } bool flag = true; for (int j = 0; j &lt; n; j ++ ) { if (i &gt;&gt; j &amp; 1) { if ((state[j][0] | good) != good) flag = false; if ((state[j][1] | bad) != bad) flag = false; } } if (flag) ans = max(ans, cnt); } return ans; }}; 复杂度分析 时间复杂度$O(N * 2^N)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2022/01/23/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D277/"},{"title":"[LeetCode-周赛]第71场双周赛","text":"Rank : 239/3028Solved : 4/4 竞赛链接 拆分数位后四位数字的最小和思路使用双重循环枚举new1, 然后使用单循环枚举new2, 注意此时每个new1对应两个new2. Code1234567891011121314151617181920212223242526class Solution {public: int minimumSum(int num) { int ans = INT_MAX; string s = to_string(num); int n = s.size(); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) { if (i == j) continue; string s1; s1.push_back(s[i]); s1.push_back(s[j]); string s2; for (int k = 0; k &lt; n; k ++ ) { if (k != i and k != j) s2.push_back(s[k]); } ans = min(ans, stoi(s1) + stoi(s2)); reverse(begin(s2), end(s2)); ans = min(ans, stoi(s1) + stoi(s2)); } return ans; }}; 复杂度分析 时间复杂度$O(N^3)$ 空间复杂度$O(N)$ 根据给定数字划分数组思路枚举. 将小于pivot、等于pivot和大于pivot的分别插入vector中, 然后合并即可. Code12345678910111213141516171819class Solution {public: vector&lt;int&gt; pivotArray(vector&lt;int&gt;&amp; nums, int p) { vector&lt;int&gt; a, b, c; for (auto&amp; num : nums) { if (num &lt; p) a.push_back(num); if (num == p) b.push_back(num); if (num &gt; p) c.push_back(num); } for (auto&amp; num : b) a.push_back(num); for (auto&amp; num : c) a.push_back(num); return a; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 设置时间的最少代价思路枚举时间, 首先注意前导0可以不要, 因此长度不足4的时候要注意分和秒的计算. 最后注意push的顺序(读错题WA了一发). Code123456789101112131415161718192021222324252627282930313233343536373839404142434445const int M = 10;class Solution {public: int minCostSetTime(int start, int moveCost, int pushCost, int tar) { int ans = INT_MAX; for (int i = 1; i &lt; 10000; i ++ ) { string s = to_string(i); string mill, sec; for (int j = s.size() -1; j &gt;= 0; j -- ) { if (sec.size() &lt; 2) sec.push_back(s[j]); else mill.push_back(s[j]); } reverse(begin(sec), end(sec)); reverse(begin(mill), end(mill)); int time = stoi(sec); if (mill.size()) time += stoi(mill) * 60; if (time != tar) continue; vector&lt;int&gt; cnt(M); for (auto&amp; c : s) cnt[c - '0'] ++ ; int cur = 0, prev = start + '0'; for (int j = 0; j &lt; s.size(); j ++) { cur += pushCost; if (s[j] != prev) cur += moveCost; prev = s[j]; } ans = min(ans, cur); // cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; cur &lt;&lt; endl; } return ans; }}; 复杂度分析 时间复杂度$O(M * N)$, M = 10, N = 10000 空间复杂度$O(M)$ 删除元素后和的最小差值思路首先枚举切割的位置, 右数组的开头可取的范围是从n + 1到2n + 1. 接着对于某个位置, 其差值的最小值是: 左边取最大的n个数, 而右边取最小的n个数.由于需要动态计算, 因此可以使用递推(动态规划)的思想提前预处理出来. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344using LL = long long;class Solution {public: long long minimumDifference(vector&lt;int&gt;&amp; nums) { multiset&lt;int&gt; left, right; int n = nums.size() / 3; vector&lt;LL&gt; L(3 * n + 1), R(3 * n + 1); LL sl = 0, sr = 0; for (int i = 1; i &lt;= n; i ++ ) left.insert(nums[i - 1]), sl += nums[i - 1], L[i] = sl; for (int i = 3 * n; i &gt; 2 * n; i -- ) right.insert(nums[i - 1]), sr += nums[i - 1], R[i] = sr; for (int i = n + 1; i &lt;= 2 * n; i ++ ) { int cur = nums[i - 1], Mx = *left.rbegin(); if (cur &lt; Mx) { sl = sl - Mx + cur; left.erase(left.find(Mx)); left.insert(cur); } L[i] = min(L[i - 1], sl); } for (int i = 2 * n; i &gt; n; i -- ) { int cur = nums[i - 1], Mn = *right.begin(); if (cur &gt; Mn) { sr = sr - Mn + cur; right.erase(right.find(Mn)); right.insert(cur); } R[i] = max(R[i + 1], sr); } LL ans = LLONG_MAX; for (int i = n + 1; i &lt;= 2 * n + 1; i ++ ) ans = min(ans, L[i - 1] - R[i]); return ans; }}; 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2022/02/05/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D%E7%AC%AC71%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"[LeetCode-周赛]279","text":"Rank : 226/4132Solved : 4/4 竞赛链接 对奇偶下标分别排序思路使用两个数组实现分别排序, 然后奇偶拼接即可. Code123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; sortEvenOdd(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; a, b; for (int i = 0; i &lt; n; i ++ ) { if (i % 2) b.push_back(nums[i]); else a.push_back(nums[i]); } sort(begin(a), end(a)); sort(begin(b), end(b), greater&lt;int&gt;()); vector&lt;int&gt; ret; for (int i = 0, j = 0; i &lt; a.size(); i ++, j ++ ) { ret.push_back(a[i]); if (j &lt; b.size()) ret.push_back(b[j]); } return ret; }}; 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ 重排数字的最小值思路贪心. 如果是负数, 则数字从大到小排序. 如果是正数, 从从小到大排序(注意前导零), 如果存在前导零, 则从小到大遍历, 将第一个非0数组与开头的0交换. Code123456789101112131415161718192021class Solution {public: long long smallestNumber(long long num) { string s = to_string(num); if (num &lt; 0) { sort(begin(s), end(s), greater&lt;char&gt;()); return -stoll(s); } sort(begin(s), end(s)); for (int i = 0; i &lt; s.size(); i ++ ) { if (s[i] != '0') { if (i == 0) break; swap(s[i], s[0]); break; } } return stoll(s); }}; 复杂度分析 时间复杂度$O(N * logN)$, 其中$N = log_{10}{num}$ 空间复杂度$O(N)$ 设计位集思路模拟. 可以通过数组vector以及1和0的计数器共同模拟除了翻转以外的所有操作. 麻烦的是翻转, 其无法暴力模拟. 因此可以设置一个flag, 表示是否翻转了. 某一位的值通过该位的值和flag共同决定. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Bitset {public: vector&lt;int&gt; s; int o, zero; int f; Bitset(int size) { f = 0; zero = size; o = 0; s.resize(size); } void fix(int idx) { int val = (s[idx] + f) % 2; if (val == 0) s[idx] = 1 - s[idx], o ++ , zero -- ; } void unfix(int idx) { int val = (s[idx] + f) % 2; if (val) s[idx] = 1 - s[idx], o -- , zero ++ ; } void flip() { swap(o, zero); f = (f + 1) % 2; } bool all() { return o == s.size(); } bool one() { return o; } int count() { return o; } string toString() { string ans; for (auto&amp; c : s) { int cur = (c + f) % 2; ans.push_back(cur + '0'); } return ans; }};/** * Your Bitset object will be instantiated and called as such: * Bitset* obj = new Bitset(size); * obj-&gt;fix(idx); * obj-&gt;unfix(idx); * obj-&gt;flip(); * bool param_4 = obj-&gt;all(); * bool param_5 = obj-&gt;one(); * int param_6 = obj-&gt;count(); * string param_7 = obj-&gt;toString(); */ 复杂度分析 时间复杂度$O(M * N + P)$, 其中M是toString的调用次数, P是其他操作的调用次数之和. 空间复杂度$O(N)$ 移除所有载有违禁货物车厢所需的最少时间思路首先枚举. 枚举1操作的结束位置, 对于某个1操作, 其对应了很多很多2和3操作的组合(2操作的边界以及1和2操作边界内的3操作), 但我们只关心其中的最少值对应的2和3操作的组合. 首先如果枚举到了i, 设2操作的边界为j(j &gt; i), 则有$Cost[i, j] = (i) + (n - j + 1) + (2 * (sum[j - 1] - sum[i]))$.其中sum是字符串的前缀和数组. 整理可得$Cost[i, j] = i + n - 2 * sum[i] + 2 * sum[j - 1] - (j - 1), j &gt; i$. 因此我们关心的是2 * sum[j - 1] - (j - 1), 只要让其取最小值即可. 这可以通过预处理的方式轻松实现. 记f[i] = 2 * sum[i] - i, 计算出f数组后处理其后缀最小值即可. Code12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int minimumTime(string s) { int n = s.size(); vector&lt;int&gt; sum(n + 1); for (int i = 1; i &lt;= n; i ++ ) { int cur = s[i - 1] - '0'; sum[i] = sum[i - 1] + cur; } // Mn: f数组的后缀最小值 vector&lt;int&gt; f(n + 2), Mn(n + 2); for (int i = 1; i &lt;= n; i ++ ) f[i] = 2 * sum[i] - i; // for (int i = 1; i &lt;= n; i ++ ) // cout &lt;&lt; &quot;f &quot; &lt;&lt; i &lt;&lt; ' ' &lt;&lt; f[i] &lt;&lt; endl; f[n + 1] = Mn[n + 1] = INT_MAX; for (int i = n; i &gt;= 0; i -- ) Mn[i] = min(f[i], Mn[i + 1]); // for (int i = 1; i &lt;= n; i ++ ) // cout &lt;&lt; &quot;min &quot; &lt;&lt; i &lt;&lt; ' ' &lt;&lt; Mn[i] &lt;&lt; endl; int ans = INT_MAX; for (int i = 0; i &lt;= n; i ++ ) { int cur = i + n - 2 * sum[i]; // cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; cur &lt;&lt; ' ' &lt;&lt; Mn[i] &lt;&lt; endl; cur += Mn[i]; ans = min(ans, cur); } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2022/02/06/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D279/"},{"title":"[LeetCode-周赛]280","text":"Rank : 379/5833Solved : 3/4 竞赛链接 得到 0 的操作数思路模拟. 按照题目要求模拟题意即可. Code123456789101112131415class Solution {public: int countOperations(int num1, int num2) { int step = 0; while (num1 and num2) { if (num1 &gt;= num2) num1 -= num2; else num2 -= num1; step ++ ; } return step; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(1)$ 使数组变成交替数组的最少操作数思路枚举. 首先可以发现题目要求奇数位置、偶数位置的值全部相同, 且奇数和偶数位置值不同. 因此我们只需计算最多能够保留多少个数字, 替换的次数为数组长度减去保留的数字个数。 为了计算保留了多少个数字, 枚举偶数位置保留哪一个数字, 然后计算奇数位置除去枚举数字后的频次最大值即可. Code123456789101112131415161718192021222324252627282930const int N = 1e5 + 5;class Solution {public: int cnt[N], L[N], R[N]; int minimumOperations(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; even; int n = nums.size(); for (int i = 0; i &lt; n; i ++ ) { if ((i &amp; 1) == 0) even[nums[i]] ++ ; else cnt[nums[i]] ++ ; } for (int i = 1; i &lt; N; i ++ ) L[i] = max(L[i - 1], cnt[i]); for (int i = N - 2; i &gt;= 1; i -- ) R[i] = max(R[i + 1], cnt[i]); int mx = 0; for (auto&amp; [k, v] : even) { int cur = v + max(L[k - 1], R[k + 1]); mx = max(mx, cur); } return n - mx; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 拿出最少数目的魔法豆思路枚举. 枚举最终的魔法豆数目, 计算小于该数目的总和以及严格大于该数目的总和. 小于该数目的总和可以使用前缀和计算. 严格大于该数目的总和部分需要预处理出个数, 然后用其前缀和减去个数乘以数目. Code12345678910111213141516171819202122232425262728293031using LL = long long;const int N = 1e5 + 5;class Solution {public: LL s[N], cnt[N]; long long minimumRemoval(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = 0; i &lt; n; i ++ ) { s[nums[i]] += nums[i]; cnt[nums[i]] += 1; } for (int i = 1; i &lt; N; i ++ ) s[i] += s[i - 1]; for (int i = N - 3; i &gt;= 1; i -- ) cnt[i] += cnt[i + 1]; LL ans = LLONG_MAX; for (int i = 0; i &lt; n; i ++ ) { int cur = nums[i]; LL left = s[cur - 1]; LL right = (s[N - 1] - s[cur]) - 1ll * cnt[cur + 1] * cur; ans = min(ans, left + right); } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 数组的最大与和思路状态压缩DP. 由于每个篮子最多可以放两个, 因此构建2 * numSlots个篮子, 构建出的第一个和第numSlots个为原始的第一个篮子, 如果这两个篮子都放表示原来的第一个篮子放两个放满了. 用$f[i]$表示考虑构建出的篮子的状态为i, 且考虑了前cnt[i]个数字的最大价值.(cnt[i]表示状态i中1的个数, 即放数组的篮子个数). 为了计算f[i], 枚举nums[cnt[i]]放在了哪里即可. 赛时dp方程多定义了一维, 导致超时.赛后参考了0x3f佬的题解 Code1234567891011121314151617181920212223242526272829const int N = 20;int f[1 &lt;&lt; N];class Solution{public: int maximumANDSum(vector&lt;int&gt;&amp; nums, int numSlots) { int n = nums.size(); memset(f, 0, sizeof(f)); int m = numSlots * 2; for (int i = 0; i &lt; (1 &lt;&lt; m); i ++ ) { int cnt = __builtin_popcount(i); if (i &lt; 1 or cnt &gt; n) continue; for (int k = 0; k &lt; numSlots; k ++ ) { if (i &gt;&gt; k &amp; 1) f[i] = max(f[i], f[i - (1 &lt;&lt; k)] + (nums[cnt - 1] &amp; (k + 1))); int r = k + numSlots; if (i &gt;&gt; r &amp; 1) f[i] = max(f[i], f[i - (1 &lt;&lt; r)] + (nums[cnt - 1] &amp; (k + 1))); } } int ans = 0; for (int i = 0; i &lt; 1 &lt;&lt; m ; i ++ ) if (__builtin_popcount(i) == n) ans = max(ans, f[i]); return ans; }}; 赛时TLE代码 12345678910111213141516171819202122232425const int N = 20;int f[1 &lt;&lt; N][N];class Solution{public: int maximumANDSum(vector&lt;int&gt;&amp; nums, int numSlots) { int n = nums.size(); memset(f, 0, sizeof(f)); int m = numSlots * 2; for (int i = 0; i &lt; (1 &lt;&lt; m); i ++ ) { for (int j = 1; j &lt;= n; j ++ ) { for (int k = 0; k &lt; numSlots; k ++ ) { if (i &gt;&gt; k &amp; 1) f[i][j] = max(f[i][j], f[i - (1 &lt;&lt; k)][j - 1] + (nums[j - 1] &amp; (k + 1))); int r = k + numSlots; if (i &gt;&gt; r &amp; 1) f[i][j] = max(f[i][j], f[i - (1 &lt;&lt; r)][j - 1] + (nums[j - 1] &amp; (k + 1))); } } } int all = (1 &lt;&lt; m) - 1; return f[all][n]; }}; 复杂度分析 时间复杂度$O(N * 2^N)$ 空间复杂度$O(2^N)$ 欢迎讨论指正","link":"/2022/02/13/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D280/"},{"title":"[cpp]语言基础","text":"cpp语言的特点 cpp是一个语言联邦. 其是过程式语言（兼容包含c语言）、面向对象语言（有面向对象语言的封装、继承和多态的特点）、泛型语言（包含标准模板库STL, 有容器、迭代器、算法、适配器、仿函数和分配器）、函数式语言（cpp11引入匿名函数的特性）和元编程语言（TODO: 不懂). cpp是不断发展的语言, cpp11、cpp14、cpp17、cpp20引入了很多新的特性. cpp中struct和class的区别在cpp中struct和class只有很细微的差别. 从使用习惯上来说. strcut一般用作数据结构集合的描述, class用作类的定义（对象的封装）. struct中默认访问控制权限是 public 的, 而class默认访问控制权限是 private 的. 如: 123456struct A{ int iNum; // 默认访问控制权限是 public}class B{ int iNum; // 默认访问控制权限是 private} class 继承默认是 private 继承，而 struct 继承默认是 public 继承 class 支持泛型模板编程. 如STL. include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别 区别： 尖括号&lt;&gt;的头文件是系统文件，双引号””的头文件是自定义文件。 编译器预处理阶段查找头文件的路径不一样。 查找路径： 使用尖括号&lt;&gt;的头文件的查找路径：编译器设置的头文件路径(g++中通过-I参数, 如include opencv等第三方库时)–&gt;系统变量(如iostream、algorithm等编译器自带头文件)。 使用双引号””的头文件的查找路径：当前目录–&gt;编译器设置的头文件路径–&gt;系统变量 cpp结构体和C结构体的区别区别： C的结构体内不允许有函数存在，cpp允许有内部成员函数，且允许该函数是虚函数。 C的结构体对内部成员变量的访问权限只能是public，而cpp允许public,protected,private三种。 C语言的结构体是不可以继承的，cpp的结构体是可以从其他的结构体或者类继承过来的。 C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 cpp 中可以省略 struct 关键字直接使用。 导入C函数的关键字是什么，cpp编译时和C有什么不同？ 关键字：在cpp中，导入C函数的关键字是extern，表达形式为extern “C”， extern “C”的主要作用就是为了能够正确实现cpp代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是cpp的。 编译区别：由于cpp支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 1234567891011121314151617181920212223242526272829303132333435363738394041// 1. extern.h#ifndef __EXTERN#define __EXTERN// extern 声明extern int x;int mul(int x, int y);#endif /* __EXTERN */// 2. extern.cpp #include &quot;extern.h&quot;// 变量x的定义int x = 10;int mul(int x, int y) { return x * y;}// 3. main.cpp#include &lt;iostream&gt;using namespace std;// 声明是外部变量和函数, 在链接的时候重解析extern int x;extern int mul(int x, int y);int main() { cout &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; mul(x, x) &lt;&lt; endl; return 0;}/* 最终的效果: main.cpp 没有直接include extern.h, 通过 extern 方法访问了其函数和变量*/ 编译命令和执行结果 1234$ g++ main.cpp extern.cpp -o main.exe$ ./main.exe10100 cpp从代码到可执行二进制文件的过程cpp和C语言类似，一个cpp程序从源码到执行文件，有四个过程，预编译、编译、汇编、链接. 预编译：这个过程主要的处理操作如下：（1） 将所有的#define删除，并且展开所有的宏定义（2） 处理所有的条件预编译指令，如#if、#ifdef（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。（4） 过滤所有的注释（5） 添加行号和文件名标识。 编译：这个过程主要的处理操作如下：（1） 词法分析：将源代码的字符序列分割成一系列的记号。（2） 语法分析：对记号进行语法分析，产生语法树。（3） 语义分析：判断表达式是否有意义。（4） 代码优化：（5） 目标代码生成：生成汇编代码。（6） 目标代码优化： 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。 链接分为静态链接和动态链接。 静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。 优点: 速度快 缺点: 多次复制, 浪费空间 动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。 优点: 节省空间 缺点: 执行时才链接, 需要重定位寻址, 速度较慢. static关键字的作用cpp中static有限定作用域和改变存储特性的作用. 全局静态变量: static作用于全局变量时, 限定了该变量的作用范围为本文件. 若未初始化, 则存储于全局未初始化段(bss), 并初始化为0. 若初始化了, 则存储于data段. 局部静态变量: static作用于局部变量时, 改变了该变量的存储特性, 若未初始化, 则存储于全局未初始化段(bss), 并初始化为0. 若初始化了, 则存储于data段. 且该变量只会初始化一次. 这样的效果像是限定了作用域的全局变量, 而且避免了全局变量在其他区域被访问和修改. 静态函数: static作用于函数时, 限定了该函数的作用域, 其只能作用于该文件. 静态成员变量: static作用于类成员变量时, 其是申明, 必须要在外部进行定义. 这种方式改变了该变量的存储特性, 变成了类变量, 无需通过对象即可访问, 即变成了只能通过类进行访问的全局变量. 静态成员函数: static作用域类成员函数时, 该函数即为类函数, 无需通过对象即可访问, 而且只能访问静态成员变量, 且不能是虚函数, 且没有this指针. 数组和指针的区别 赋值：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝 存储方式: 数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，数组的存储空间，不是在静态区就是在栈上。 指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针所指向的存储空间大小不能确定, 而指针自身的存储空间大小是确定的。 求sizeof: 数组所占存储空间的内存大小：sizeof（数据类型）* 数组大小, $数组大小=sizeof(数组名) / sizeof(数据类型)$ 在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。 什么是函数指针，如何定义函数指针，有什么使用场景 概念：函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。 定义形式如下:123int func(int a); int (*f)(int a); // 定义函数指针变量ff = &amp;func; 函数指针的应用场景：回调（callback）。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫Callback。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;// 定义函数指针类型, 参数为一个int, 返回值为inttypedef int (*FuncPointer) (int x);int addOne(int x) { return x + 1;}int addTwo(int x) { return x + 2;}// 函数指针作为函数的参数int addYouWant(FuncPointer fp, int x) { return fp(x);}int main() { FuncPointer fp; fp = addOne; cout &lt;&lt; fp(5) &lt;&lt; endl; fp = addTwo; cout &lt;&lt; fp(5) &lt;&lt; endl; cout &lt;&lt; addYouWant(addOne, 5) &lt;&lt; endl; cout &lt;&lt; fp &lt;&lt; endl; return 0;} 静态变量什么时候初始化作用域：cpp里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。 对于C语言的全局和静态变量(int, char, double等)，初始化发生在任何代码执行之前，属于编译期初始化.而cpp标准规定：全局或静态对象当且仅当对象首次用到时才进行构造初始化。 cpp规定，const的静态成员可以直接在类内初始化(编译器初始化)，而非const的静态成员需要在类外声明以初始化。对于后一种情况，我们一般选择在类的实现文件中初始化(运行期初始化)。 生命周期：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存。 nullptr调用成员函数可以吗？为什么？1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;class animal {public: void sleep() { cout &lt;&lt; &quot;animal sleep&quot; &lt;&lt; endl; } void breathe() { cout &lt;&lt; &quot;animal breathe haha&quot; &lt;&lt; endl; }};class fish : public animal {public: void breathe() { cout &lt;&lt; &quot;fish bubble&quot; &lt;&lt; endl; }};int main() { animal *pAn = nullptr; // 编译器静态绑定: animal::breathe(pAn) animal::breathe 不是虚函数且没有解引用的行为, 因此可以正常运行 pAn-&gt;breathe(); // 输出：animal breathe haha // fish::breathe(pFish) 不是虚函数且没有解引用的行为, 因此可以正常运行 fish *pFish = nullptr; pFish-&gt;breathe(); // 输出：fish bubble return 0;} 这是cpp的静态绑定, 因为在编译时对象就绑定了函数地址，和指针空不空没关系。pAn-&gt;breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。 什么是野指针，怎么产生的，如何避免？ 概念：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的） 产生原因：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误, 或者返回了函数中的指向栈中变量的指针(指针指向的内存被释放掉了)。或者使用未初始化的指针(指针未初始化)。 避免办法：（1）初始化置NULL（2）申请内存后判空（3）指针释放后置NULL（4）使用智能指针 内联函数和宏函数的区别宏定义不是函数，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；而内联函数本质上是一个函数，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。宏函数是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；而内联函数则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率宏定义是没有类型检查的，无论对还是错都是直接替换；而内联函数在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等 1、使用时的一些注意事项： 使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。 2、内联函数使用的条件： 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联, 即inline为内联建议。 12345678910111213141516#include &lt;cstdio&gt;// 宏函数#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))// 内联函数inline int max(int a, int b) { if (a &gt; b) return a; return b;} int main() { printf(&quot;macro function %d\\n&quot;, MAX(10, 5)); printf(&quot;inline function %d\\n&quot;, max(10, 5));} 运算符i++和++i的区别 赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。 效率不同：后置++执行速度比前置的慢。 i++ 不能作为左值，而 ++i 可以 两者都不是原子操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;ostream&gt;using namespace std;template &lt;typename T&gt;class Interger { T val;public: Interger (T v) : val(v){} T getVal() const { return this -&gt; val; } // ++ i Interger&amp; operator ++ () { this -&gt; val += 1; return *this; } // i ++ Interger operator ++ (int) { Interger&lt;T&gt; tmp(this -&gt; val); this -&gt; val += 1; return tmp; }};template &lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const Interger&lt;T&gt;&amp; u) { os &lt;&lt; u.getVal(); return os;}int main() { Interger&lt;int&gt; a(10), b(10); cout &lt;&lt; a ++ &lt;&lt; endl; cout &lt;&lt; ++ b &lt;&lt; endl; Interger&lt;float&gt; c(3.14); cout &lt;&lt; c ++ &lt;&lt; endl; cout &lt;&lt; ++ c &lt;&lt; endl; return 0;/* 输出10113.145.14*/} new和malloc的区别，各自底层实现原理 new是操作符(cpp关键字)，而malloc是c语言的库函数(cstdlib)。 new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。 malloc需要给定申请内存的大小，返回的指针(void *)需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。 new可以被重载(operator new)；malloc不行 new分配内存更直接和安全。 new发生错误抛出异常(bad_alloc)，malloc失败返回值为NULL new支持数组, 使用new[]和delete[]支持. new和delete在自由存储区上动态申请和分配内存, malloc和free在操作系统堆上动态申请和分配内存 new和delete可以调用malloc和free, 反之则否. malloc和free搭配使用. 其从操作系统的堆(Heap)内存区动态申请和释放内存空间. 当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址（有点像操作系统的空闲区链表）。 new和delete搭配使用. 其从 自由存储区 动态分配内存. 自由存储区是cpp中new和delete运算符分配和释放对象抽象出的概念. 操作系统的堆(Heap)和自由存储区并不等价. 大多数情况下, cpp编译器默认使用堆作为自由存储区, 也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来实现. 而可以通过重载new运算符, 改用其他内存来实现内存的分配, 例如全局变量做的对象池，这时自由存储区就区别于堆了。 new底层实现：关键字new在调用构造函数的时候实际上进行了如下的几个步骤： 通过operator new函数动态申请一块内存. 调用构造函数初始化这块内存（为这个新对象添加属性） 返回指向对象的指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;new&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;sstream&gt;using namespace std;class MyString {private: string str;public: MyString (const string&amp; s): str(s) { cout &lt;&lt; endl &lt;&lt; &quot;call mystring constructor function&quot; &lt;&lt; endl; } ~MyString () = default; static void* operator new (size_t size) throw() { cout &lt;&lt; endl &lt;&lt; &quot;call mystring operator new function!&quot; &lt;&lt; endl; // maclloc 函数实现 operator new void* p = malloc(size); // 编译器自带的全局operator new 实现 // void *p = ::operator new(size); if (p == NULL) throw bad_alloc(); return p; } static void* operator new (size_t size, void* p) { cout &lt;&lt; endl &lt;&lt; &quot;place ment new called!&quot; &lt;&lt; endl; return p; } // 通过getline实现字符串分割 vector&lt;string&gt; split(char delim) { stringstream ss(this -&gt; str); string word; vector&lt;string&gt; ans; while (getline(ss, word, delim)) ans.emplace_back(word); return ans; }};void printSplit(MyString* s, char delim) { // 通过delim字符进行分隔 auto ans = s -&gt; split(delim); cout &lt;&lt; &quot;string split result : &quot; &lt;&lt; endl; for (auto&amp; c : ans) cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;split string end !&quot; &lt;&lt; endl;}int main() { MyString* s = new MyString(&quot;I am using cpp.&quot;); printSplit(s, ' '); // placement new: 在一块已经分配好的内存上调用构造函数, 不涉及内存的动态申请 s = new (s) MyString(&quot;Testing,PlaceMent,New!&quot;); printSplit(s, ','); return 0;}/* 输出call mystring operator new function!call mystring constructor functionstring split result :Iamusingcpp.split string end !place ment new called!call mystring constructor functionstring split result :TestingPlaceMentNew!split string end !*/ const和define的区别const用于定义常量；而define用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的区别有： const生效于编译的阶段；define生效于预处理阶段。 const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。 const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。 函数指针和指针函数的区别 定义: 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。 写法 12指针函数：int *func(int x,int y);函数指针：int (*func)(int x,int y) Top-Level Const和Low-Level Const 顶层const表示指针是个常量, 这种指针称为指针常量. 底层const表示指针所指的对象是常量, 称为常量指针. 用于声明引用的const都是底层const, 简称为常量引用, 其能绑定到非常量对象、字面值和一般表达式上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;int main() { int i = 0; int* const p1 = &amp;i; // 顶层const, 常量指针, p1是常量 const int ci = 42; // 顶层const, 无法修改ci的值 const int *p2 = &amp;ci; // 底层const, 允许修改p2的值, 无法修改p2指向的值 const int* const p3 = p2; // 左边是底层const, 右边是顶层const, 无法修改p3以及修改p3指向的内容 const int&amp; r = ci; // 用于声明引用的const都是底层const int x = 10; // 常量引用绑定到左值上, 无法通过引用修改该变量 const int&amp; r1 = x; // 常量引用绑定到表达式上, 该表达式为右值, 因此常量引用绑定到了一个临时对象上 const int&amp; r2 = x ++ ; cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl; x = 1234; cout &lt;&lt; &quot;修改原变量 x 为 &quot; &lt;&lt; x &lt;&lt; &quot; 后, 常量引用r1值变成 &quot; &lt;&lt; r1 &lt;&lt; &quot; , 常量引用r2值变成 &quot; &lt;&lt; r2 &lt;&lt; endl; float f = 3.14; // 常量引用类型和原始类型不匹配 const int&amp; r3 = f; f = 4.567; cout &lt;&lt; &quot;修改f后, r3值为: &quot; &lt;&lt; r3 &lt;&lt; endl; // 常量引用绑定到类型匹配的const对象上去 const int cx = 4; const int&amp; r4 = cx; // 常量引用绑定到字面量上 const int&amp; r5 = 9527; return 0;/* 输出x = 11修改原变量 x 为 1234 后, 常量引用r1值变成 1234 , 常量引用r2值变成 10修改f后, r3值为: 3*/} 使用指针需要注意什么 定义指针时，先初始化为NULL, 防止使用未初始化的指针(野指针). 调用函数返回指针后, 判断指针是否为NULL, 如malloc. new一般不需要, 其失败的话会触发bad_alloc异常. 指针指向的内存回收后, 置指针为NULL. 如free一块动态内存后, 需要置NULL. 不返回指针栈区的指针. 防止指针悬挂. 指针作为访问数组的方式时, 需要自行确定访问区域是否合法, 访问越界的内存空间会造成不可预知的问题. 内联函数和函数的区别，内联函数的作用 内联函数比普通函数多了关键字inline 内联函数避免了函数调用的开销；普通函数有调用的开销 普通函数在被调用的时候，需要寻址（函数入口地址）；内联函数不需要寻址。 内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句；普通函数没有这个要求。 内联函数的作用：内联函数在调用时，是将调用表达式用内联函数体来替换(展开)。避免函数调用的开销。 cpp有几种传值方式，之间的区别是什么？传参方式有这三种：值传递、引用传递、指针传递 值传递：形参即使在函数体内值发生变化，也不会影响实参的值（拷贝）； 引用传递：形参在函数体内值发生变化，会影响实参的值； 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值； 值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。 c语言函数调用中参数入栈顺序1234567891011121314151617181920#include &lt;stdio.h&gt;void foo(int x, int y, int z){ printf(&quot;x = %d at [%X]\\n&quot;, x, &amp;x); printf(&quot;y = %d at [%X]\\n&quot;, y, &amp;y); printf(&quot;z = %d at [%X]\\n&quot;, z, &amp;z);}int main(int argc, char *argv[]){ foo(100, 200, 300); return 0; /* 输出x = 100 at [61FF10]y = 200 at [61FF14]z = 300 at [61FF18]*/} 系统栈是向低地址方向生长的. 因此z在栈底, 而x在栈顶. 从而可以推断出参数的入栈顺序是从右到左. 一般c/cpp编译器都用cdecl函数调用约定: 函数参数按照从右向左的顺序入栈，函数调用者负责清除栈中的参数. 从右到左的原因是可以方便的处理可变参数的问题(如printf函数). 这样栈顶就是最左边的参数, 在编译器就可以确定函数的参数相对于栈顶的相对地址reference. 参考资料牛客网dian神","link":"/2022/02/16/cpp/%5Bcpp%5D%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"title":"[LeetCode-周赛]第72场双周赛","text":"Rank : 91/4311Solved : 4/4 竞赛链接 统计数组中相等且可以被整除的数对思路模拟.数据范围和数值范围都很小, 直接$O(N^2)$枚举. Code1234567891011121314class Solution {public: int countPairs(vector&lt;int&gt;&amp; nums, int k) { int ans = 0; int n = nums.size(); for (int i = 0; i &lt; n; i ++ ) for (int j = i + 1; j &lt; n; j ++ ) { if (nums[i] == nums[j] and (i * j) % k == 0) ans ++ ; } return ans; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(1)$ 找到和为给定整数的三个连续整数思路如果连续整数为x - 1、x、和x + 1. 则和为3x必为3的倍数. Code12345678910class Solution {public: vector&lt;long long&gt; sumOfThree(long long num) { using LL = long long; if (num % 3) return {}; LL mid = num / 3; return {mid - 1, mid, mid + 1}; } }; 复杂度分析 时间复杂度$O(1)$ 空间复杂度$O(1)$ 拆分成最多数目的偶整数之和思路贪心. 如果是奇数则无解. 如果是偶数. 从小到大枚举[2, 4, 6, 8, ...]如果可以选择则贪心的选择当前数, 总和减去当前数. 如果最优解没有选择当前数, 选了比当前数大的数, 那么可以调整最优解选当前数, 这样选的可能多了1, 且选的总和多了一部分. 可以将多的这部分加到最优解的选的最大值上去. 逐步将最优解调整成贪心解. Code12345678910111213141516171819202122class Solution {public: vector&lt;long long&gt; maximumEvenSplit(long long s) { using LL = long long; if (s % 2 or s &lt; 0) return {}; if (s == 0) return {0}; vector&lt;LL&gt; ans; for (LL i = 2; ; i += 2) { if (s - i &gt; i) { ans.push_back(i); s -= i; } else { ans.push_back(s); break; } } return ans; }}; 复杂度分析 时间复杂度$O(\\sqrt{N})$ 空间复杂度$O(\\sqrt{N})$ 统计数组中好三元组数目思路首先将问题转换成一个数组上的问题.因为两个数组都是一个排列, 因此可将[0, n - 1]的值映射成其在nums1[]中的下标. 这样映射完成后, nums2中的一个数值递增三元组, 其映射前的数值在原来的nums1中一定是从前到后按序出现的并且在原nums2中是按下标递增出现的. 满足题目要求的好三元组. 另一方面, 在原nums1[]中的按下标递增的三元组, 按照上述映射后, 其映射值在映射后的nums2[]一定按值递增. 这样, 最终求映射后数组的数值递增三元组即可. 为了求数组的递增三元组, 枚举中间值, 求其左边严格小于当前值的个数left和右边严格大于当前值的个数right. 则以当前值为中间值的递增三元组的个数为$left * right$. 枚举所有的中间位置即可. 动态的快速求左边或者右边严格当前值的个数的方法，可以使用树状数组. 且这道题无需离散化映射, 因为是[0, n - 1]的排列, 将其映射成[1, n]即可. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152inline int lowbit(int x) { return x &amp; -x;}void add(vector&lt;int&gt;&amp; nums, int x, int c) { int n = nums.size(); for (int i = x; i &lt; n; i += lowbit(i)) nums[i] += c;}int query(vector&lt;int&gt;&amp; nums, int x) { int n = nums.size(); int ans = 0; for (int i = x; i; i -= lowbit(i)) ans += nums[i]; return ans;}class Solution {public: long long goodTriplets(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { using LL = long long; int n = nums1.size(); map&lt;int, int&gt; f; for (int i = 0; i &lt; n; i ++ ) f[nums1[i]] = i; for (auto&amp; c : nums2) c = f[c] + 1; LL ans = 0; vector&lt;int&gt; L(n + 1, 0), R(n + 1, 0); for (int i = 1; i &lt;= n; i ++ ) add(R, i, 1); for (int i = 0; i &lt; n; i ++ ) { int cur = nums2[i]; // remove from right add(R, cur, -1); int left = query(L, cur - 1), right = query(R, n) - query(R, cur); ans += 1ll * left * right; // add to left add(L, cur, 1); } return ans; }}; 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2022/02/19/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D%E7%AC%AC72%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"进程间通信的方式","text":"进程之间为了同步交互, 就需要进行进程之间的通信, 由于每个进程拥有独立的虚拟地址空间, 并且通过进程对应的页表记录虚拟页和物理内存页的映射. 因此需要提供额外的资源, 这份资源可以让目标进程获取以及操作来帮助不同进行之间完成通信. 而根据提供资源方法的不同, 造成了不同的进程间通信方式. 匿名管道匿名管道是进程之间通信的方式之一. 其方式是创建一个匿名管道实现父子\\兄弟进程通信, 通过内核缓冲区提供这份公开的资源用于通信. 操作系统实现对这块缓冲区的管理. 使得写进程只管写, 读进程只管读, 屏蔽了底层的具体实现过程. 主要特点 实现父子\\兄弟进程之间的通信 单向通信 面向字节流的服务 依赖文件系统 管道内部保持同步机制 依附于进程, 无法单独存在 测试样例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define BUFFSIZE 1024char buff[BUFFSIZE];int main() { // 文件描述符: fd[0]指向管道的读端,fd[1]指向管道的写端。fd[1]的输出是fd[0]的输入 int fd[2]; if (pipe(fd) == -1) { fprintf(stderr, &quot;pipe error!&quot;); return -1; } // fork进程 pid_t pid = fork(); if (pid == 0) { // 子进程关闭写 close(fd[1]); while (1) { char* msg = &quot;read from father process: &quot;; write(1, msg, strlen(msg)); int s = read(fd[0], buff, BUFFSIZE - 1); if (s &lt;= 0) break; // 将读入的数据输出到标准输出 write(1, buff, s); } // 结束读 char* readone = &quot;son process read done.\\n&quot;; write(1, readone, strlen(readone)); } else { // 父进程关闭读 close(fd[0]); int s = 0; // 从标准输入读入: 0-标准输入, 1-标准输出, 2-标准错误 while (s = read(0, buff, BUFFSIZE - 1), buff[0] != '\\n') { char* msg = &quot;write to son process: &quot;; write(1, msg, strlen(msg)); write(fd[1], buff, s); } // 结束写 char* writedone = &quot;father process write done.\\n&quot;; write(1, writedone, strlen(writedone)); } return 0;}/* 输出read from father process: Hi, Jsss ~write to son process: Hi, Jsss ~read from father process: Work Hard !write to son process: Work Hard !read from father process: Happy Life ~write to son process: Happy Life ~read from father process: Good Bye ~write to son process: Good Bye ~read from father process: father process write done.son process read done.*/ 命名管道匿名管道的局限在于通信进程只能是具有血缘关系的进程. 而更常见的情况是需要通信的双方不含有血缘关系. 针对这种情况, 命名管道就发挥作用了. 我们可能会比较熟悉Linux中常用的管道符 |. 它能将前一个进程的输出作为输入传入下一个进程, 快速的完成我们的一些需求. 如: 在某文件中查找特定字符及其位置. 123456789101112131415161718192021# cat 输出文件内容作为 grep的输入$ cat ubuntu_setup_env.sh | grep sudo -n8:SUDOERS_FILE=/etc/sudoers11:sudo apt-get update14:sudo apt remove -y --purge openssh-server15:sudo apt install -y openssh-server18:sudo apt install -y cmake gcc clang gdb valgrind build-essential21:sudo cp $SSHD_FILE ${SSHD_FILE}.`date '+%Y-%m-%d_%H-%M-%S'`.back22:sudo sed -i '/^Port/ d' $SSHD_FILE23:sudo sed -i '/^ListenAddress/ d' $SSHD_FILE24:sudo sed -i '/^UsePrivilegeSeparation/ d' $SSHD_FILE25:sudo sed -i '/^PasswordAuthentication/ d' $SSHD_FILE26:echo &quot;# configured by CLion&quot; | sudo tee -a $SSHD_FILE27:echo &quot;ListenAddress ${SSHD_LISTEN_ADDRESS}&quot; | sudo tee -a $SSHD_FILE28:echo &quot;Port ${SSHD_PORT}&quot; | sudo tee -a $SSHD_FILE29:echo &quot;UsePrivilegeSeparation no&quot; | sudo tee -a $SSHD_FILE30:echo &quot;PasswordAuthentication yes&quot; | sudo tee -a $SSHD_FILE32:sudo service ssh --full-restart35:sed -i '/^sudo service ssh --full-restart/ d' ~/.bashrc36:echo &quot;%sudo ALL=(ALL) NOPASSWD: /usr/sbin/service ssh --full-restart&quot; | sudo tee -a $SUDOERS_FILE40: sudo service ssh --full-restart 查看进程的状态 1234$ ps aux | grep sshroot 377 0.0 0.0 12180 3068 ? Ss 19:21 0:00 sshd: /usr/sbin/sshd [listener] 0 of 10-100 startupsjsss 768 0.0 0.0 8164 728 pts/5 S+ 20:06 0:00 grep --color=auto ssh#USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 主要特点 单向通信 支持任意进程间通信 依赖于文件系统 测试样例1234567891011121314151617181920212223242526// read.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt; #define BUFFSIZE 1024char buff[BUFFSIZE];int main() { // 从管道读取 FILE* fp = fopen(&quot;fifo&quot;, &quot;r&quot;); if (fp == NULL) { fprintf(stderr, &quot;fopen error&quot;); return -1; } while (fgets(buff, BUFFSIZE - 1, fp) != NULL) printf(&quot;read from FIFO: %s\\n&quot;, buff); fclose(fp); printf(&quot;read over!&quot;); return 0;} 123456789101112131415161718192021222324252627282930313233// write.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include&lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt; #define BUFFSIZE 1024char buff[BUFFSIZE];int main() { // 文件必须不存在 int st = mkfifo(&quot;fifo&quot;, 0644); if (st != 0) { fprintf(stderr, &quot;mkfifo error\\n&quot;); return -1; } // 写入管道 FILE* fp = fopen(&quot;fifo&quot;, &quot;w&quot;); if (fp == NULL) { fprintf(stderr, &quot;fopen error\\n&quot;); return -1; } for (int i = 10; i &lt;= 20; i ++ ) fprintf(fp, &quot;cur = %d\\n&quot;, i); fclose(fp); printf(&quot;write over!\\n&quot;); return 0;} 1234567891011121314151617181920212223242526# 先写后读, 运行结果read from FIFO: cur = 10read from FIFO: cur = 11read from FIFO: cur = 12read from FIFO: cur = 13read from FIFO: cur = 14read from FIFO: cur = 15read from FIFO: cur = 16read from FIFO: cur = 17read from FIFO: cur = 18read from FIFO: cur = 19read from FIFO: cur = 20$ ls -alprw-r--r-- 1 jsss jsss 0 Feb 28 22:20 fifo# fifo的文件类型为p : 即命名管道文件 信号量信号量是本质上是一个计数器, 用于控制多个共享进程对临界资源的访问. 信号量是操作系统内核所处理的, 因此不同的进程都可以访问的到信号量及其值. 从而实现多进程间的同步. 信号量主要支持两种操作, 且这两种操作均为原子操作, 即不会被打断: P操作. P操作是申请资源, 让信号量的值减1. 如果信号量值大于0, 则申请成功; 如果值为小于等于0, 就阻塞等待, 直到信号量值大于0被唤醒. V操作. V操作是释放资源, 让信号量的值加1. 如果有进程被信号量阻塞, 则唤醒; 如果没有则给信号量值加1. 主要特点 操作系统提供了一组关于信号量的同步访问临界资源的函数 一般和共享内存方法搭配使用进行进程间通信 初始值为1的信号量可以看做互斥锁. 因为同一时刻最多一个进程可以申请持有该信号量. 需要显式删除. 可以在代码中使用semctl函数删除. 也可以在终端下使用ipcrm -s命令删除. 测试样例测试样例和共享内存一起在下面给出, 是一个简单的生产者-消费者模型. 共享内存共享内存允许多个进程共享同一个物理内存区域以实现进行之间的通信. 其核心思路是不同进程的页表中包含了同一块物理内存, 而虚拟内存页可以是不同的. 基本流程是先向内核申请一块共享内存区域, 接着将该内存区域映射到进程的虚拟地址空间, 从而实现不同进程操作同一块共享内存区域, 实现进程间通信. 主要特点 直接在内存中操作, 速度较快 支持任意进程间通信 未提供同步机制, 需要自行利用信号量等实现进程间同步 支持双向通信 需要显式删除. 可以在代码中使用shmctl函数删除. 也可以在终端下使用ipcrm -m命令删除. 测试样例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172// shmwrite#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;// 缓冲区大小#define MAXN 10// 生产者生产总数#define ALL 20// 临界资源typedef struct buff { int arr[MAXN]; int finish; int curIdx;} Buff;// 用作初始化信号量的结构union semun{ int val; //使用的值 struct semid_ds *buf; // IPC_STAT、IPC_SET 使用的缓存区 unsigned short *arry; // GETALL、SETALL 使用的数组 struct seminfo *__buf; // IPC_INFO(Linux特有) 使用的缓存区 }; // 信号量初始化为给定值int initSem(int semid, int value);// P操作函数int P(int semid);// V操作函数int V(int semid);// 获取信号量值int getSem(int semid);// 删除信号量int deleteSem(int semid);int main() { // 创建一块共享内存, 返回共享内存标识. 参数key_t是长整型（唯一非零）, 系统建立IPC通讯 （ 消息队列、 信号量和 共享内存） 时必须指定一个ID值. int shmid = shmget((key_t)9527, sizeof(Buff), IPC_CREAT | 0644); if (shmid == -1) { fprintf(stderr, &quot;create shared memory error!\\n&quot;); return -1; } // 将共享主存attach到当前进程, 即映射到当前进程的虚拟内存空间 // shm指针指向共享内存区 Buff* shm = (Buff*)shmat(shmid, 0, 0); shm -&gt; finish = 0, shm -&gt; curIdx = -1; if ((void*)shm == (void*)-1) { fprintf(stderr, &quot;shmat error!\\n&quot;); return -1; } /* 创建信号量用于同步临界区代码. 参数key是整数值（唯一非零），不相关的进程可以通过它访问一个信号量， 它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用semget()函数并提供一个键， 再由系统生成一个相应的信号标识符（semget()函数的返回值），只有semget()函数才直接使用信号量键， 所有其他的信号量函数使用由semget()函数返回的信号量标识符。如果多个程序使用相同的key值，key将负责协调工作。 empty 记录空缓冲区的数量，full 记录满缓冲区的数量 */ int semid_empty = semget((key_t)99999, 1, IPC_CREAT | 0644); int semid_full = semget((key_t)66666, 1, IPC_CREAT | 0644); int semid_mutex = semget((key_t)12345, 1, IPC_CREAT | 0644); // 初始化 if (initSem(semid_empty, MAXN) == -1 || initSem(semid_full, 0) == -1 || initSem(semid_mutex, 1) == -1) { fprintf(stderr, &quot;init sem error!\\n&quot;); return -1; } int cnt = 0; while (cnt &lt; ALL) { // 先检查是否可以生产 P(semid_empty); // 申请互斥锁mutex进行生产 P(semid_mutex); // 临界区 srand((unsigned int)time(NULL)); ++ (shm -&gt; curIdx); shm -&gt; arr[shm -&gt; curIdx] = cnt; ++ cnt; printf(&quot;produce cur-val = %d, curIdx = %d, empty size = %d\\n&quot;, cnt, shm-&gt;curIdx, getSem(semid_empty)); // 释放锁以及一块满缓冲区 V(semid_mutex); V(semid_full); } // 等待消费者消费完成 while (!(shm -&gt; finish)) {} //把共享内存从当前进程中分离 if (shmdt(shm) == -1) { fprintf(stderr, &quot;shmdt error!\\n&quot;); return -1; } // 删除共享内存 if (shmctl(shmid, IPC_RMID, 0) == -1) { fprintf(stderr, &quot;shmctl error!\\n&quot;); return -1; } // 删除信号量 if (deleteSem(semid_full) == -1 || deleteSem(semid_empty) == -1 || deleteSem(semid_mutex) == -1) { fprintf(stderr, &quot;deleteSem error!\\n&quot;); return -1; } printf(&quot;write done!\\n&quot;); return 0;}int initSem(int semid, int value) { // 信号量初始化 union semun sem; sem.val = value; // semctl函数使用 SETVAL 初始化信号量 if (semctl(semid, 0, SETVAL, sem) == -1 ) return -1; return 0;}int P(int semid) { struct sembuf sem; sem.sem_num = 0; // 信号量编号为0 sem.sem_op = -1; // -1 表示 P操作 sem.sem_flg = SEM_UNDO; // 通常设置为SEM_UNDO,使操作系统跟踪信号量，并在进程没有释放该信号量而终止时，操作系统释放信号量 if (semop(semid, &amp;sem, 1) == -1) return -1; return 0;}int V(int semid) { struct sembuf sem; sem.sem_num = 0; // 信号量编号为0 sem.sem_op = 1; // -1 表示 P操作 sem.sem_flg = SEM_UNDO; // 通常设置为SEM_UNDO,使操作系统跟踪信号量，并在进程没有释放该信号量而终止时，操作系统释放信号量 if (semop(semid, &amp;sem, 1) == -1) return -1; return 0; }int getSem(int semid) { int ret = semctl(semid, 0, GETVAL); return ret;}int deleteSem(int semid) { union semun sem; if (semctl(semid, 0, IPC_RMID, sem) == -1) return -1; return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156// shmread#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt; // 缓冲区大小#define MAXN 10// 生产者生产总数#define ALL 20// 临界资源typedef struct buff { int arr[MAXN]; int finish; int curIdx;} Buff;// 用作初始化信号量的结构union semun{ int val; //使用的值 struct semid_ds *buf; // IPC_STAT、IPC_SET 使用的缓存区 unsigned short *arry; // GETALL、SETALL 使用的数组 struct seminfo *__buf; // IPC_INFO(Linux特有) 使用的缓存区 }; // 信号量初始化为给定值int initSem(int semid, int value);// P操作函数int P(int semid);// V操作函数int V(int semid);// 获取信号量值int getSem(int semid);// 删除信号量int deleteSem(int semid);int main() { // 创建一块共享内存, 返回共享内存标识. 参数key_t是长整型（唯一非零）, 系统建立IPC通讯 （ 消息队列、 信号量和 共享内存） 时必须指定一个ID值. int shmid = shmget((key_t)9527, sizeof(Buff), IPC_CREAT | 0644); if (shmid == -1) { fprintf(stderr, &quot;create shared memory error!\\n&quot;); return -1; } // 将共享主存attach到当前进程, 即映射到当前进程的虚拟内存空间 // shm指针指向共享内存区 Buff* shm = (Buff*)shmat(shmid, 0, 0); if ((void*)shm == (void*)-1) { fprintf(stderr, &quot;shmat error!\\n&quot;); return -1; } /* 创建信号量用于同步临界区代码. 参数key是整数值（唯一非零），不相关的进程可以通过它访问一个信号量， 它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用semget()函数并提供一个键， 再由系统生成一个相应的信号标识符（semget()函数的返回值），只有semget()函数才直接使用信号量键， 所有其他的信号量函数使用由semget()函数返回的信号量标识符。如果多个程序使用相同的key值，key将负责协调工作。 empty 记录空缓冲区的数量，full 记录满缓冲区的数量 */ int semid_empty = semget((key_t)99999, 1, 0644); int semid_full = semget((key_t)66666, 1, 0644); int semid_mutex = semget((key_t)12345, 1, 0644); if (semid_full == -1 || semid_empty == -1 || semid_mutex == -1) { fprintf(stderr, &quot;semget error!\\n&quot;); return -1; } int cnt = 0; // 消费者进行消费 while (cnt &lt; ALL) { // 先检查是否可以消费 P(semid_full); // 申请互斥锁mutex进行消费 P(semid_mutex); // 临界区 ++ cnt; printf(&quot;consume cur-val = %d, curIdx = %d, full size = %d\\n&quot;, shm-&gt;arr[shm-&gt;curIdx] , shm-&gt;curIdx, getSem(semid_full)); -- (shm -&gt; curIdx); if (cnt == ALL) shm -&gt; finish = 1; // 释放锁以及一块空缓冲区 V(semid_mutex); V(semid_empty); } //把共享内存从当前进程中分离 if (shmdt(shm) == -1) { fprintf(stderr, &quot;shmdt error!\\n&quot;); return -1; } printf(&quot;read done!\\n&quot;); return 0;}int initSem(int semid, int value) { // 信号量初始化 union semun sem; sem.val = value; // semctl函数使用 SETVAL 初始化信号量 if (semctl(semid, 0, SETVAL, sem) == -1 ) return -1; return 0;}int P(int semid) { struct sembuf sem; sem.sem_num = 0; // 信号量编号为0 sem.sem_op = -1; // -1 表示 P操作 sem.sem_flg = SEM_UNDO; // 通常设置为SEM_UNDO,使操作系统跟踪信号量，并在进程没有释放该信号量而终止时，操作系统释放信号量 if (semop(semid, &amp;sem, 1) == -1) return -1; return 0;}int V(int semid) { struct sembuf sem; sem.sem_num = 0; // 信号量编号为0 sem.sem_op = 1; // 1 表示 V 操作 sem.sem_flg = SEM_UNDO; // 通常设置为SEM_UNDO,使操作系统跟踪信号量，并在进程没有释放该信号量而终止时，操作系统释放信号量 if (semop(semid, &amp;sem, 1) == -1) return -1; return 0; }int getSem(int semid) { int ret = semctl(semid, 0, GETVAL); return ret;}int deleteSem(int semid) { union semun sem; if (semctl(semid, 0, IPC_RMID, sem) == -1) return -1; return 0;} 执行结果: 12345678910111213141516171819202122$ ./shmwrite.o produce cur-val = 1, curIdx = 0, empty size = 9produce cur-val = 2, curIdx = 1, empty size = 8produce cur-val = 3, curIdx = 2, empty size = 7produce cur-val = 4, curIdx = 3, empty size = 6produce cur-val = 5, curIdx = 4, empty size = 5produce cur-val = 6, curIdx = 5, empty size = 4produce cur-val = 7, curIdx = 6, empty size = 3produce cur-val = 8, curIdx = 7, empty size = 2produce cur-val = 9, curIdx = 8, empty size = 1produce cur-val = 10, curIdx = 9, empty size = 0produce cur-val = 11, curIdx = 2, empty size = 7produce cur-val = 12, curIdx = 2, empty size = 7produce cur-val = 13, curIdx = 2, empty size = 7produce cur-val = 14, curIdx = 2, empty size = 7produce cur-val = 15, curIdx = 2, empty size = 7produce cur-val = 16, curIdx = 2, empty size = 7produce cur-val = 17, curIdx = 2, empty size = 7produce cur-val = 18, curIdx = 2, empty size = 7produce cur-val = 19, curIdx = 2, empty size = 7produce cur-val = 20, curIdx = 2, empty size = 7write done! 12345678910111213141516171819202122$ ./shmread.o consume cur-val = 9, curIdx = 9, full size = 9consume cur-val = 8, curIdx = 8, full size = 8consume cur-val = 7, curIdx = 7, full size = 7consume cur-val = 6, curIdx = 6, full size = 6consume cur-val = 5, curIdx = 5, full size = 5consume cur-val = 4, curIdx = 4, full size = 4consume cur-val = 3, curIdx = 3, full size = 3consume cur-val = 2, curIdx = 2, full size = 2consume cur-val = 10, curIdx = 2, full size = 2consume cur-val = 11, curIdx = 2, full size = 2consume cur-val = 12, curIdx = 2, full size = 2consume cur-val = 13, curIdx = 2, full size = 2consume cur-val = 14, curIdx = 2, full size = 2consume cur-val = 15, curIdx = 2, full size = 2consume cur-val = 16, curIdx = 2, full size = 2consume cur-val = 17, curIdx = 2, full size = 2consume cur-val = 18, curIdx = 2, full size = 2consume cur-val = 19, curIdx = 2, full size = 2consume cur-val = 1, curIdx = 1, full size = 1consume cur-val = 0, curIdx = 0, full size = 0read done! ipcs 查看共享内存和信号量的使用情况. 12345678910111213$ ipcs------ Message Queues --------key msqid owner perms used-bytes messages ------ Shared Memory Segments --------key shmid owner perms bytes nattch status 0x00002537 18 jsss 644 48 1 ------ Semaphore Arrays --------key semid owner perms nsems 0x0001869f 54 jsss 644 1 0x0001046a 55 jsss 644 1 0x00003039 56 jsss 644 1 执行流程: 先执行了shmwrite进行生产, 因此很快缓冲区被填满. 接着执行ipcs查看IPC的使用情况. 最后执行shmread进行消费, 消费了前八个后基本就是生产一个消费一个的动态平衡状态. 参考资料 信号量 信号量 信号量 共享内存","link":"/2022/02/28/OS/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"title":"无锁队列的原理和实现","text":"无锁队列是指多线程对于队列的操作无需添加粒度较大的独占锁mutex, 而是通过细粒度的CAS(compare and swap)原子操作实现多线程下的同步. 其主要思想是: 使用mutex的锁的代价太高, 那就使用更小粒度的锁, 甚至这个锁的粒度是一条赋值指令. 很多情况下, 一个完整事件的处理流程可以拆分成几个子事件. 虽然各子事件有顺序关系, 但无强烈的时间上的约束. 这样当该阶段处理完成后, 我们可以给下一个阶段传递一条消息. 下阶段接收到消息后, 再进行处理. 这里传递消息的数据结构可以是无锁队列. 保证了高并发和分布式场景下的快速处理需求和一定的前后顺序. 这就类似于生产者-消费者问题: 多个生产者产生多个事件, 给下一阶段的消费者处理. 本篇博客主要参考了酷壳陈皓关于无锁队列的讲解博客以及原始的论文-Implementing Lock-Free Queues和改进的论文-Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms. CAS操作Compare And Swap (CAS)是现代操作系统支持的原子性操作, 如X86中CMPXCHG汇编指令. 其实现逻辑如下: 12345678bool compare_and_swap(int *addr, int oldVal, int newVal){ if (*addr != oldVal) return false; *addr = newVal; return true;} addr指向内存中的某个变量, 如果该内存值为oldVal, 那么就将其置newVal并返回成功; 否则直接返回失败. 有了CAS操作, 多线程情况下我们可以保证某个共享变量值为我们期待值时才执行某些操作, 从而实现同步. GCC的CAS 12bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...) cpp11的CAS 123456template&lt; class T &gt;bool atomic_compare_exchange_weak( std::atomic* obj, T* expected, T desired );template&lt; class T &gt;bool atomic_compare_exchange_weak( volatile std::atomic* obj, T* expected, T desired ); 逻辑实现可以通过链表或数组实现. 数组实现的话由于数组大小需要指定而队列长度不一定知道, 因此需要实现循环队列. 存在一定的局限性. 基于链表的实现用链表实现队列的时候, 为了避免麻烦的边界判断, 我们可以添加头结点. 初始化时申请头结点, 并且head指针和tail指针均指向该结点. 入队操作 设入队新建结点的指针为p, 则p -&gt; next = nullptr, 入队操作需要两步实现. tail -&gt; next = p tail = p 为了保证第一步的并发正确性. 我们持续不断获取tail的快照, 记为cur. 直到CAS(cur -&gt; next, nullptr, p). 即如果cur -&gt; next = nullptr成立, 则当前cur一定为正确的tail. 接着我们将cur -&gt; next更新成p. 这样是正确的. 因为当某个线程执行完这一步后. tail指针还未更新成p, 这样其他所有线程都在轮询等待tail指针的next为空, 无法入队. 当轮询完成第一步后, 我们退出循环. 然后执行CAS(tail, cur, p). 即将尾指针置为新入队结点. 结点定义 12345678910 // 使用cpp11实现, 用了atomic类对象的方法实现CAS操作 // 结点定义 struct Node { T val; atomic&lt;Node*&gt; next; Node () : val(T()), next(atomic&lt;Node*&gt;(nullptr)) {} Node (const T&amp; _v) : val(_v), next(atomic&lt;Node*&gt;(nullptr)){} Node (const T&amp; _v, atomic&lt;Node*&gt; _next) : val(_v), next(_next) {}}; 入队(VERSION-1) 1234567891011121314151617// VERSION-1void enqueue(T _val) { // p指向插入结点 Node* p = new Node(_val); Node* cur; // Node* null = nullptr; while (true) { cur = tail.load(); // CAS(cur -&gt; next, nullptr, p) if (cur -&gt; next.compare_exchange_weak(null, p) == true) break; } // CAS(tail, cur, p) tail.compare_exchange_weak(cur, p);} 以上操作的流程会出现一个问题. 因为只有入队的线程才能将tail指针更新, 因此如果该线程入队后还未更新tail就结束了. 那么其他所有入队线程都将死锁. 因为他们CAS(cur -&gt; next, nullptr, p)时, cur -&gt; next一定不为空, 此时可能出现cur -&gt; next = p. 为了解决上述可能存在的问题. 我们主要解决思路是让其他线程也可以移动tail指针. 一个简单的方法是, 如果当前线程CAS(cur -&gt; next, nullptr, p)入队失败了, 那么说明当前cur不是真正的tail, 那么我们尝试CAS(tail, cur, cur -&gt; next). 即尝试让tail往后走. 然后再获取tail的快照, 按照之前的流程轮询(Retry-loop). 入队(VERSION-2) 123456789101112131415161718192021// VERSION-2void enqueue(T _val) { // p指向插入结点 Node* p = new Node(_val); Node* cur; // Node* null = nullptr; while (true) { cur = tail.load(); // CAS(cur -&gt; next, nullptr, p) if (cur -&gt; next.compare_exchange_weak(null, p) == true) break; // CAS(tail, cur, cur -&gt; next) else tail.compare_exchange_weak(cur, cur -&gt; next) } // CAS(tail, cur, p) tail.compare_exchange_weak(cur, p);} 较为复杂的方法是, 获取tail的快照cur, 并记录cur -&gt; next为next. 接着判断cur是否为tail. 如果不为就重新开始. 然后判断next是否为空. 如果不为空, 我们就尝试更新tail, 更新的语句是CAS(tail, cur, next). 如果为空. 我们就尝试CAS(tail -&gt; next, next, p)入队(此时next = nullptr). 入队(VERSION-3) 12345678910111213141516171819202122232425void enqueue (T _val) { // 插入结点为p Node* p = new Node(_val); Node *cur, *next; Node* null = nullptr; while (true) { // cur 指针为尾结点的快照 cur = tail.load(); // next 指针为为尾结点下一个结点 next = cur -&gt; next; // 如果尾指针被移动, 则重新获取cur和next (可能被其他线程移动了, 重新获取以减少CAS操作次数) if (cur != tail.load()) continue; if (next != nullptr) { // 当next指针不为空时, 尝试移动tail指针, 防止出现死锁 tail.compare_exchange_weak(cur, next); continue; } // 实现第一步操作: tail -&gt; next = p if (cur-&gt;next.compare_exchange_weak(null, p) == true) break; } // 实现第二步操作: tail = p tail.compare_exchange_weak(cur, p);}; 出队操作 出队操作类似于入队操作的思路. 我们首先获取head的快照cur. 然后判断cur -&gt; next是否为空, 如果为空说明此时队列为空, 返回队列为空的信号. 如果不为空, 我们CAS(head, cur, cur -&gt; next)来重置head的指针. 然后返回cur -&gt; next -&gt; val, 因为此时cur指向之前的头结点, cur -&gt; next -&gt; val为出队前的队头. 出队(VERSION-1) 1234567891011121314151617 bool dequeue (T&amp; _ret) { // 返回true: 出队成功, 返回值存在 _ret参数中 Node* cur; while (true) { cur = head.load(); if (cur -&gt; next == nullptr) return false; // CAS(head, cur, cur -&gt; next) if (head.compare_exchange_weak(cur, cur -&gt; next)) break; } _ret = cur -&gt; next -&gt; val; // 释放原头结点 delete cur; return true;} 上述思路存在几个问题. 首先比较严重的是, 如果我们CAS(head, cur, cur -&gt; next)成功了, 也就是逻辑上执行了head = head -&gt; next, 此时如果另外一个线程也执行了出队操作, 并且已经将队头free掉了. 那我们再访问cur -&gt; next -&gt; val时明显就出现了访问非法内存. 因此一个核心问题是: 在获取到其队头元素值之前, 其他线程不能执行出队操作. 为了保证队头结点不被free掉. 我们可以在CAS操作之前访问. 这样保证CAS操作成功后, 我们一定已经拿到了队头. 即使此时其他线程执行出队操作. 也不影响该线程的正确性. 具体而言, 我们定义一个next指针, 初始next = cur -&gt; next. 然后判断cur是否等于head. 如果不等于则重新获取快照(减少不必要的CAS操作). 如果等于, 接着判断next是否为空, 如果为空说明此时队列为空, 返回. 接着先记录next结点的值, 然后尝试通过CAS操作移动head. 即CAS(head, cur, cur -&gt; next). 出队(VERSION-2) 123456789101112131415161718192021222324 bool dequeue (T&amp; _ret) { Node *cur, *next; while (true) { cur = head.load(); next = cur-&gt;next; // 如果头指针被移动, 则重新获取其快照 (可能被其他线程移动了, 重新获取以减少CAS操作次数) if (cur != head.load()) continue; // 队列为空, 出队失败 if (next == nullptr) return false; // 在CAS操作前记录返回值, 如果在CAS操作之后则该结点有可能被其他线程free _ret = next-&gt;val; // 实现出队的操作. head = head -&gt; next if (head.compare_exchange_weak(cur, next)) break; } // 释放原头结点 delete cur; return true;} 上述版本还存在一个问题. 如果在判断next == nullptr时, 一个入队操作执行完成了第一步, 还没移动tail指针. 此时如果队列只有这个一个元素. 那么head = tail 且 next = p. 出队的话会将tail指向被free的原头结点. 具体图示可以查看酷壳陈皓关于无锁队列的讲解博客 解决的思路和入队解决死锁的思路是一样的. 即当我们发现head == tail 且 next != nullptr时, 我们尝试更新tail即可. 出队(VERSION-3) 123456789101112131415161718192021222324252627282930bool dequeue (T&amp; _ret) { Node *nowHead, *nowTail, *next; while (true) { nowHead = head.load(), nowTail = tail.load(); next = nowHead -&gt; next; // 如果头指针被移动, 则重新获取其快照 (可能被其他线程移动了, 重新获取以减少CAS操作次数) if (nowHead != head.load()) continue; // 队列为空, 出队失败 if (nowHead == nowTail and next == nullptr) return false; // tail指针未正确取值, 尝试移动tail if (nowHead == nowTail and next != nullptr) { tail.compare_exchange_weak(nowTail, next); continue; } // 在CAS操作前记录返回值, 如果在CAS操作之后则该结点有可能被其他线程free _ret = next-&gt;val; // 实现出队的操作. head = head -&gt; next if (head.compare_exchange_weak(nowHead, next)) break; } // 释放原头结点 delete nowHead; return true;} 代码实现首先通过上述分析, 使用cpp11进行了代码实现. 接着对实现的代码进行正确性测试、内存检查和性能测试. 正确性检查思路. 检查每个物品是否只入队一次且只出队一次. 内存检查. CLion中使用Valgrind的Memcheck工具在WSL环境下进行检查. 性能测试. 与使用mutex的版本进行比较. setting.h: 全局设置 123456789101112131415161718192021//// Created by Jsss on 2022/3/12.//#ifndef LOCKFREEQUEUE_SETTING_H#define LOCKFREEQUEUE_SETTING_H// 生产者数量int producerWorks = 4;// 消费者数量int consumerWorks = 4;// 每个生产者生产的个数int producerNums = 1e6;// 重复次数int epochs = 10;#endif //LOCKFREEQUEUE_SETTING_H LockFreeQueue.h: 无锁队列的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//// Created by Jsss on 2022/3/12.//#ifndef LOCKFREEQUEUE_LOCKFREEQUEUE_H#define LOCKFREEQUEUE_LOCKFREEQUEUE_H#pragma once#include &lt;atomic&gt;using std::atomic;template &lt;typename T&gt;class LockFreeQueue{public: struct Node { T val; atomic&lt;Node*&gt; next; Node () : val(T()), next(atomic&lt;Node*&gt;(nullptr)) {} Node (const T&amp; _v) : val(_v), next(atomic&lt;Node*&gt;(nullptr)){} Node (const T&amp; _v, atomic&lt;Node*&gt; _next) : val(_v), next(_next) {} }; LockFreeQueue () { Node* dummy = new Node; head.store(dummy); tail.store(dummy); }; // 入队操作 void enqueue (T _val) { // 插入结点为p Node* p = new Node(_val); Node *cur, *next; Node* null = nullptr; while (true) { // cur 指针为尾结点的快照 cur = tail.load(); // next 指针为为尾结点下一个结点 next = cur -&gt; next; // 如果尾指针被移动, 则重新获取cur和next (可能被其他线程移动了, 重新获取以减少CAS操作次数) if (cur != tail.load()) continue; if (next != nullptr) { // 当next指针不为空时, 尝试移动tail指针, 防止出现死锁 tail.compare_exchange_weak(cur, next); continue; } // 实现第一步操作: tail -&gt; next = p if (cur-&gt;next.compare_exchange_weak(null, p) == true) break; } // 实现第二步操作: tail = p tail.compare_exchange_weak(cur, p); }; // version 1// bool dequeue (T&amp; _ret) {// Node *nowHead, *next;//// while (true) {// nowHead = head.load();// next = nowHead-&gt;next;// // 如果头指针被移动, 则重新获取其快照 (可能被其他线程移动了, 重新获取以减少CAS操作次数)// if (nowHead != head.load())// continue;// // 队列为空, 出队失败// if (next == nullptr)// return false;// // 在CAS操作前记录返回值, 如果在CAS操作之后则该结点有可能被其他线程free// _ret = next-&gt;val;// // 实现出队的操作. head = head -&gt; next// if (head.compare_exchange_weak(nowHead, next))// break;// }// // 释放原头结点// delete nowHead;// return true;// } // version 2 bool dequeue (T&amp; _ret) { Node *nowHead, *nowTail, *next; while (true) { nowHead = head.load(), nowTail = tail.load(); next = nowHead -&gt; next; // 如果头指针被移动, 则重新获取其快照 (可能被其他线程移动了, 重新获取以减少CAS操作次数) if (nowHead != head.load()) continue; // 队列为空, 出队失败 if (nowHead == nowTail and next == nullptr) return false; // tail指针未正确取值, 尝试移动tail if (nowHead == nowTail and next != nullptr) { tail.compare_exchange_weak(nowTail, next); continue; } // 在CAS操作前记录返回值, 如果在CAS操作之后则该结点有可能被其他线程free _ret = next-&gt;val; // 实现出队的操作. head = head -&gt; next if (head.compare_exchange_weak(nowHead, next)) break; } // 释放原头结点 delete nowHead; return true; } // 删除拷贝构造函数和拷贝赋值函数 LockFreeQueue (const LockFreeQueue&amp; ) = delete; LockFreeQueue operator = (const LockFreeQueue&amp;) = delete;private: atomic&lt;Node*&gt; head, tail;};#endif //LOCKFREEQUEUE_LOCKFREEQUEUE_H check.cpp: 正确性检查 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//// Created by Jsss on 2022/3/12.//#include &lt;iostream&gt;#include &lt;vector&gt;#include &quot;LockFreeQueue.h&quot;#include &quot;setting.h&quot;#include &lt;thread&gt;#include &lt;chrono&gt;using std::vector;using std::thread;using std::cout;int all = producerWorks * producerNums;// 记录物品的生产和消费vector&lt;atomic&lt;int&gt;&gt; in(all), out(all);// 记录生产者和消费者完成数目atomic&lt;int&gt; prodFinish(0);LockFreeQueue&lt;int&gt; qu;void produce (int _id) { // 确定生产者生产编号的范围, 保证每个生产者生产的物品唯一 int L = _id * producerNums, R = (_id + 1) * producerNums - 1; for (int u = L; u &lt;= R; u ++ ) { qu.enqueue(u); in[u].fetch_add(1) ; } // 生产完毕则, finish个数 + 1 cout &lt;&lt; &quot;produce &quot; &lt;&lt; _id &lt;&lt; &quot; finish.\\n&quot;; prodFinish.fetch_add(1);}void consume () { // 必须使用CAS操作判断, 如果prodFinish的值不为producerWorks的数目, 即生产者还在生产, 就继续尝试消费 int cur;// while (prodFinish.load() &lt; producerWorks) { while (prodFinish.compare_exchange_weak(producerWorks, producerWorks) == false) { // 取成功则对应位置的 out + 1 while (qu.dequeue(cur)) out[cur].fetch_add(1); }}void lastConsume () { int cur; while (qu.dequeue(cur)) out[cur].fetch_add(1);}void check() { int inCnt = 0, outCnt = 0; for (int i = 0; i &lt; all; i ++ ) if (in[i].load() != 1) { cout &lt;&lt; &quot;produce object &quot; &lt;&lt; i &lt;&lt; &quot; error, val = &quot; &lt;&lt; in[i].load() &lt;&lt; '\\n'; inCnt ++ ; } for (int i = 0; i &lt; all; i ++ ) if (out[i].load() != 1) { cout &lt;&lt; &quot;consume object &quot; &lt;&lt; i &lt;&lt; &quot; error, val = &quot; &lt;&lt; out[i].load() &lt;&lt; '\\n'; outCnt ++ ; } cout &lt;&lt; &quot;\\nerror in count = &quot; &lt;&lt; inCnt &lt;&lt; '\\n'; cout &lt;&lt; &quot;error out count = &quot; &lt;&lt; outCnt &lt;&lt; '\\n';}int main() { std::chrono::time_point&lt;std::chrono::system_clock&gt; start_time = std::chrono::system_clock::now(); // 初始化in 和 out (atomic类禁止拷贝构造和移动构造, 使用atomic_init()函数实现其初始化) for (auto&amp; c : in) std::atomic_init(&amp;c, 0); for (auto&amp; c : out) std::atomic_init(&amp;c, 0); vector&lt;thread&gt; prod(producerWorks), cons(consumerWorks); for (int i = 0; i &lt; producerWorks; i ++ ) prod[i] = thread(produce, i); for (auto&amp; t : cons) t = thread(consume); for (auto&amp; t : prod) t.join(); for (auto&amp; t : cons) t.join(); // 当生产者生产完毕后, 添加最后一个消费者, 该消费者保证能够将剩下的物品消费完毕 lastConsume(); // 消费完毕后, 进行正确性检查. check(); std::chrono::time_point&lt;std::chrono::system_clock&gt; end_time = std::chrono::system_clock::now(); std::chrono::milliseconds time = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_time - start_time); cout &lt;&lt; &quot;\\ncost time = &quot; &lt;&lt; time.count() &lt;&lt; &quot; ms\\n&quot;; return 0;} benchmark_lockfree.cpp: 无锁队列性能测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//// Created by Jsss on 2022/3/13.//#include &lt;iostream&gt;#include &lt;vector&gt;#include &quot;LockFreeQueue.h&quot;#include &quot;setting.h&quot;#include &lt;thread&gt;#include &lt;chrono&gt;using std::vector;using std::thread;using std::cout;int all = producerWorks * producerNums;// 记录生产者和消费者完成数目atomic&lt;int&gt; prodFinish(0);LockFreeQueue&lt;int&gt; qu;void produce (int _id) { // 确定生产者生产编号的范围, 保证每个生产者生产的物品唯一 int L = _id * producerNums, R = (_id + 1) * producerNums - 1; for (int u = L; u &lt;= R; u ++ ) qu.enqueue(u); // 生产完毕则, finish个数 + 1 prodFinish.fetch_add(1);}void consume () { // 必须使用CAS操作判断, 如果prodFinish的值不为producerWorks的数目, 即生产者还在生产, 就继续尝试消费 int cur;// while (prodFinish.load() &lt; producerWorks) { while (prodFinish.compare_exchange_weak(producerWorks, producerWorks) == false) { // 取成功则对应位置的 out + 1 while (qu.dequeue(cur)) ; }}void lastConsume () { int cur; while (qu.dequeue(cur)) ;}void epochRunLockFree() { vector&lt;thread&gt; prod(producerWorks), cons(consumerWorks); for (int i = 0; i &lt; producerWorks; i ++ ) prod[i] = thread(produce, i); for (auto&amp; t : cons) t = thread(consume); for (auto&amp; t : prod) t.join(); for (auto&amp; t : cons) t.join(); // 当生产者生产完毕后, 添加最后一个消费者, 该消费者保证能够将剩下的物品消费完毕 lastConsume();}int main() { std::chrono::time_point&lt;std::chrono::system_clock&gt; start_time = std::chrono::system_clock::now(); for (int i = 0; i &lt; epochs; i ++ ) epochRunLockFree(); std::chrono::time_point&lt;std::chrono::system_clock&gt; end_time = std::chrono::system_clock::now(); std::chrono::milliseconds time = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_time - start_time); cout &lt;&lt; &quot;\\nepoch cost average time = &quot; &lt;&lt; time.count() / epochs &lt;&lt; &quot; ms\\n&quot;; return 0;} 测试结果 正确性测试 1234567891011produce 1 finish.produce 0 finish.produce 3 finish.produce 2 finish.error in count = 0error out count = 0cost time = 1273 msProcess finished with exit code 0 Valgrind内存检查 无锁队列性能测试 123epoch cost average time = 987 msProcess finished with exit code 0 mutex队列性能测试 123epoch cost average time = 378 msProcess finished with exit code 0 分析总结 使用无锁队列比mutex更慢的原因可能有2. 其一是无锁队列中使用了结构体, 并使用new和delete申请和释放, 频繁调用导致比mutex版本的int更慢. 其二是结构体使用了atomic&lt;Node*&gt;作为next指针. 如果使用普通的Node*并使用__sync_bool_compare_and_swap()可能会比现在更快. 实验用的机器是自己的笔记本. cpu是5800H, 八核心十六线程. 使用设置生产线程=2, 消费线程=2, 生产个数=2e6的时候耗时700ms左右; 当设置生产线程=4, 消费线程=4, 生产个数=1e6的时候耗时900ms左右; 而设置生产线程=8, 消费线程=8, 生产个数=5e5的时候耗时在1300ms左右. 相同的生产个数, 随着核心数的增加, 耗时却在增加, 这可能是多核情况下必须缓存一致性协议(MESI)来保持多核缓存一致, 而且使用了atomic, 导致耗时增加. 无锁队列可能适应于分布式场景下. 利用多设备的计算资源进行业务的分阶段处理. 参考 酷壳陈皓关于无锁队列的讲解博客 Implementing Lock-Free Queues Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms TODO 代码整理, 上传Github 解决ABA问题","link":"/2022/03/13/ConcurrencyAndDistribution/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"},{"title":"[LeetCode-周赛]286","text":"Rank : 111/21134Solved : 4/4 竞赛链接 Find the Difference of Two Arrays思路模拟题意即可. 使用哈希表unordered_set可以快速判断某个数是否存在. Code12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;vector&lt;int&gt;&gt; findDifference(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { vector&lt;vector&lt;int&gt;&gt; ret; // 存储nums1 和 nums2 unordered_set&lt;int&gt; st1, st2; for (auto&amp; num : nums1) st1.insert(num); for (auto&amp; num : nums2) st2.insert(num); // 存储答案 unordered_set&lt;int&gt; ans1, ans2; for (auto&amp; num : nums1) if (st2.count(num) == 0) ans1.insert(num); for (auto&amp; num : nums2) if (st1.count(num) == 0) ans2.insert(num); vector&lt;int&gt; ret1, ret2; for (auto&amp; w : ans1) ret1.push_back(w); for (auto&amp; w : ans2) ret2.push_back(w); ret.push_back(ret1); ret.push_back(ret2); return ret; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ Minimum Deletions to Make Array Beautiful思路贪心. 假设左边已经保留了left个数字, 当前枚举到i位置. 我们从i位置开始往右找j, 直到nums[j] == nums[i]不满足为止(双指针算法). 这样我们找到了一段与nums[i]相等的子数组. 现在我们判断: 如果left为奇数: 说明i是答案中的奇数下标, 因此我们可以最多保留2个nums[i]. 它两的位置是先奇数再偶数, 这样满足题意. 如果left为偶数: 说明i是答案中的偶数下标, 因此我们只能保留1个nums[i]. 贪心选择完成后, 我们最后检查保留数组的长度是否为奇数, 如果为奇数, 去掉最后一个即可. Code12345678910111213141516171819202122class Solution {public: int minDeletion(vector&lt;int&gt;&amp; nums) { int left = 0, n = nums.size(); for (int i = 0; i &lt; n; ) { int j = i; while (j &lt; n and nums[j] == nums[i]) j ++ ; int len = j - i; if (left &amp; 1) left += min(2, len); else left += 1; i = j; } if (left &amp; 1) left -= 1; return n - left; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(1)$ Find Palindrome With Fixed Length思路模拟题意. 题目限定了回文数字的长度为intLength, 这样我们可以自由指定的长度为 $len = \\lceil intLength / 2 \\rceil$. 除了首位必须大于0之外, 我们可以任意的指定其他位置数字, 并且由于回文数字的长度相等且比较数字的时候先比较高位, 因此高位的排序就是最后回文数字的排序. 我们记录 $L = pow(10, len - 1), R = pow(10, len) - 1$. 如果我们要求第k个回文数字, 那么它的高位一定是L + k - 1, 然后我们根据长度是奇数还是偶数将高位和低位拼接在一起即可. 还需要检查 $L + k - 1 &lt;= R$ 是否满足, 若不满足则不存在这样的第k个回文数字, 答案为-1. Code1234567891011121314151617181920212223242526272829using LL = long long;class Solution {public: vector&lt;long long&gt; kthPalindrome(vector&lt;int&gt;&amp; qu, int alen) { int len = (alen + 1) / 2; vector&lt;LL&gt; ans; for (auto&amp; k : qu) { // 计算L, R : 回文数字的下界和上界 int L = pow(10, len - 1), R = pow(10, len) - 1; L += k - 1; // 判断是否存在解 if (L &gt; R) { ans.push_back(-1); continue; } // 合并高位和低位构造回文数字 string s = to_string(L); string ns = s; reverse(ns.begin(), ns.end()); LL cur = 0LL; if (alen &amp; 1) cur = stoll(s + ns.substr(1)); else cur = stoll(s + ns); ans.push_back(cur); } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(1)$: 常数空间存储数字, 也可以认为是$log_{10}{max(queries)}$ Maximum Value of K Coins From Piles思路经典二维动态规划. 状态定义:$f[i][j]$表示考虑了前i个硬币桌子, 且总共拿了j个时取得的最大价值 状态转移: $f[i][j] = f[i - 1][j]$: 表示第i个桌子一个也不拿. $f[i][j] = max(f[i][j], f[i - 1][j - u] + sum), u\\in{[1, min(j, m)]}$: 表示第i个桌子上拿取前u个(其价值为sum), 且第i个桌子最多有m个. Code12345678910111213141516171819202122232425const int N = 1010, M = 2010;int f[N][M];class Solution {public: int maxValueOfCoins(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int k) { memset(f, 0, sizeof(f)); int n = nums.size(); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= k; j ++ ) { f[i][j] = f[i - 1][j]; int m = nums[i - 1].size(); for (int u = 1, sum = 0; u &lt;= min(j, m); u ++ ) { sum += nums[i - 1][u - 1]; f[i][j] = max(f[i][j], f[i - 1][j - u] + sum); } } return f[n][k]; }}; 复杂度分析 时间复杂度$O(N * K)$ 空间复杂度$O(N * K)$ 欢迎讨论指正","link":"/2022/03/27/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D286/"},{"title":"并行数组求和","text":"使用cpp的thread、promise、future、packaged_task、async等并发处理机制实现数组求和. 并发编程实现思路将数组进行平均划分, 每个线程处理一个子数组段, 然后主线程收集子线程的结果, 实现并行数组加法. Thread我们将任务划分后, 对于线程求和函数传入存储子数组和的引用, 这样主线程直接能够拿到该子数组和. 子线程求和函数1234void multiAdd(vector&lt;int&gt;&amp; nums, int l, int r, LL&amp; sum) { for (int i = l; i &lt;= r; i ++ ) sum += nums[i];} 主线程分配任务和汇集总和1234567891011121314151617181920212223LL multiThread(vector&lt;int&gt;&amp; nums) { vector&lt;thread&gt; threads(M); vector&lt;LL&gt; sum(M, 0LL); int n = nums.size(), step = n / M + 1; for (int i = 0; i &lt; M; i ++ ) { // 划分任务段 int l = (i == 0) ? 0 : i * step; int r = min(n - 1, (i + 1) * step - 1); // 使用 ref进行包装, 无法直接传递 threads[i] = thread(multiAdd, ref(nums), l, r, ref(sum[i])); } // join子线程 for (auto&amp; t : threads) t.join(); // 主线程统计总和 LL ans = 0; for (auto&amp; c : sum) ans += c; return ans;} Promise和FuturePromise可以存储一个值, 这个值可以在将来被异步的获取. 获取方式是通过promise.get_future()获取与该Promise共享状态的Future对象, 然后使用future.get()异步的阻塞等待获取其值. 子线程求和函数123456void promiseAdd(vector&lt;int&gt;&amp; nums, int l, int r, promise&lt;LL&gt;&amp; promise) { LL cnt = 0LL; for (int i = l; i &lt;= r; i ++ ) cnt += nums[i]; promise.set_value(cnt);} 主线程分配任务和汇集总和1234567891011121314151617181920212223242526LL promiseThread(vector&lt;int&gt;&amp; nums) { vector&lt;thread&gt; threads(M); vector&lt;future&lt;LL&gt;&gt; sum(M); vector&lt;promise&lt;LL&gt;&gt; prom(M); int n = nums.size(), step = n / M + 1; for (int i = 0; i &lt; M; i ++ ) { int l = (i == 0) ? 0 : i * step; int r = min(n - 1, (i + 1) * step - 1); // 绑定future和promise sum[i] = prom[i].get_future(); threads[i] = thread(promiseAdd, ref(nums), l, r, ref(prom[i])); } LL ans = 0; // 异步获取future值 for (auto&amp; f : sum) ans += f.get(); for (auto&amp; t : threads) t.join(); return ans;} Packaged_taskpackaged_task封装一个函数, 如同function&lt;&gt;模板类一样. 不过packaged_task可以异步的获取封装函数的返回值, 该返回值存储在future对象中. 子线程求和函数1234567LL packageTaskAdd(vector&lt;int&gt;&amp; nums, int l, int r) { LL sum = 0LL; for (int i = l; i &lt;= r; i ++ ) sum += nums[i]; // 直接返回 return sum;} 主线程分配任务和汇集总和12345678910111213141516171819202122LL packageTaskThread(vector&lt;int&gt;&amp; nums) { using task = packaged_task&lt;LL(vector&lt;int&gt;&amp;, int, int)&gt;; vector&lt;future&lt;LL&gt;&gt; sum(M); int n = nums.size(), step = n / M + 1; for (int i = 0; i &lt; M; i ++ ) { int l = (i == 0) ? 0 : i * step; int r = min(n - 1, (i + 1) * step - 1); // 封装任务 task curTask(packageTaskAdd); // 执行任务 curTask(ref(nums), l, r); // 绑定到future对象上 sum[i] = curTask.get_future(); } LL ans = 0; for (auto&amp; f : sum) ans += f.get(); return ans;} Asyncasync可以同步也可以异步的执行一个任务. 异步执行的话使用多线程进行计算. 任务的返回值存储于future对象中, 可以使用future.get()获取异步获取其值. 子线程求和函数123456LL asyncAdd(vector&lt;int&gt;&amp; nums, int l, int r) { LL sum = 0; for (int i = l; i &lt;= r; i ++ ) sum += nums[i]; return sum;} 主线程分配任务和汇集总和1234567891011121314151617LL asyncThread(vector&lt;int&gt;&amp; nums) { vector&lt;future&lt;LL&gt;&gt; sum(M); int n = nums.size(), step = n / M + 1; for (int i = 0; i &lt; M; i ++ ) { int l = (i == 0) ? 0 : i * step; int r = min(n - 1, (i + 1) * step - 1); // launch::async 开始线程异步执行 sum[i] = async(launch::async, asyncAdd, ref(nums), l, r); } LL ans = 0; for (auto&amp; f : sum) ans += f.get(); return ans;} 代码和结果Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;chrono&gt;#include &lt;future&gt;#include &lt;assert.h&gt;using namespace std;using LL = long long;const int N = 1e8;const int M = 16;LL nativeAdd(vector&lt;int&gt;&amp; nums) { LL ans = 0; for (auto&amp; c : nums) ans += c; return ans;}void multiAdd(vector&lt;int&gt;&amp; nums, int l, int r, LL&amp; sum) { for (int i = l; i &lt;= r; i ++ ) sum += nums[i];}LL multiThread(vector&lt;int&gt;&amp; nums) { vector&lt;thread&gt; threads(M); vector&lt;LL&gt; sum(M, 0LL); int n = nums.size(), step = n / M + 1; for (int i = 0; i &lt; M; i ++ ) { int l = (i == 0) ? 0 : i * step; int r = min(n - 1, (i + 1) * step - 1); threads[i] = thread(multiAdd, ref(nums), l, r, ref(sum[i])); } for (auto&amp; t : threads) t.join(); LL ans = 0; for (auto&amp; c : sum) ans += c; return ans;}void promiseAdd(vector&lt;int&gt;&amp; nums, int l, int r, promise&lt;LL&gt;&amp; promise) { LL cnt = 0LL; for (int i = l; i &lt;= r; i ++ ) cnt += nums[i]; promise.set_value(cnt);}LL promiseThread(vector&lt;int&gt;&amp; nums) { vector&lt;thread&gt; threads(M); vector&lt;future&lt;LL&gt;&gt; sum(M); vector&lt;promise&lt;LL&gt;&gt; prom(M); int n = nums.size(), step = n / M + 1; for (int i = 0; i &lt; M; i ++ ) { int l = (i == 0) ? 0 : i * step; int r = min(n - 1, (i + 1) * step - 1); // 绑定future和promise sum[i] = prom[i].get_future(); threads[i] = thread(promiseAdd, ref(nums), l, r, ref(prom[i])); } LL ans = 0; // 异步获取future值 for (auto&amp; f : sum) ans += f.get(); for (auto&amp; t : threads) t.join(); return ans;}LL packageTaskAdd(vector&lt;int&gt;&amp; nums, int l, int r) { LL sum = 0LL; for (int i = l; i &lt;= r; i ++ ) sum += nums[i]; return sum;}LL packageTaskThread(vector&lt;int&gt;&amp; nums) { using task = packaged_task&lt;LL(vector&lt;int&gt;&amp;, int, int)&gt;; vector&lt;future&lt;LL&gt;&gt; sum(M); int n = nums.size(), step = n / M + 1; for (int i = 0; i &lt; M; i ++ ) { int l = (i == 0) ? 0 : i * step; int r = min(n - 1, (i + 1) * step - 1); // 封装任务 task curTask(packageTaskAdd); // 执行任务 curTask(ref(nums), l, r); // 绑定到future对象上 sum[i] = curTask.get_future(); } LL ans = 0; for (auto&amp; f : sum) ans += f.get(); return ans;}LL asyncAdd(vector&lt;int&gt;&amp; nums, int l, int r) { LL sum = 0; for (int i = l; i &lt;= r; i ++ ) sum += nums[i]; return sum;}LL asyncThread(vector&lt;int&gt;&amp; nums) { vector&lt;future&lt;LL&gt;&gt; sum(M); int n = nums.size(), step = n / M + 1; for (int i = 0; i &lt; M; i ++ ) { int l = (i == 0) ? 0 : i * step; int r = min(n - 1, (i + 1) * step - 1); sum[i] = async(launch::async, asyncAdd, ref(nums), l, r); } LL ans = 0; for (auto&amp; f : sum) ans += f.get(); return ans;}void naive(vector&lt;int&gt;&amp; nums) { auto start_time = chrono::system_clock::now(); LL ans1 = nativeAdd(nums); auto end_time = chrono::system_clock::now(); chrono::milliseconds time1 = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time); cout &lt;&lt; &quot;nativeAdd cost time = &quot; &lt;&lt; time1.count() &lt;&lt; &quot; ms, total sum = &quot; &lt;&lt; ans1 &lt;&lt; '\\n';}void threads(vector&lt;int&gt;&amp; nums) { auto start_time = chrono::system_clock::now(); LL ans2 = multiThread(nums); auto end_time = chrono::system_clock::now(); chrono::milliseconds time2 = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time); cout &lt;&lt; &quot;multiThread cost time = &quot; &lt;&lt; time2.count() &lt;&lt; &quot; ms, total sum = &quot; &lt;&lt; ans2 &lt;&lt; '\\n';}void promisefuture(vector&lt;int&gt;&amp; nums) { auto start_time = chrono::system_clock::now(); LL ans2 = promiseThread(nums); auto end_time = chrono::system_clock::now(); chrono::milliseconds time2 = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time); cout &lt;&lt; &quot;promiseThread cost time = &quot; &lt;&lt; time2.count() &lt;&lt; &quot; ms, total sum = &quot; &lt;&lt; ans2 &lt;&lt; '\\n';}void packagedtask(vector&lt;int&gt;&amp; nums) { auto start_time = chrono::system_clock::now(); LL ans2 = packageTaskThread(nums); auto end_time = chrono::system_clock::now(); chrono::milliseconds time2 = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time); cout &lt;&lt; &quot;packageTaskThread cost time = &quot; &lt;&lt; time2.count() &lt;&lt; &quot; ms, total sum = &quot; &lt;&lt; ans2 &lt;&lt; '\\n'; }void async(vector&lt;int&gt;&amp; nums) { auto start_time = chrono::system_clock::now(); LL ans2 = asyncThread(nums); auto end_time = chrono::system_clock::now(); chrono::milliseconds time2 = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time); cout &lt;&lt; &quot;asyncThread cost time = &quot; &lt;&lt; time2.count() &lt;&lt; &quot; ms, total sum = &quot; &lt;&lt; ans2 &lt;&lt; '\\n'; }int main() { vector&lt;int&gt; nums; srand((unsigned int)time(NULL)); for (int i = 1; i &lt; N; i ++ ) nums.push_back(rand() % N); naive(nums); threads(nums); promisefuture(nums); packagedtask(nums); async(nums); return 0;} Result12345nativeAdd cost time = 615 ms, total sum = 1638266934225multiThread cost time = 372 ms, total sum = 1638266934225promiseThread cost time = 34 ms, total sum = 1638266934225packageTaskThread cost time = 208 ms, total sum = 1638266934225asyncThread cost time = 39 ms, total sum = 1638266934225","link":"/2022/03/24/ConcurrencyAndDistribution/%E5%B9%B6%E8%A1%8C%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C/"},{"title":"残酷八股文群学习汇总-2月","text":"残酷八股文项目地址 什么是五级流水线，数据冒险是什么指令指令的定义 计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程百度百科。 指令的结构指令包含了操作码和操作数. 操作码决定该条指令的作用（运算类(add、mul、sub)、控制跳转(JA、JE)、取值(lea)）; 操作数指定了参与指令操作的具体数据, 操作数可以是立即数(如add eax, 10, 其中10为立即数), 可以来自寄存器(如mov eax, esp), 也可以来自内存(如mov eax, 某内存地址(逻辑地址)). 根据操作数的多少, 指令可以分为无操作数指令(ret)、一操作数指令JE, INC、二操作指令(mov)和三操作数指令(add)等等。 五级流水线 cpu流水线技术是一种将指令分解为多步，并让不同指令的各步操作重叠，从而实现几条指令并行处理，以加速程序运行过程的技术百度百科。 MIPS五级流水线分为五个模块: 取址 -&gt; 译码 -&gt; 执行 -&gt; 访存 -&gt; 写回 取址: 控制单元根据PC中存放的指令地址, 从存储器中取出下一条即将执行的指令放入指令寄存器. 译码: 根据指令编码的规则去对指令进行译码. 即翻译指令, 看看指令具体是什么操作, 需要几个操作数, 操作数是立即数还是在寄存器或内存里, 并给出操作数的地址以及结果的保存地址等. 执行: 有了操作码和操作数, 就根据操作码对操作数进行操作, 即执行指令. 访存: 访存是load \\ store, 即读内存或写内存. 内存操作数需要读内存, 有些结果的保存需要写入内存. (读写内存远远慢于读写寄存器, 可以利用cache加速, 但可能还会遇到缺页中断的问题). 写回: 将指令执行的结果写入寄存器中或内存中. 数据冒险流水线技术通过并行处理来加速程序的执行过程, 但有些情况下这种并行会导致使用数据存在冒险: 当前指令需要需要使用之前指令的运算结果, 但是其结果没有写回. 如图, add指令需要t0作为操作数参与运算, 但其被上一条指令sub操作, 而且其结果还未写回. 此时存在数据冒险. 解决方法 插入nop指令. (软件解决方法, 不足在下面参考博客中) 流水线停顿, 增加气泡. 数据前递.t0在EX阶段(执行)就被计算出，所以可将它送到下一条指令ALU的输入，而不需要添加气泡。参考 数据冒险讲解博客 Python: 什么是鸭子类型定义 鸭子类型（duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。 含义鸭子类型关注对象的方法和属性而不是对象自身的类型. 如下getLen函数可以接受任意类型的参数, 它关注的是该参数是否支持len方法. 如重写了__getitem__的Nums类支持切片操作. 其只有在运行时才能确定参数的正确与否, 如果错误将会引起运行时错误. 1234567891011121314151617181920212223242526272829303132333435363738394041class Nums(): def __init__(self, length): self.nums = [_ for _ in range(length)] def __len__(self): return len(self.nums) def __getitem__(self, idx): return self.nums[idx]def getLen(a): return len(a)def printNum(a): for x in a: print(x, end=',') print()nums = [_ for _ in range(5)]obj = Nums(5)print(f&quot;length of nums = {getLen(nums)}\\t length of obj = {getLen(obj)}&quot;)print(&quot;print nums:&quot;)printNum(nums[:-1])print(&quot;print obj:&quot;)printNum(obj[:-1])# 输出# length of nums = 5 length of obj = 5# print nums:# 0,1,2,3,# print obj:# 0,1,2,3, 优缺点 优点: 主要是动态语言的特性, 其无需关注具体的类型, 极大放松了编程的限制. 缺点: debug和维护的成本高昂, 需依赖清晰的文档和规范才能在多人协作的情况下提高开发效率. cpp: volatile 和 atomic 的区别volatilevolatile是cpp中的关键字, 其可以修饰变量用作类型修饰. 如volatile int a = 5; 易变性: volatile修饰的变量编译器不会保存到寄存器中, 而是每一次都从内存中读取.避免在多线程编程中的一些问题. 不可优化性: 限制编译器对于变量的优化. 顺序性: 能够保证volatile变量间的顺序性, 编译器不会进行乱序优化. atomicatomic是cpp11提供了模板类, 可以用其定义一个原子类型: atomic&lt;int&gt; a;, 且重载了++, –, += , |= 等运算符. 并且可以通过load和store原子性的读取和修改其值. 区别 volatile是cpp关键字, 用作类型修饰符, 是编译器级别的语义. atomic是cpp的STL提供的模板类, 是库级别的. volatile保证了顺序关系, 主要语义是防止编译器缓存, 但无法保证原子性. atomic是为了原子性而产生的, 其内置的成员函数load和store以及重载的运算符等防止了多线程编程下的数据竞争. 从内存里读一个byte计算机内部是怎么样实现的首先计算机需要知道该byte的虚拟地址. 这是通过寻址获取的. 通过寻址获得其逻辑页号和页内偏移, 然后查看TLB(快表)和页表该页是否已经load进物理内存. 如果快表或者页表中存在该虚拟页和物理页的映射. 则MMU进行地址译码, 获取其物理地址, 最后通过总线访问内存. 如果不存在映射则发生缺页中断, 陷入内核态系统找到对应的中断服务程序进行处理, 具体就是寻找一块物理空闲页然后将逻辑页读入, 并将映射存入快表和页表.(如果物理页满了会利用页面置换算法(LRU, FIFO, OPT)淘汰物理内存页), 完成后重新执行该条指令(因为中断后未完成). C++: 简述 virtual function虚函数可以分为纯虚函数和虚函数. 纯虚函数格式1virtual void func() = 0; 特性 含有纯虚函数的类称为抽象类, 这种类无法实例化. 且继承它的类如果没有实现纯虚函数的话其还是抽象类. 抽象类的语义类似于某些语言中”接口”的语义, 只有继承类全部实现了该抽象类定义的纯虚函数, 即可认为继承类”实现”了抽象类”接口”语义. 虚函数虚函数是cpp动态多态的关键. cpp的多态分为静态多态和动态多态. 静态多态是如函数的重载、泛型模板等, 其发生在编译期. 动态多态是动态类型配合虚函数导致的运行时多态. 格式1virtual void func(); 特性 含有虚函数的类会产生虚函数表, 其中每个表项都是函数指针, 指向具体的函数. 在构造对象时, 对象会保存虚函数表指针, 其指向虚函数表. 虚函数配合动态类型会产生多态的效果. 虚函数的绑定是推迟到运行时, 但虚函数的参数绑定是在编译期的, 目的是加快执行速度, 因此虚函数带有默认参数的情况应该避免或保证默认参数一致, 否则会出现不符合预期的结果. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;class Base {public: void say() { cout &lt;&lt; &quot;Base&quot; &lt;&lt; endl; } virtual void func(int i = 0) { cout &lt;&lt; &quot;This is Base Class. i = &quot; &lt;&lt; i &lt;&lt; endl; }};class Derived : public Base {public: virtual void func(int i = 1) { cout &lt;&lt; &quot;This is Derived Class. i = &quot; &lt;&lt; i &lt;&lt; endl; }};int main() { // p的静态类型是Base Base* p = nullptr; // 静态绑定, 且该函数不调用this, 因此可以正确执行 p -&gt; say(); // p的静态类型是Base, 动态类型是Base p = new Base; p -&gt; func(); // p的静态类型是Base, 动态类型是Derived p = new Derived; // 动态类型配合虚函数, 产生运行时动态多态的效果 p -&gt; func(); return 0;/* 输出BaseThis is Base Class. i = 0This is Derived Class. i = 0*/} a、b两台服务器怎么判断是否能连通, 为什么能用ping和traceroutepingping主要用于确定网络间的连通性以及网络间的连接状况. 其是基于ICMP协议工作的. ping命令会构建一个ICMP请求报文给目标主机, 并等待目标主机返回ICMP应答报文. 源主机工作流程 ping目标主机后ICMP协议构建ICMP请求报文 IP层协议得到ICMP报文以及目标主机IP地址后, 将本机地址作为源地址, 再加上其他的一些控制信息组成IP数据包. 根据本地ARP缓存查找目标IP地址对应的MAC地址(物理地址). 如果没找到就通过ARP协议找. 最后将目标主机的MAC地址和本机的MAC地址交给数据链路层, 构造数据帧. 通过物理层发送给目标主机 目标主机工作流程 物理层收到二进制数据流经过数据链路层, 根据以太网协议解析出数据帧, 判断数据帧中的目标MAC地址是否为本机, 是则接受, 否则抛弃. 经过网络层解析IP数据包, 通过IP包头的协议字段判断出是ICMP报文. 之后ICMP协议处理, 构建并发送一个ICMP应答报文. 将封装好的ICMP应答报文经过网络层、数据链路层、物理层发送回源主机. Traceroutetraceroute命令不仅可以检测网络间是否联通, 还可以知道从源主机到目标主机经过了哪些路由器. 其可以通过利用ICMP协议定位路径上经过的路由器. 并利用端口不可达错误来确定数据包是否到达目标主机. 工作流程 源主机向目标主机发送一系列的UDP报文. 第一个报文的生存时间TTL = 1, 当其到达路径上第一个路由器时, 该路由器将TTL值减1, 并发现TTL = 0. 因此路由器将其丢弃, 并发送给源主机ICMP不可达的报文. 主机收到ICMP不可达报文后, 接着发送TTL = 2的报文, 这样确定路径上第2个路由器. 这样循环往复, 直到数据报到达目标主机, 由于traceroute发送的是端口号大于30000的UDP报文, 因此目标主机只能发送一个端口不可达的ICMP数据包(无法交付的UDP报文)给源主机. 通过这种方法源主机知道了到目标主机路径上的路由器的IP和目标主机是否联通等信息. traceroute是怎么traceback, 最终让发出traceroute的客户端得到信息的 源主机向目标主机发送一系列的UDP报文. 第一个报文的生存时间TTL = 1, 当其到达路径上第一个路由器时, 该路由器将TTL值减1, 并发现TTL = 0. 因此路由器将其丢弃, 并发送给源主机ICMP不可达的报文. 源主机收到ICMP不可达报文后, 接着发送TTL = 2的报文, 这样确定路径上第2个路由器. 这样循环往复, 直到数据报到达目标主机, 由于traceroute发送的是端口号大于30000的UDP报文, 因此目标主机只能发送一个端口不可达的ICMP数据包(无法交付的UDP报文)给源主机. 通过这种方法源主机知道了到目标主机路径上的路由器的IP和目标主机是否联通等信息. C++: 简述 vtable虚函数表是含有虚函数的类所拥有的. 它配合动态绑定技术, 可以实现运行期多态. 特点 每个含有虚函数的类均会有一份类共享的虚函数表. 每个对象含有虚函数表指针, 一般会在对象内存地址的开头. 这样的好处是通过父类指针调用子类对象的虚函数时, 能在子类对象的前sizeof(父类)区域中拿到子类的虚函数表指针, 正确的实现多态. 虚函数表是指针数组, 其表项为函数指针, 指向类所对应的虚函数. 虚函数表的产生是在编译器, 并且编译器会为有虚函数的对象添加虚函数指针. 动态绑定是在运行期. 其依赖于虚函数指针和虚函数表. hashmap和treemap的区别, 除了红黑树还可以怎么实现treemaphashmapcpp的unordered_set和unordered_map均为关联哈希容器. 支持查找、增加、修改、删除指针的key. 通过哈希方法实现. treemapcpp的set和map均为关联式有序容器. 支持默认比较(如set&lt;pair&lt;int, int&gt;&gt;)或自定义(重载operator &lt;)的方式来指定容器对元素的排序动作. 保证key唯一且有序. 一般通过红黑树实现, 红黑树是一种高度平衡查找二叉树. 区别 实现方式不同 支持的操作不尽相同. map和set容器自带支持lower_bound和upper_bound函数, 可以按key值大小遍历容器等. 常用操作时间复杂度 容器 添加 删除 修改 查找 hashmap $O(1)$ $O(1)$ $O(1)$ $O(1)$ treemap $O(logN)$ $O(logN)$ $O(logN)$ $O(logN)$ 实现还可以利用其他AVL树来实现treemap, 如普通AVL树、Treap.","link":"/2022/03/14/%E6%AE%8B%E9%85%B7%E5%85%AB%E8%82%A1%E6%96%87/%E6%AE%8B%E9%85%B7%E5%85%AB%E8%82%A1%E6%96%87%E7%BE%A4%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB-2%E6%9C%88/"},{"title":"[cpp]STL学习-move和forward","text":"move和forward是cpp11引入的两个模板函数, move配合移动语义对应的函数(移动构造, 移动赋值)可以减少不必要的拷贝, 而forward可以完美的保留参数的特性, 从而实现预期的行为. 引用从cpp11以来, 引用可以分为左值引用、右值引用和通用引用. 左值引用和右值引用分别可以绑定到左值和右值上, 从而在函数调用过程中减少不必要的拷贝. 通用引用用于泛型编程中, 其可以绑定到左值上, 也可以绑定到右值上. 引用折叠cpp规定不存在指向引用的引用. 在泛型编程中, 如果模板函数指定参数类型为T&amp;&amp; param, 而传入的参数可以是左值也可以是右值, 因此T&amp;&amp;作为通用引用就需要利用引用折叠规则进行参数类型的适配. 如果参数param为左值或左值引用, 那么T就被推导为T&amp;, 这样参数类型就变成了T&amp; &amp;&amp;param, 引用折叠规则规定这种情况下T为左值引用. 如果参数param为右值, 那么T就被推导为T, 这样参数类型就变成了T&amp;&amp; param. 如果参数param为命名右值引用, 那么T被推导为T&amp;, 因为命名右值引用为左值, T &amp;&amp;无法绑定到左值上去, 因此推导为T&amp;. 如果参数param为匿名右值引用, 那么T被推导为T, 因为匿名右值引用为右值. Code1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt;void testType(T&amp;&amp; param) { if(is_rvalue_reference&lt;decltype(param)&gt;::value) cout&lt;&lt;&quot;param is rvalue reference\\n&quot;; else cout&lt;&lt;&quot;param is lvalue reference\\n&quot;;}int main() { int val = 10; int&amp; L = val; int&amp;&amp; R = 123; // 左值 testType(val); // 左值引用 testType(L); // 命名右值引用 testType(R); // 匿名右值引用 testType(static_cast&lt;int&amp;&amp;&gt;(val)); // 右值 testType(10086); return 0;} Result12345param is lvalue referenceparam is lvalue referenceparam is lvalue referenceparam is rvalue referenceparam is rvalue reference movemove函数无条件的将传入参数转换为右值引用返回. 由于函数返回右值引用为匿名右值引用, 因此其可以配合移动构造函数和移动赋值函数实现移动语义. move源码1234567891011// GNU cpp-11.2.0/** * @brief Convert a value to an rvalue. * @param __t A thing of arbitrary type. * @return The parameter cast to an rvalue-reference to allow moving it.*/template&lt;typename _Tp&gt; _GLIBCXX_NODISCARD constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; move(_Tp&amp;&amp; __t) noexcept { return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); } move函数的源码很简单. 函数的参数类型为通用引用, 返回值类型为constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;, 其中std::remove_reference&lt;_Tp&gt;::type是偏特化模板, 类似于traits, 提取的是_Tp的去掉引用后的类型(如int&amp;为int, char&amp;&amp;为char). 函数的主体为一条类型转化的语句: static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t). 其意很明确: 将参数转换为对应类型的右值引用并返回. 使用样例move函数的过程很简单, 就是简单的类型转换. 其可以认为是一个小的语法糖, 主要配合移动构造函数和移动赋值函数实现移动语义. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Array {public: Array () : _size(0), _ptr(nullptr) {} Array (int len) { _size = len; _ptr = new int[_size]; } // copy-cotr Array (Array&amp; a) { _size = a._size; _ptr = new int[_size]; for (int i = 0; i &lt; _size; i ++ ) _ptr[i] = a._ptr[i]; cout &lt;&lt; &quot;called copy-cotr. &quot; &lt;&lt; endl; } // copy operator = Array&amp; operator = (Array&amp; a) { if (this == &amp;a) return *this; if (_ptr != nullptr) delete _ptr; // copy _size = a._size; _ptr = new int[_size]; for (int i = 0; i &lt; _size; i ++ ) _ptr[i] = a._ptr[i]; cout &lt;&lt; &quot;called copy operator = &quot; &lt;&lt; endl; return *this; } // move cotr Array (Array&amp;&amp; a) { _size = a._size; _ptr = a._ptr; a._size = 0; a._ptr = nullptr; cout &lt;&lt; &quot;called move cotr.&quot; &lt;&lt; endl; } // move operator = Array&amp; operator = (Array&amp;&amp; a) { if (this == &amp;a) return *this; if (_ptr != nullptr) delete _ptr; // move _size = a._size; _ptr = a._ptr; a._size = 0; a._ptr = nullptr; cout &lt;&lt; &quot;called move operator = &quot; &lt;&lt; endl; return *this; } // de-cotr. ~ Array () { delete _ptr; cout &lt;&lt; &quot;called de-cotr.&quot; &lt;&lt; endl; } void printInfo() { cout &lt;&lt; &quot;size of array is &quot; &lt;&lt; _size &lt;&lt; endl; }private: // size and pointer int _size; int* _ptr;};int main() { Array arr(10); Array dst; dst = move(arr); dst.printInfo(); arr.printInfo(); return 0;}/*called move operator = size of array is 10size of array is 0called de-cotr.called de-cotr.*/ 总结 move函数无法移动任何东西, 其只是无条件的返回参数的匿名右值引用. move需要配合移动构造函数和移动赋值函数才能正确实现移动语义. forward源码123456789101112131415161718192021222324252627/*** @brief Forward an lvalue.* @return The parameter cast to the specified type.** This function is used to implement &quot;perfect forwarding&quot;.*/template&lt;typename _Tp&gt;_GLIBCXX_NODISCARDconstexpr _Tp&amp;&amp;forward(typename std::remove_reference&lt;_Tp&gt;::type&amp; __t) noexcept{ return static_cast&lt;_Tp&amp;&amp;&gt;(__t); }/*** @brief Forward an rvalue.* @return The parameter cast to the specified type.** This function is used to implement &quot;perfect forwarding&quot;.*/template&lt;typename _Tp&gt;_GLIBCXX_NODISCARDconstexpr _Tp&amp;&amp;forward(typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) noexcept{ static_assert(!std::is_lvalue_reference&lt;_Tp&gt;::value, &quot;template argument&quot; &quot; substituting _Tp must not be an lvalue reference type&quot;); return static_cast&lt;_Tp&amp;&amp;&gt;(__t);} forward可以有区别转发左值和右值, 其主要特点是通过函数重载实现不同参数类型的分别处理. 如果__t是左值那么进入第一个版本, 如果__t是右值那么进入第二个版本. 通过源码可以发现, 只有_Tp为左值引用时, 参数__t才会被转发成_Tp的左值引用. 否则就是_Tp类型的右值引用. 那么为什么需要forward函数呢? 如果我们希望根据参数引用的类型实现不同的功能, 或者在函数调用中保留原始参数的引用特性, 就必须使用forward函数进行完美转发. 使用样例Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Array {public: Array () : _size(0), _ptr(nullptr) {} Array (int len) { _size = len; _ptr = new int[_size]; } // copy-cotr Array (Array&amp; a) { _size = a._size; _ptr = new int[_size]; for (int i = 0; i &lt; _size; i ++ ) _ptr[i] = a._ptr[i]; cout &lt;&lt; &quot;called copy-cotr. &quot; &lt;&lt; endl; } // copy operator = Array&amp; operator = (Array&amp; a) { if (this == &amp;a) return *this; if (_ptr != nullptr) delete _ptr; // copy _size = a._size; _ptr = new int[_size]; for (int i = 0; i &lt; _size; i ++ ) _ptr[i] = a._ptr[i]; cout &lt;&lt; &quot;called copy operator = &quot; &lt;&lt; endl; return *this; } // move cotr Array (Array&amp;&amp; a) { _size = a._size; _ptr = a._ptr; a._size = 0; a._ptr = nullptr; cout &lt;&lt; &quot;called move cotr.&quot; &lt;&lt; endl; } // move operator = Array&amp; operator = (Array&amp;&amp; a) { if (this == &amp;a) return *this; if (_ptr != nullptr) delete _ptr; // move _size = a._size; _ptr = a._ptr; a._size = 0; a._ptr = nullptr; cout &lt;&lt; &quot;called move operator = &quot; &lt;&lt; endl; return *this; } // de-cotr. ~ Array () { delete _ptr; cout &lt;&lt; &quot;called de-cotr.&quot; &lt;&lt; endl; } void printInfo() { cout &lt;&lt; &quot;size of array is &quot; &lt;&lt; _size &lt;&lt; endl; }private: // size and pointer int _size; int* _ptr;};template&lt;typename T&gt; T wrap(T&amp;&amp; src) { return forward&lt;T&amp;&amp;&gt;(src);}void funcB(Array&amp;&amp; src) { }template&lt;typename T&gt; void funcA(T&amp;&amp; src) { // Candidate function not viable: expects an rvalue for 1st argument, 转发失败 // funcB(src); // 转发成功 funcB(forward&lt;T&amp;&amp;&gt;(src));}int main() { Array arr(10); Array dst1 = wrap(arr); Array dst2 = wrap(move(arr)); dst1.printInfo(); dst2.printInfo(); funcA(move(dst2)); return 0;} Result1234567called copy-cotr. called move cotr.size of array is 10size of array is 10called de-cotr.called de-cotr.called de-cotr. 我们在main函数里调用完美转发包装的wrap函数. 通过传入参数的不同实现调用不同的构造函数. 在函数调用中, 由于命名右值引用是左值, 因此其无法进行期望的函数调用, 需要使用forward转发 forward完美转发会保留参数的const和引用特性, 降低出错的可能. 总结由于命名右值引用是左值, 因此在函数中继续转发该参数会发生不符合预期的结果出现(调用左值引用版本的代码、编译出错等等), 而forward可以完美转发参数的const特性和引用特性, 从而保证执行符合我们的预期, 降低出错的可能性.","link":"/2022/03/22/cpp/%5Bcpp%5DSTL%E5%AD%A6%E4%B9%A0-move%E5%92%8Cforward/"},{"title":"第一届ACC(AcWing Cup)全国高校联赛(决赛)题解","text":"Rank : 57/758Solved : 3/3 竞赛链接 两个闹钟思路暴力. 应该是用扩展欧几里得, 但上来写了发暴力, 然后就过了… Code123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; int find = 0, res = INT_MAX; for (int i = 0; i &lt;= 100; i ++ ) for (int j = 0; j &lt;= 100; j ++ ) { if ((b + i * a) == (d + j * c)) { find = 1; res = min(res, b + i * a); } } if (find) cout &lt;&lt; res &lt;&lt; '\\n'; else cout &lt;&lt; -1 &lt;&lt; '\\n'; return 0;} 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(1)$ 合并石子思路贪心. 双指针扫描 如果当前两段相同, 则答案 + 1, 重新开始统计. 如果当前a段 &lt; b段, 则加上a段的数. 如果当前a段 &gt; b段, 则加上b段的数. 最后需要处理一下边界, 就如同归并排序一样. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int a[N], b[N];int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; for (int j = 1; j &lt;= m; j ++ ) cin &gt;&gt; b[j]; int i = 2, j = 2, step = 0; int sa = a[1], sb = b[1]; while (i &lt;= n and j &lt;= m) { if (sa == sb) { step ++ ; sa = 0, sb = 0; if (i &lt;= n) { sa += a[i]; i ++ ; } if (j &lt;= m) { sb += b[j]; j ++ ; } } else if (sa &lt; sb) { if (i &lt;= n) { sa += a[i]; i ++ ; } } else if (sa &gt; sb) { if (j &lt;= m) { sb += b[j]; j ++ ; } } } while (i &lt;= n) sa += a[i ++ ]; while (j &lt;= m) sb += b[j ++ ]; if (sa != sb) step = 0; else if (sa) step ++ ; cout &lt;&lt; step &lt;&lt; '\\n'; return 0;} 复杂度分析 时间复杂度$O(N + M)$ 空间复杂度$O(N + M)$ 翻转树边思路换根动态规划. 我们首先计算以u为根时, u可以遍历其所有子节点所需的代价. 这样我们可以求出某个点的正确答案. 假设是1号结点. 然后我们换根dp, 我们从父节点u推算子结点v的正确答案. 如果u -&gt; v的代价是0, 那么当以v为根时, 我们只需要将u -&gt; v翻转即可. 所以 $f[v] = f[u] + 1$. 如果u -&gt; v的代价是1, 那么当以v为根时, 这条边是无需代价的, 所以 $f[v] = f[u] - 1$. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;using PII = pair&lt;int, int&gt;;const int N = 2e5 + 5;vector&lt;PII&gt; g[N];int f[N];int dfs(int u, int fa) { int&amp; ret = f[u]; for (auto&amp; [v, w] : g[u]) { if (v == fa) continue; ret += dfs(v, u) + w; } return ret;}void dp(int u, int fa) { for (auto&amp; [v, w] : g[u]) { if (v == fa) continue; if (w == 0) f[v] = f[u] + 1; else f[v] = f[u] - 1; dp(v, u); }}int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt; n; i ++ ) { int a, b; cin &gt;&gt; a &gt;&gt; b; g[a].push_back({b, 0}); g[b].push_back({a, 1}); } dfs(1, -1); dp(1, -1); int mn = INT_MAX; for (int i = 1; i &lt;= n; i ++ ) mn = min(mn, f[i]); cout &lt;&lt; mn &lt;&lt; '\\n'; for (int i = 1; i &lt;= n; i ++ ) if (mn == f[i]) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\\n'; return 0;} 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2022/03/27/algo/AcWing/%E7%AC%AC%E4%B8%80%E5%B1%8AACC-AcWing-Cup-%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E8%81%94%E8%B5%9B-%E5%86%B3%E8%B5%9B-%E9%A2%98%E8%A7%A3/"},{"title":"[LeetCode-周赛]291","text":"Rank : 362/19115Solved : 4/4 竞赛链接 Remove Digit From Number to Maximize Result思路枚举. 注意到数据范围很小, 因此直接枚举删除的位置, 然后保存值最大的答案. Code1234567891011121314151617class Solution {public: string removeDigit(string s, char digit) { string ans; int n = s.size(); for (int i = 0; i &lt; n; i ++ ) { char cur = s[i]; if (s[i] == digit) { auto str = s.substr(0, i) + s.substr(i + 1); if (ans == &quot;&quot; or str &gt; ans) ans = str; } } return ans; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(N)$ Minimum Consecutive Cards to Pick Up思路贪心. 枚举每一个匹配对的右端点, 寻找该右端点最佳的左端点, 即求从当前位置向左看, 最靠近当前位置的左端点, 这可以使用哈希表来完成. Code1234567891011121314151617181920class Solution {public: int minimumCardPickup(vector&lt;int&gt;&amp; nums) { int n = nums.size(); unordered_map&lt;int, int&gt; f; int ans = n + 1; for (int i = 0; i &lt; n; i ++ ) { int cur = nums[i]; if (f.count(cur)) ans = min(ans, i - f[cur] + 1); // 更新哈希表 f[cur] = i; } if (ans == n + 1) ans = -1; return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ K Divisible Elements Subarrays思路枚举. 枚举合法子串(暴力或者双指针均可), 然后去重, 计算不重复的答案. 由于不同长度的子串不用相互比较, 因此可以使用N个set来去重, 即先按长度分组, 然后组内使用set去重. Code 暴力枚举合法子串: 1234567891011121314151617181920212223242526const int N = 210;class Solution {public: set&lt;vector&lt;int&gt;&gt; st[N]; int countDistinct(vector&lt;int&gt;&amp; nums, int k, int p) { int n = nums.size(); for (int i = 0; i &lt; n; i ++ ) for (int j = i, cnt = 0; j &lt; n; j ++ ) { if (nums[j] % p == 0) ++ cnt; if (cnt == k + 1) break; vector&lt;int&gt; cur(nums.begin() + i, nums.begin() + j + 1); int m = cur.size(); st[m].insert(cur); } int ans = 0; for (int i = 0; i &lt; N; i ++ ) ans += st[i].size(); return ans; }}; 双指针枚举合法子串: 123456789101112131415161718192021222324252627const int N = 210;class Solution {public: set&lt;vector&lt;int&gt;&gt; st[N]; int countDistinct(vector&lt;int&gt;&amp; nums, int k, int p) { int n = nums.size(); for (int i = 0, j = 0, cnt = 0; i &lt; n; i ++ ) { if (nums[i] % p == 0) ++ cnt; while (cnt &gt; k) { if (nums[j] % p == 0) -- cnt; ++ j; } for (int k = j; k &lt;= i; k ++ ) { vector&lt;int&gt; cur(nums.begin() + k, nums.begin() + i + 1); int m = cur.size(); st[m].insert(cur); } } int ans = 0; for (int i = 0; i &lt; N; i ++ ) ans += st[i].size(); return ans; }}; 复杂度分析 时间复杂度$O(N^3*logN)$, 按长度来分, 每一组长度下子串的个数为$O(N)$, 插入set的时间复杂度为$O(N * logN)$. 空间复杂度$O(N^2)$ Total Appeal of A String思路枚举. 枚举每一个字符对于整体答案的贡献. 先预处理出i位置左边第一个j字符的位置. 记为L[i][j]. 那么i位置处字符s[i]对于整体答案的贡献为: 贡献 = $(i - 0) * (n + 1 - i)$, 如果$L[i - 1][s[i]]$不存在 贡献 = $(i - L[i - 1][s[i]]) * (n + 1 - i)$, 如果$L[i - 1][s[i]]$存在 即以左闭右开的方式处理其贡献. 这样是为了防止重复计算, 如果采用左闭右闭, 那么会少计算答案; 如果采用左开右开, 那么会多计算答案. Code1234567891011121314151617181920212223242526272829using LL = long long;const int N = 1e5 + 5, M = 26;class Solution {public: int L[N][M]; long long appealSum(string s) { int n = s.size(); memset(L, -1, sizeof(L)); for (int i = 1; i &lt;= n; i ++ ) { int cur = s[i - 1] - 'a'; for (int j = 0; j &lt; M; j ++ ) L[i][j] = L[i - 1][j]; L[i][cur] = i; } LL ans = 0LL; for (int i = 1; i &lt;= n; i ++ ) { int cur = s[i - 1] - 'a'; int left = L[i - 1][cur], right = n + 1; if (left == -1) left = 0; ans += 1ll * (i - left) * (right - i); } return ans; }}; 复杂度分析 时间复杂度$O(N * |S|)$, $|S|$是字符集大小. 空间复杂度$O(N * |S|)$ 欢迎讨论指正","link":"/2022/05/01/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D291/"},{"title":"线程池的原理和实现","text":"使用cpp实现一个接口友好, 并发安全的线程池. 线程池的作用当我们需要频繁创建线程用于计算密集型任务时, 创建和释放需要频繁调用内核API进行线程的创建、切换和资源回收等, 会造成服务的处理性能下降. 线程池就是预先向操作系统申请一些工作线程, 等待用户将(计算)任务放入线程池交由线程池中的线程运行, 提升服务处理高并发任务的能力. 线程池的原理当有任务放入线程池时, 线程池会唤醒工作线程, 工作线程会拿走任务进行计算. 而当线程池工作队列满时, 放入任务会阻塞直到工作队列非满. 由以上逻辑分析可见, 线程池就是典型的生产者-消费者问题. 通常一个线程池应该有以下参数: 工作线程个数 工作队列大小 主线程 其中, 消费者就是工作线程, 而生产者是用户线程. 逻辑实现生产者-消费者问题中, 缓冲区就是临界资源. 而生产者和消费者需要互斥访问临界资源, 这通过互斥锁mutex实现. 而线程的唤醒(如生产者放入缓冲区唤醒消费者)可以通过条件变量或者信号量(cpp20中semaphore库)来实现. 线程池中消费者(工作线程)和工作队列是线程池应该管理的内容. 任务的添加取决于用户, 线程池需要提供添加任务和结束线程池的接口给用户. 同时由于结束线程池的时候工作队列可能还有计算任务, 因此需要等待所有计算任务运行完毕后才能结束线程池, 释放线程资源. 代码实现线程池内部参数1234567891011121314151617// 线程池工作线程std::vector&lt;std::thread&gt; workers_;// 任务队列std::deque&lt;Task&gt; tasks_;// 工作池最大个数size_t maxQueueSize_;// 线程池工作线程个数size_t numOfThreads_;// 线程池工作状态bool running_;// 互斥锁和条件变量实现消费者和生产者的唤醒, 以及线程工作状态的切换(结束线程池)std::mutex mtx_;std::condition_variable notFull_, notEmpty_; 线程池构造函数注意线程池不可拷贝赋值以及不可拷贝构造, 而且需要显示构造. 12explicit ThreadPool(size_t numOfThreads = 0, size_t maxQueueSize = 20): numOfThreads_(numOfThreads), maxQueueSize_(maxQueueSize), running_(false) {} 开启线程池1234567// 开启线程池void ThreadPool::start () { running_ = true; // thread的创建推迟到 start()函数被调用 for (int i = 0; i &lt; numOfThreads_; i ++ ) workers_.emplace_back(std::thread(&amp;ThreadPool::consumeTask, this));} 添加任务接口为了提供用户友好的接口, 我使用了模板函数和可变参数模板来实现添加任务的接口(参考cpp标准库的实现). 123456789// 外部添加任务的接口函数template&lt;typename _Callable, typename... _Args&gt;void addTask(_Callable&amp;&amp; __f, _Args&amp;&amp;... __args) { // 使用 bind(function adapter) 封装好后添加到线程池中 Task task = std::bind(std::forward&lt;_Callable&gt;(__f),std::forward&lt;_Args...&gt;(__args...)); // 线程池内部实现函数 addToWorkingPool(task);} 其中线程池内部将任务定义为: 1using Task = std::function&lt;void()&gt;; 添加任务函数的实现123456789101112131415161718192021222324252627// 生产者, 向线程池添加任务void ThreadPool::addToWorkingPool(Task task) { if (!running_) throw std::runtime_error (&quot;ThreadPool must running when adding tasks.&quot;); // 如果线程池工作队列为空, 则主线程(管理线程)执行 if (numOfThreads_ == 0) { task(); return ; } std::unique_lock&lt;std::mutex&gt; lock(mtx_); // 保证最后一个任务能够被添加入任务队列. // 当工作队列为满时, 等待. while的作用时防止条件变量虚假唤醒 // 如果线程池满且正在运行, 那就阻塞等待 notFull 条件变量 while (isFull() and running_) notFull_.wait(lock); // 如果线程池不在运行, 结束 if (!running_) return ; // 添加到工作队列中 tasks_.emplace_back(move(task)); // 唤醒工作线程 notEmpty_.notify_one();} 添加任务到线程池时, 如果线程池正在运行且工作队列已满, 则该生产者阻塞等待线程池非满notFull条件变量. 同时为了防止虚假唤醒, 使用while进行该条件的判断. 虚假唤醒: 比如工作队列为空且生产者添加了一个任务并唤醒了当前工作线程, 而这个任务被另一个没有阻塞的线程执行了, 那么当当前线程拿到互斥锁之后, 如果不判断就直接取任务, 会存在任务队列为空的可能(消费者的解释,生产者同理, 即可能被其他生产者放入任务队列了, 此时再放就会逻辑出错.) 当线程池在运行时, 添加任务到工作队列即可. 工作线程1234567891011121314151617181920212223// 工作线程(消费者)void ThreadPool::consumeTask() { while (true) { Task task; { std::unique_lock&lt;std::mutex&gt; lock(mtx_); // 当任务队列为空且线程池正在运行, 需要等待生产者添加任务 while (tasks_.empty() and running_) notEmpty_.wait(lock); // 如果线程池停止且任务队列为空, 即结束该工作线程 if (!running_ and tasks_.empty()) return ; assert(tasks_.size()); task = tasks_.front(); tasks_.pop_front(); notFull_.notify_one(); } // 执行任务 task(); }} 工作进程是消费者, 需要不断从工作队列中互斥获取任务并执行. 当线程池在运行且工作队列为空时, 工作线程需要阻塞等待工作队列非空的条件变量(notEmpty). 注意使用while判断从而避免虚假唤醒的问题. 当线程池停止运行且工作队列为空时, 此时计算任务全被执行完毕且不会有新的任务添加入线程池, 因此结束工作线程. 而如果线程池停止运行且工作队列不为空时, 此时任然需要执行计算任务. 计算任务的执行在unique_lock的作用域之外(使用RAII机制的资源管理类, 其离开作用域时析构函数会释放持有的锁资源), 否则会严重影响锁的释放和获取, 导致性能严重下降. 结束线程池123456789101112131415161718// 结束线程池void ThreadPool::stop() { if (!running_) throw std::runtime_error (&quot;ThreadPool must running when stop it.&quot;); { std::unique_lock&lt;std::mutex&gt; lock(mtx_); running_ = false; // 唤醒所有阻塞在 notEmpty 条件变量上的工作线程 notEmpty_.notify_all(); // 唤醒所有阻塞在 notFull 条件变量上的生产者线程 notFull_.notify_all(); } // 回收所有工作(消费者)线程 for (auto&amp; t : workers_) t.join();} 结束线程池时全部唤醒阻塞在notFull上的生产者和notEmpty上的消费者线程. 然后回收线程资源. 析构线程池12345// 析构函数~ThreadPool() { if (running_) stop();} 如果还在运行, 调用stop函数结束线程池即可. 性能评估比较单线程计算和多生产者线程池模型: 12345 oneThreadRun cost time = 79572 ms ThreadPool cost time = 10155 msProcess finished with exit code 0 遇到的问题和解决方式 性能低的问题 将计算任务Task的执行放在释放锁之后. 编写多生产者模型时的BUG 最初使用匿名函数实现多生产者模式是这样写的: 123456789101112// 多生产者模式for (int i = 0; i &lt; producers; i ++ ) { produceThread[i] = thread([&amp;] () -&gt; void { // 多生产者, 添加到任务队列中 for (int j = 0; j &lt; M; j ++ ) { futu[i][j] = prom[i][j].get_future(); threadPool.addTask(func, ref(prom[i][j])); } // 生产者完成数 + 1 finish.fetch_add(1); });} 写完死活调试都会出现BUG(段错误), 在windows平台和linux平台(WSL2)均会出现问题. 最后重写多生产者模式(和单生产者类似)才解决这个问题. 问题就是使用thread并传入匿名函数时, 不能通过引用去捕获参数, 而应该通过std::ref包装传递. 浪费了我大半天… 123456789101112// 多生产者模式for (int i = 0; i &lt; producers; i ++ ) { produceThread[i] = thread([] (ThreadPool&amp; threadPool, int i) -&gt; void { // 多生产者, 添加到任务队列中 for (int j = 0; j &lt; M; j ++ ) { futu[i][j] = prom[i][j].get_future(); threadPool.addTask(func, ref(prom[i][j])); } // 生产者完成数 + 1 finish.fetch_add(1); }, ref(threadPool), i);} 多生产者的设计问题 多生产者应该由用户决定和资源回收. 代码GitHubCode","link":"/2022/04/07/ConcurrencyAndDistribution/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"},{"title":"[cpp]StringView学习","text":"string_view是cpp17之后提供了一个模板类. 它维护一个对于底层字符数组的只读视图, 可以在多种场景下提高程序的性能. StringView的优势传递字符串参数的时候, 在不进行修改操作的时候通常都会使用const string&amp;来接收实参, 其在接收字符串字面值、字符数组和字符串指针的时候还是会存在构造字符串的问题. 即先生成一个匿名string对象, 然后const string&amp;绑定到该匿名对象上去. 当字符串很大时, 会存在严重的性能问题. substr函数. string的substr函数会返回一个string对象. 该操作造成的拷贝会影响程序的性能(在只读要求下). 针对以上问题: string_view能够较好的解决. 因为其是一个只读视图, 用string_view作为参数拷贝的开销是很低的, 以及string_view的substr函数返回的还是一个string_view. 避免了重新生成一个新的字符串的大开销操作. string_view在cpp17以前的一些第三方库中有自己的实现: leveldb的Slice实现. google基础库Abseil的StringView实现. StringView的实现字面值可以使用string_view sv = &quot;just test&quot;sv;字面值来生成string_view. 123constexpr string_view operator&quot;&quot; sv(const char* _Str, size_t _Len) noexcept { return string_view(_Str, _Len); } 数据成员string_view的模板类中, 只包含了两个私有数据成员_Mydata和_Mysize. _Mydata为指向底层字符数组的指针, 而_Mysize表示string_view的可见长度. 123456// MSVC-14.30.30705: xstring// wrapper for any kind of contiguous character bufferusing const_pointer = const _Elem*;using size_type = size_t;const_pointer _Mydata;size_type _Mysize; 构造函数1234567891011121314// 默认构造函数constexpr basic_string_view() noexcept : _Mydata(), _Mysize(0) {}// 拷贝构造constexpr basic_string_view(const basic_string_view&amp;) noexcept = default;// 拷贝赋值constexpr basic_string_view&amp; operator=(const basic_string_view&amp;) noexcept = default;// 使用指针和长度进行构造 constexpr basic_string_view(const const_pointer _Cts, const size_type _Count) noexcept // strengthened : _Mydata(_Cts), _Mysize(_Count) {}// 只使用指针构造, 不同编译器的实现可能不同.constexpr basic_string_view(const const_pointer _Ntcts) noexcept //strengthened : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {} 成员函数string_view的成员函数几乎和string没有差异. 不过需要注意的是: string_view的成员函数无法修改底层的数据, 比如operator[]返回constexpr引用. 其能修改的只有_Mydata指针的指向以及_Mysize的大小(即string_view的可见范围). 1constexpr const_reference operator[]( size_type pos ) const; 修改_Mydata指针和_Mysize大小的函数: 12345678// Moves the start of the view forward by n characters. The behavior is undefined if n &gt; size().constexpr void remove_prefix( size_type n );// Moves the end of the view back by n characters. The behavior is undefined if n &gt; size().constexpr void remove_suffix( size_type n );// Exchanges the view with that of v.constexpr void swap( basic_string_view&amp; v ) noexcept; String和StringView的互相构造 string_view构造string 可以使用string_view直接调用string的构造函数来初始化一个string对象. 并且string不与string_view共享底层数据. 注意只能显式调用string来讲string_view进行转换, 因为其实对底层数据的拷贝. 123template&lt; class StringViewLike &gt;explicit basic_string( const StringViewLike&amp; t, const Allocator&amp; alloc = Allocator() ); 测试代码 12345678910// 通过字面量创建string_view, 先调用constexpr string_view operator&quot;&quot; sv返回string_view对象, 然后赋值拷贝string_view sv = &quot;abcdef&quot;sv;string str = string(sv);str[0] = '1';cout &lt;&lt; &quot;string = &quot; &lt;&lt; str &lt;&lt; &quot;, string_view = &quot; &lt;&lt; sv &lt;&lt; endl;/*string = 1bcdef, string_view = abcdef*/ string构造string_view string_view可以使用string来构造, 原因是string有string_view的类型转换函数. 其可以进行隐式的转换, 因为string转换成string_view只是生成了一个只读视图. 12// string -&gt; string_view 的类型转换函数operator std::basic_string_view&lt;CharT, Traits&gt;() const noexcept; 测试代码 1234567string str = &quot;abc&quot;;string_view sv = str;cout &lt;&lt; &quot;string_view = &quot; &lt;&lt; sv &lt;&lt; endl;/*string_view = abc*/ StringView的使用注意事项 资源所有权的问题: It is the programmer’s responsibility to ensure that std::string_view does not outlive the pointed-to character array string_view的生命周期和其观察的底层字符串的生命周期是无关的. 因此如果底层字符串先于string_view析构, 那么当再次访问时, 其行为是未定义的. 底层字符串的修改问题: 12345678910string str = &quot;abc&quot;;string_view sv(str);string s = move(str);cout &lt;&lt; &quot;sv = &quot; &lt;&lt; sv &lt;&lt; &quot;, str = &quot; &lt;&lt; str &lt;&lt; &quot;, s = &quot; &lt;&lt; s &lt;&lt; endl;/*sv = bc, str = , s = abc*/ 因此我们需要保证使用string_view观察的底层字符串其必须不能被修改, 否则会造成不可预期的后果. 终结符的问题: 我们都知道c和cpp的字符串是以\\0作为终结符的. 而string_view是限定了可见长度, 当我们使用string_view时, 需要注意其不能使用strlen系列的函数进行字符串的操作, 因为字符串终结符的可见性可能被remove_suffix移除掉了. 12345678910const string str = &quot;abcdefg&quot;;string_view sv(str);sv.remove_prefix(1);sv.remove_suffix(2);cout &lt;&lt; &quot;sv = &quot; &lt;&lt; sv &lt;&lt; &quot;, strlen(sv) = &quot; &lt;&lt; strlen(sv.data()) &lt;&lt; endl;/* Errorsv = bcde, strlen(sv) = 6 */ 总结string_view解决了只读字符串某些场景下的性能问题. 但其在使用的时候还需要注意其引入的问题, 其不像lock_guard、unique_lock、shared_ptr、weak_ptr或unique_ptr等资源管理类一样和被管理资源的生命周期有着较为紧密的联系, 因此在使用的时候需要注意上述的几个问题. 参考cppreference-string_view[现代C++]性能控的工具箱之string_viewC++17剖析：string_view的实现，以及性能","link":"/2022/04/11/cpp/%5Bcpp%5DStringView%E5%AD%A6%E4%B9%A0/"},{"title":"[读书笔记]Linux Inside: 同步原语01-Spinlocks","text":"本系列博客为Linux Inside文章中Linux同步原语的阅读笔记. 主要包含了Spinlocks、Semaphores、Mutex、Reader/Writer semaphores、SeqLock、RCU和Lockdep. Linux内核提供了多种同步原语为防止多进程或多线程情况下的Race Condition. 这些同步原语的使用在内核代码中随处可见. 他们主要有: spinlocks; mutex; semaphores; seqlocks; atomic operations; SpinlocksSpinlocks是一种低阶的同步机制, 其用一个变量表示该锁的状态: acquired、released. 任何一个想要获得该锁的进程都必须向该变量写入值表示该锁被某进程acquired, 或想要释放锁的进程都必须向该变量写入值表示该锁被某进程released, 即其用变量表示锁的状态. 因此所有相关(写入变量)的操作必须是atomic的以防止出现数据竞争问题. 结构体定义Linux内核中SpinLocks由spinlock_t结构体来表示. 该结构体的定义为: 12345678910111213typedef struct spinlock { union { struct raw_spinlock rlock;#ifdef CONFIG_DEBUG_LOCK_ALLOC# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map)) struct { u8 __padding[LOCK_PADSIZE]; struct lockdep_map dep_map; };#endif };} spinlock_t; 该结构体的定义位于 include/linux/spinlock_types.h 头文件中. 如果内核中CONFIG_DEBUG_LOCK_ALLOC设置被禁用, 那么spintlock_t包含一个联合体, 该Union只有一个字段: raw_spinlock. raw_spinlock的表示spinlock的具体实现结构体. 该结构体的定义如下: 12345678910typedef struct raw_spinlock { arch_spinlock_t raw_lock;#ifdef CONFIG_DEBUG_SPINLOCK unsigned int magic, owner_cpu; void *owner;#endif#ifdef CONFIG_DEBUG_LOCK_ALLOC struct lockdep_map dep_map;#endif} raw_spinlock_t; 其中arch_spinlock_t代表架构相关的Spinlocks的具体实现. x86_64架构中的具体实现为: 12345678910111213typedef struct qspinlock { union { atomic_t val; struct { u8 locked; u8 pending; }; struct { u16 locked_pending; u16 tail; }; };} arch_spinlock_t; 相关处理函数内核提供的自旋锁相关的函数有: spin_lock_init: 对给定的spinlock初始化. spin_lock: 锁定给定的spinlock. spin_unlock: 释放给定的spinlock. spin_is_locked: 检查给定的spinlock的状态. spin_lock_bh: 禁止软件中断并锁定给定的spinlock. spin_unlock_bh: 释放给定的spinlock并允许软件中断. 初始化Spinlocks其中spin_lock_init宏在include/linux/spinlock.h头文件中声明, 它的具体实现为: 12345# define spin_lock_init(_lock) \\do { \\ spinlock_check(_lock); \\ *(_lock) = __SPIN_LOCK_UNLOCKED(_lock); \\} while (0) 该宏定义执行了两个操作: 检查给定的spinlock并且执行__SPIN_LOCK_UNLOCKED. 检查spinlock的具体实现很简单, 该函数仅仅返回raw_spinlock_t以保证我们得到normal raw spinlock. 1234static __always_inline raw_spinlock_t *spinlock_check(spinlock_t *lock){ return &amp;lock-&gt;rlock;} 正如__SPIN_LOCK_UNLOCKED的名字所示, 该宏初始化给定的spinlock并且将其中变量设置为released状态. 该宏定义在include/linux/spinlock_types.h头文件中, 具体实现为: 1234567891011#define ___SPIN_LOCK_INITIALIZER(lockname) \\ { \\ .raw_lock = __ARCH_SPIN_LOCK_UNLOCKED, \\ SPIN_DEBUG_INIT(lockname) \\ SPIN_DEP_MAP_INIT(lockname) }#define __SPIN_LOCK_INITIALIZER(lockname) \\ { { .rlock = ___SPIN_LOCK_INITIALIZER(lockname) } }#define __SPIN_LOCK_UNLOCKED(lockname) \\ (spinlock_t) __SPIN_LOCK_INITIALIZER(lockname) 我们无需关系DEBUG相关的初始化(SPIN_DEBUG_INIT(lockname)和SPIN_DEP_MAP_INIT(lockname)). 因此__SPIN_LOCK_UNLOCKED宏定义将会被展开成: *(_lock) = (spinlock_t) { .rlock = {.raw_lock = __ARCH_SPIN_LOCK_UNLOCKED} }. 其中x86_64架构的__ARCH_SPIN_LOCK_UNLOCKED的宏定义为: #define __ARCH_SPIN_LOCK_UNLOCKED { { .val = ATOMIC_INIT(0) } }. 因此经过一系列的宏定义展开后, spin_lock_init宏将给定的spin_lock的atomic状态变量设置为0, 表示unlocked状态. 对Spinlocks上锁spin_lock函数定义在include/linux/spinlock.h文件中. 1234static __always_inline void spin_lock(spinlock_t *lock){ raw_spin_lock(&amp;lock-&gt;rlock);} 其中raw_spin_lock的宏定义在相同的文件中. 其宏定义为: #define raw_spin_lock(lock) _raw_spin_lock(lock) 如果允许SMP并且设置了CONFIG_INLINE_SPIN_LOCK. 那么_raw_spin_lock的定义为: #define _raw_spin_lock(lock) __raw_spin_lock(lock) 该宏对应的函数定义为: 123456static inline void __raw_spin_lock(raw_spinlock_t *lock){ preempt_disable(); spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_); LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);} 该函数首先调用preempt_disable宏来禁用抢占. 当释放该自旋锁的时候, 抢占将会被允许: 123456static inline void __raw_spin_unlock(raw_spinlock_t *lock){ spin_release(&amp;lock-&gt;dep_map, _RET_IP_); do_raw_spin_unlock(lock); preempt_enable();} 需要通过禁用抢占来防止其他进程抢占该锁. spin_acquire通过一系列的宏展开为: #define spin_acquire(l, s, t, i) lock_acquire_exclusive(l, s, t, NULL, i)#define lock_acquire_exclusive(l, s, t, n, i) lock_acquire(l, s, t, 0, 1, n, i) 其中lock_acquire函数的实现为: 12345678910111213141516171819void lock_acquire(struct lockdep_map *lock, unsigned int subclass, int trylock, int read, int check, struct lockdep_map *nest_lock, unsigned long ip){ unsigned long flags; if (unlikely(current-&gt;lockdep_recursion)) return; raw_local_irq_save(flags); check_flags(flags); current-&gt;lockdep_recursion = 1; trace_lock_acquire(lock, subclass, trylock, read, check, nest_lock, ip); __lock_acquire(lock, subclass, trylock, read, check, irqs_disabled_flags(flags), nest_lock, ip, 0, 0); current-&gt;lockdep_recursion = 0; raw_local_irq_restore(flags);} lock_acquire通过raw_local_irq_save宏来关闭硬件中断. 因为给定的自旋锁可能通过开启硬件中断来获取. 这样该进程就不会被抢占, 在该函数的最后通过raw_local_irq_restore来重新开启中断. 主要的功能在__lock_acquire函数中完成(作者说到会在之后的章节解读该函数). 在__raw_spin_lock函数的最后, 会执行LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock); LOCK_CONTENDED该宏定义在include/linux/lockdep.h头文件中, 并只是调用给定的函数. 12#define LOCK_CONTENDED(_lock, try, lock) \\ lock(_lock) 此时lock是do_raw_spin_lock函数, _lock是给定的raw_spinlock_t: 12345static inline void do_raw_spin_lock(raw_spinlock_t *lock) __acquires(lock){ __acquire(lock); arch_spin_lock(&amp;lock-&gt;raw_lock);} 其中arch_spin_lock宏定义为: #define arch_spin_lock(l) queued_spin_lock(l) 下一节中将深入了解queued spinlocks的工作原理和相关概念.","link":"/2022/04/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Linux-Inside-%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/"},{"title":"对于学习的一些简单感悟","text":"大部分人解决问题依赖经验，而经验是从以往类似的案例中学习中获得的。 如同我们刷题一样，只有学过题目考察的定理，见过类似的考察方式，我们才能快速的解决问题；如果只有比较少的类型问题的经验，我们可能会在各种细节上斟酌把握；如果没有见过类似的问题，那几乎只有很少一部分人才能解决这个问题，称之为很有天赋很聪明不为过。 所以我今后应该做的事情就是：学习前人的智慧结晶，扩充自己的知识库和见识，丰富自己解决问题的技术和方案。技术新花样层出不穷, 但是底层的知识以及原理是通用且长期有效的。 学习的方式主要是看书、阅读技术博客、读源码、看技术分享视频以及与人交流。 积极拥抱变化, 不留恋在自己的舒适区, 不仅是学习的态度, 也应该是人生的态度.","link":"/2022/03/31/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88/%E5%AF%B9%E4%BA%8E%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%84%9F%E6%82%9F/"},{"title":"[cpp]基于RAII的资源管理类的原理和实现","text":"RAII(Resource Acquisition Is Initialization)是cpp中的编程技术之一。其意义为: 资源获取就是初始化, 保证资源在使用前获取, 使用后自动释放.降低程序因获取和释放资源导致出错的可能. RAII, is a C++ programming technique which binds the life cycle of a resource that must be acquired before use (allocated heap memory, thread of execution, open socket, open file, locked mutex, disk space, database connection—anything that exists in limited supply) to the lifetime of an object. RAII机制将资源(分配的堆内存、执行的线程、套接字、文件、mutex、硬盘空间、数据库连接等有限的资源)的生命周期绑定到RAII对象的生命周期上去. RAII的原理和基本流程: 在RAII类的构造函数中申请资源(可能会抛出异常). 所有可以访问RAII对象的地方使用资源. RAII对象析构的时候释放所拥有的资源(不抛出异常). 应用在标准库中, RAII技术有了广泛使用. 比如我们经常使用的std::string和std::vector. 以及管理锁相关的资源管理类lock_guard和unique_lock、管理用户自定义的资源(智能指针)shared_ptr、weak_ptr和unique_ptr. 优势 RAII机制保证所有可以访问RAII对象的函数都可以访问该对象所管理的资源, 减少不必要的运行时检测. RAII机制还保证所有的资源在RAII对象的生命周期结束时被释放，与获取时相反顺序的顺序释放, 无需程序员手动释放. 在构造函数中如果发生异常导致资源获取失败, 所有已经构造完成的成员和基类对象以构造时相反的顺序进行释放, 防止资源泄漏. 上述优势利用了cpp语言的核心特性: 对象的生命周期, 构造的顺序, 栈展开等来避免资源泄露, 保证异常安全. 下面给出cppreference上给出的一个例子, 体现了RAII资源管理类的优势: 12345678910111213141516std::mutex m; void bad() { m.lock(); // acquire the mutex f(); // if f() throws an exception, the mutex is never released if(!everything_ok()) return; // early return, the mutex is never released m.unlock(); // if bad() reaches this statement, the mutex is released} void good(){ std::lock_guard&lt;std::mutex&gt; lk(m); // RAII class: mutex acquisition is initialization f(); // if f() throws an exception, the mutex is released if(!everything_ok()) return; // early return, the mutex is released} // if good() returns normally, the mutex is released 栈展开一旦构造出了异常对象, 控制流向上(调用堆栈)查找直到找到try, 此时与所有相关的catch块按照出现的顺序进行参数的比较,直到找到一个匹配。如果没有找到匹配，控制流继续展开堆栈，直到下一个try块，依此类推。如果找到匹配，控制流将跳转到匹配的catch块。 当控制流向上移动到调用堆栈时，将对所有已构造但尚未销毁的栈上的局部对象调用析构函数, 这就是栈展开. 测试代码以下代码直接参考了StackUnwinding. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;new&gt;class Except0{public: ~Except0() { std::cout &lt;&lt; &quot;Except0's destructor is called!&quot; &lt;&lt; std::endl; }private: std::string str_;};class Except1{public: ~Except1() { std::cout &lt;&lt; &quot;Except1's destructor is called!&quot; &lt;&lt; std::endl; }private: std::string str_;};class Except2{public: ~Except2() { std::cout &lt;&lt; &quot;Except2's destructor is called!&quot; &lt;&lt; std::endl; }private: std::string str_;};class Except3{public: ~Except3() { std::cout &lt;&lt; &quot;Except3's destructor is called!&quot; &lt;&lt; std::endl; }private: std::string str_;};class Except4{public: ~Except4() { std::cout &lt;&lt; &quot;Except4's destructor is called!&quot; &lt;&lt; std::endl; }private: std::string str_;};void Test3(){ Except4 ex4; // throw an exception std::string().at(1); Except3 ex3;}void Test2(){ Except2 ex2; Test3();}void Test1(){ Except1 ex1; Test2();}int main(){ std::cout &lt;&lt; &quot;Test start&quot; &lt;&lt; std::endl; try { Except0 ex0; Test1(); } catch (const std::bad_alloc&amp; err) { std::cout &lt;&lt; err.what() &lt;&lt; std::endl; } catch (const std::exception&amp; err) { std::cout &lt;&lt; err.what() &lt;&lt; std::endl; } catch (...) { std::cout &lt;&lt; &quot;unknown exceptions&quot; &lt;&lt; std::endl; } std::cout &lt;&lt; &quot;Test end&quot; &lt;&lt; std::endl; return 0;}/* g++ -std=c++17Test startExcept4's destructor is called!Except2's destructor is called!Except1's destructor is called!Except0's destructor is called!basic_string::at: __n (which is 1) &gt;= this-&gt;size() (which is 0)Test end*/// tips: // 1. 异常必须要被捕获处理，未捕获异常将导致不会调用局部对象的析构函数（典型情况如此，具体是否调用依赖于具体的实现） 注意事项注意异常必须被捕获, 否则会调用std::terminate : 终止当前的程序, 并且不会栈上调用局部对象的析构函数. 123Test startterminate called after throwing an instance of 'std::out_of_range' what(): basic_string::at: __n (which is 1) &gt;= this-&gt;size() (which is 0) 实现经过以上分析, 我们可以看到基于RAII技术的资源管理类主要用于标准库本身的以及向用户提供封装好的模板类. 而对用户提供的资源管理类通常可以分为指针类型和锁类型的. 我们分别实现共享的指针类型资源管理类和锁资源管理类. 共享的指针类型资源管理类我们实现一个简易的shared_ptr模板类. shared_ptr使用指针用来管理用户指定的资源, 并提供和指针相同的行为: -&gt;, *操作符, 并支持拷贝赋值和拷贝构造. 并提供线程安全的资源访问和释放特性. 为了实现shared_ptr, 我们需要记录引用计数, 通过构造函数和拷贝构造等函数来维护这个引用计数即可. 而关键是如何记录这个引用计数. 这个引用计数应该对所有shared_ptr对象都是可见的, 这样才能正确记录. 为了实现对所有对象都可见, 我们可以在shared_ptr类中记录指向该引用计数的指针. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// 不可拷贝基类class noncopyable {public: noncopyable(const noncopyable&amp;) = delete; noncopyable operator=(const noncopyable&amp;) = delete;protected: noncopyable() = default; ~noncopyable() = default;};// 引用计数控制块class refCount : noncopyable{public: refCount () { _cnt.store(0); } refCount(int cnt) { _cnt.store(cnt); } void decRefCount() { _cnt.fetch_sub(1); } void incRefCount() { _cnt.fetch_add(1); } int getRefCount() { return _cnt.load(); }private: atomic_int _cnt;};// 简易版shared_ptr模板类template &lt;typename T&gt;class SharedPtr : noncopyable {public: using value_type = T; using pointer_type = T*; using reference_type = T&amp;; // 构造函数 SharedPtr () : _ptr(nullptr), _ref(nullptr) {} SharedPtr (pointer_type ptr) : _ptr(ptr), _ref(new refCount(1)) {} SharedPtr (const SharedPtr&amp; other) { _ptr = other._ptr; _ref = other._ref; this -&gt; increase(); } // 拷贝构造 SharedPtr&amp; operator = (const SharedPtr&amp; other) { if (this == &amp;other) return *this; // 先减当前的引用计数 this -&gt; decrease(); // 拷贝赋值 _ptr = other._ptr; _ref = other._ref; // 增加引用计数 this -&gt; increase(); } // 析构函数 ~SharedPtr() { cout &lt;&lt; &quot;~SharedPtr() called&quot; &lt;&lt; endl; decrease(); } int use_count() { return _ref -&gt; getRefCount(); } // Dereferences the stored pointer. The behavior is undefined if the stored pointer is null. pointer_type operator -&gt; () { return this -&gt; _ptr; } reference_type operator * (){ return *(this -&gt; _ptr); } pointer_type get() { return this -&gt; _ptr; } operator bool (){ return this -&gt; _ptr != nullptr; }private: // 内部实现, 不对外开放 void decrease() { if (_ptr == nullptr) return ; _ref -&gt; decRefCount(); if (_ref -&gt; getRefCount() == 0) { delete _ptr; cout &lt;&lt; &quot;free resource&quot; &lt;&lt; endl; } } void increase() { if (_ptr == nullptr) return ; _ref -&gt; incRefCount(); } // 指向控制块的指针, 记录引用计数 refCount* _ref; // 指向共享资源的指针 pointer_type _ptr;}; 测试样例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;atomic&gt;#include &lt;memory&gt;using namespace std;// 不可拷贝基类class noncopyable {public: noncopyable(const noncopyable&amp;) = delete; noncopyable operator=(const noncopyable&amp;) = delete;protected: noncopyable() = default; ~noncopyable() = default;};// 引用计数控制块class refCount : noncopyable{public: refCount () { _cnt.store(0); } refCount(int cnt) { _cnt.store(cnt); } void decRefCount() { _cnt.fetch_sub(1); } void incRefCount() { _cnt.fetch_add(1); } int getRefCount() { return _cnt.load(); }private: atomic_int _cnt;};// 简易版shared_ptr模板类template &lt;typename T&gt;class SharedPtr : noncopyable {public: using value_type = T; using pointer_type = T*; using reference_type = T&amp;; // 构造函数 SharedPtr () : _ptr(nullptr), _ref(nullptr) {} SharedPtr (pointer_type ptr) : _ptr(ptr), _ref(new refCount(1)) {} SharedPtr (const SharedPtr&amp; other) { _ptr = other._ptr; _ref = other._ref; this -&gt; increase(); } // 拷贝构造 SharedPtr&amp; operator = (const SharedPtr&amp; other) { if (this == &amp;other) return *this; // 先减当前的引用计数 this -&gt; decrease(); // 拷贝赋值 _ptr = other._ptr; _ref = other._ref; // 增加引用计数 this -&gt; increase(); } // 析构函数 ~SharedPtr() { cout &lt;&lt; &quot;~SharedPtr() called&quot; &lt;&lt; endl; decrease(); } int use_count() { return _ref -&gt; getRefCount(); } // Dereferences the stored pointer. The behavior is undefined if the stored pointer is null. pointer_type operator -&gt; () { return this -&gt; _ptr; } reference_type operator * (){ return *(this -&gt; _ptr); } pointer_type get() { return this -&gt; _ptr; } operator bool (){ return this -&gt; _ptr != nullptr; }private: // 内部实现, 不对外开放 void decrease() { if (_ptr == nullptr) return ; _ref -&gt; decRefCount(); if (_ref -&gt; getRefCount() == 0) { delete _ptr; cout &lt;&lt; &quot;free resource&quot; &lt;&lt; endl; } } void increase() { if (_ptr == nullptr) return ; _ref -&gt; incRefCount(); } // 指向控制块的指针, 记录引用计数 refCount* _ref; // 指向共享资源的指针 pointer_type _ptr;};class Resource {public: Resource () = default; Resource (int val) : _val(val) {} int get () const { return _val; }private: int _val;};ostream&amp; operator &lt;&lt; (ostream&amp; os, const Resource&amp; res) { os &lt;&lt; res.get(); return os;}int main() { SharedPtr&lt;Resource&gt; sp(new Resource(123)); auto nsp = sp; cout &lt;&lt; sp -&gt; get() &lt;&lt; endl; cout &lt;&lt; (*nsp).get() &lt;&lt; endl; cout &lt;&lt; nsp.use_count() &lt;&lt; endl; // 使用前先判断是否为空, 调用了 operator bool if (nsp) { *nsp = 10086; auto p = nsp.get(); cout &lt;&lt; &quot;nsp is not empty, *nsp = &quot; &lt;&lt; (*p) &lt;&lt; endl; } return 0;}/*1231232nsp is not empty, *nsp = 10086~SharedPtr() called~SharedPtr() calledfree resource*/ 锁资源管理类锁资源管理类的实现较为直接, 可以使用引用或指针的方式去管理用户在构造函数中传入的锁资源. 通过构造函数和析构函数获取和释放资源, 并提供lock和unlock来管理锁资源, 实现了一个简易版的unique_lock&lt;mutex&gt;. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142class noncopyable {public: noncopyable(const noncopyable&amp;) = delete; noncopyable operator=(const noncopyable&amp;) = delete;protected: noncopyable() = default; ~noncopyable() = default;};class MutexUniqueLock: noncopyable {public: MutexUniqueLock(mutex&amp; mtx) : _mtx(mtx), _own(false) { _mtx.lock(); _own = true; } void lock() { if (!_own) { _mtx.lock(); _own = true; } } void unlock() { if (_own) { _mtx.unlock(); _own = false; } } ~MutexUniqueLock() { if (_own) _mtx.unlock(); }private: // 指向mutex的引用 mutex&amp; _mtx; // 是否持有该锁 bool _own;}; 测试样例测试样例是一个简单的双线程奇偶交替打印程序, 使用CAS和mutex 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;atomic&gt;using namespace std;class noncopyable {public: noncopyable(const noncopyable&amp;) = delete; noncopyable operator=(const noncopyable&amp;) = delete;protected: noncopyable() = default; ~noncopyable() = default;};class MutexUniqueLock: noncopyable {public: MutexUniqueLock(mutex&amp; mtx) : _mtx(mtx), _own(false) { _mtx.lock(); _own = true; } void lock() { if (!_own) { _mtx.lock(); _own = true; } } void unlock() { if (_own) { _mtx.unlock(); _own = false; } } ~MutexUniqueLock() { if (_own) _mtx.unlock(); }private: // 指向mutex的引用 mutex&amp; _mtx; // 是否持有该锁 bool _own;};// 互斥锁mutex mtx;// 先打印奇数atomic&lt;bool&gt; isOdd(true);void printOdd() { for (int i = 1; i &lt;= 100; i += 2) { bool want = true; // CAS, compare_exchange_weak会修改Expected的值, 因此需要在循环内修改 while (isOdd.compare_exchange_weak(want, want) == false) want = true; // 临界区 MutexUniqueLock lock(mtx); cout &lt;&lt; i &lt;&lt; &quot; &quot;; isOdd = false; }}void printEven() { for (int i = 2; i &lt;= 100; i += 2) { bool want = false; // CAS, compare_exchange_weak会修改Expected的值, 因此需要在循环内修改 while (isOdd.compare_exchange_weak(want, want) == false) want = false; // 临界区 MutexUniqueLock lock(mtx); cout &lt;&lt; i &lt;&lt; &quot; &quot;; isOdd = true; }}int main() { thread oddThread(printOdd); thread evenThread(printEven); oddThread.join(); evenThread.join(); return 0;}/*1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100*/ 总结基于RAII编程技术的资源管理类有着相同的思想内涵, 其在构造函数和析构函数中进行资源的获取和释放. 标准库封装了一些友好的资源管理类, 主要有基于锁机制的lock_guard和unique_lock, 还有智能指针类型的用户资源管理类shared_ptr、weak_ptr和unique_ptr. 针对不同语义下的应用场景, 需要重载一些函数来提供便捷的资源访问, 减轻程序编写过程中的负担. 参考RAII栈展开StackUnwinding 欢迎讨论指正","link":"/2022/04/12/cpp/%5Bcpp%5D%E5%9F%BA%E4%BA%8ERAII%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"},{"title":"[LeetCode-周赛]295","text":"Rank : 135 / 16846Solved : 4/4 竞赛链接 最近第一次做出四题, 赶紧把思路分享一下hhhhhh. Rearrange Characters to Make Target String思路枚举. 分别统计一下s和target中的字符数量, 然后对于target中的每个字符单独考虑, 看看s中最多能组成几组, 最后取每个字符对应的最小值即可. Code123456789101112131415161718class Solution {public: int rearrangeCharacters(string s, string target) { unordered_map&lt;char, int&gt; cnt, ct; for (auto&amp; c : s) cnt[c] ++ ; for (auto&amp; c : target) ct[c] ++ ; int ans = INT_MAX; for (auto&amp; [k, v] : ct) ans = min(ans, cnt[k] / v); if (ans == INT_MAX) ans = 0; return ans; }}; 复杂度分析 时间复杂度$O(N + M)$ 空间复杂度$O(N + M)$ Apply Discount to Prices思路模拟. 模拟题意即可. 处理字符串c++相对麻烦一点, 所以我这里使用了python. Code123456789101112131415class Solution: def discountPrices(self, s: str, discount: int) -&gt; str: d = discount * 0.01 words = s.split(' ') ans = [] for word in words: cur = word if word[0] == '$' and word[1:].isnumeric(): cur = float(cur[1:]) * (1.0 - d) cur = format(cur, &quot;.2f&quot;) cur = '$' + str(cur) ans.append(cur) ans = &quot; &quot;.join(ans) return ans 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ Steps to Make Array Non-decreasing思路区间最值. 考虑每一个数需要几步才能删掉他, 记为f[i]. 如果该数左边没有比它大的数, 那么该数无需删除, f[i] = 0. 如果该数左边有比它大的数, 该数需要删除, f[i] &gt; 0. 假设当前数下标为i, 左边第一个比它大的数下标为j, 那么删除当前数的代价为: $$ f[i] = max(f[k]) + 1, \\ k \\in [j + 1, i]$$ 因为只有将[j + 1, i - 1]之间的数全部删掉后, 才能再下一步中使用nums[j]去删掉nums[i]. 这样问题转化成区间最值, 可以使用线段树解决.(没板子, 抄区间最值搞了老半天….) Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const int N = 1e5 + 5;struct Node { int l, r; int v;} tr[N * 4];void pushup(int u) { tr[u].v = max(tr[u + u].v, tr[u + u + 1].v);}void build(int u, int l, int r) { tr[u] = {l, r}; // tr[u].v = 0; if (l &lt; r) { int mid = l + r &gt;&gt; 1; build(u + u, l, mid); build(u + u + 1, mid + 1, r); pushup(u); }}int query(int u, int l, int r) { if (tr[u].l == l and tr[u].r == r) return tr[u].v; int mid = tr[u].l + tr[u].r &gt;&gt; 1; int v = 0; if (r &lt;= mid) v = query(u + u, l, r); else if (l &gt; mid) v = query(u + u + 1, l, r); else { v = max(query(u + u, l, mid), query(u + u + 1, mid + 1, r)); } return v;}void modify(int u, int x, int c) { if (tr[u].l == x and tr[u].r == x) { tr[u].v = c; return ; } int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (x &lt;= mid) modify(u + u, x, c); else modify(u + u + 1, x, c); pushup(u);}class Solution {public: int totalSteps(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n + 1, 0), idx(n + 1, 0); stack&lt;int&gt; stk; for (int i = 1; i &lt;= n; i ++ ) { int cur = nums[i - 1]; while (stk.size() and nums[stk.top() - 1] &lt;= cur) stk.pop(); if (stk.size()) idx[i] = stk.top(); stk.push(i); } build(1, 1, n); for (int i = 1; i &lt;= n; i ++ ) { if (idx[i] == 0) continue; // for (int j = idx[i] + 1; j &lt; i; j ++ ) // ans = max(ans, f[j]); assert (idx[i] + 1 &lt;= i); f[i] = query(1, idx[i] + 1, i) + 1; modify(1, i, f[i]); } return *max_element(f.begin(), f.end()); }}; 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ Minimum Obstacle Removal to Reach Corner思路经典0-1BFS. 把每个格子看作点, 格子与相邻格子连边. 那么边的权重只会是0或1. 问题转化成从起点到终点的最短路, 且边的权重只有0/1. 可以使用0-1 BFS / Dijkstra解决. Code1234567891011121314151617181920212223242526272829303132333435// 0-1 BFSusing PII = pair&lt;int, int&gt;;const int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};class Solution {public: int minimumObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; g) { int n = g.size(), m = g[0].size(); constexpr int INF = 1e9; vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(m, INF)); dist[0][0] = 0; deque&lt;PII&gt; qu; qu.emplace_front(0, 0); while (qu.size()) { auto [x, y] = qu.front(); qu.pop_front(); for (int i = 0; i &lt; 4; i ++ ) { int nx = x + dx[i], ny = y + dy[i]; if (nx &gt;= 0 and nx &lt; n and ny &gt;= 0 and ny &lt; m) { if (g[nx][ny] == 1 and dist[nx][ny] &gt; dist[x][y] + 1) { dist[nx][ny] = dist[x][y] + 1; qu.emplace_back(nx, ny); } else if (g[nx][ny] == 0 and dist[nx][ny] &gt; dist[x][y]) { dist[nx][ny] = dist[x][y]; qu.emplace_front(nx, ny); } } } } return dist[n - 1][m - 1]; }}; 复杂度分析 时间复杂度$O(N * M)$ 空间复杂度$O(N * M)$ 欢迎讨论指正","link":"/2022/05/29/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D295/"},{"title":"[cpp]资源生命周期管理类:enable_shared_from_this","text":"enable_shared_from_this模板类能够帮助我们轻松的用对象在其方法中获取指向对象的shared_ptr, 从而在并行编程中安全的管理资源的生命周期, 避免跨线程调用中资源的提前释放导致程序出错的危害. 我们在之前简单学习了基于RAII的资源管理类的原理和实现, 并实现了一个简易的shared_ptr类来安全的管理资源. shared_ptr模板类使用共享的Control Block来管理资源的生命周期, Control Block记录了引用计数、weak引用计数和其他必要的信息来管理资源. 当使用raw指针构造一个shared_ptr对象时, 新的Control Block就会被创建. 因此为了保证只有唯一一个Control Block来管理资源, 必须用已有的shared_ptr对象使用拷贝构造\\拷贝赋值的方式创建新的shared_ptr对象. 从而避免资源被多次释放造成的程序出错. 下面给出一个典型的错误使用场景: 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;int main() { { int* p = new int(1234); shared_ptr&lt;int&gt; sp1 {p}; shared_ptr&lt;int&gt; sp2 {p}; cout &lt;&lt; &quot;ref Count = &quot; &lt;&lt; sp1.use_count() &lt;&lt; endl; } cout &lt;&lt; &quot;Done\\n&quot;; return 0;}/* Output on Linux Ubuntu g++ 9.4.0ref Count = 1free(): double free detected in tcache 2已放弃 (核心已转储)*/ 因此我们必须避免同一个资源被多个shared_ptr对象管理, 这会造成程序出错. 对象的生命周期在并行(异步)编程中, 一个线程可能会调用其他线程的函数异步的完成某些任务, 而该任务依赖于当前线程所用的对象资源, 这种情况下, 必须保证该对象资源的生命周期必须比异步函数的生命周期要长, 因为如果在异步函数执行的过程中它所用的对象被其他线程析构了, 那么会造成程序崩溃. 因此我们必须使用一些方法保证对象资源的生命周期, 一般实践中使用对象的this指针来传递对象的上下文, 保证该对象的跨线程生命周期. 简单来说, 我们使用this指针保证A线程中的对象资源在调用B线程中的异步方法, 且该方法使用该对象资源时, 该对象资源的生命周期必须长于B线程中的异步函数, 即其在B线程中异步函数生命周期中不可被其他线程释放. 为了实现上述需求, 我们可以使用shared_ptr来管理this指针(管理对象资源). 那么该如何管理呢？我们考虑从该对象本身构造出指向其自身的shared_ptr对象. 我们需要从shared_ptr所管理的对象中获取其指向自身的shared_ptr对象时, 如果我们简单的使用类的成员函数返回指向自身的shared_ptr对象, 那么根据以上分析, 这将会导致程序出错. 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Resource {public: Resource (int res) : _res(res) {} ~Resource () { cout &lt;&lt; &quot;called dest.&quot; &lt;&lt; endl; } shared_ptr&lt;Resource&gt; getObject() { return shared_ptr&lt;Resource&gt;(this); }private: int _res;};int main() { { shared_ptr&lt;Resource&gt; sp = make_shared&lt;Resource&gt;(10); auto objSp = sp -&gt; getObject(); } cout &lt;&lt; &quot;Done\\n&quot;; return 0;}/* Output on Linux Ubuntu g++ 9.4.0called dest.double free or corruption (out)已放弃 (核心已转储)*/ 上面错误使用场景和最开始提到的场景是一模一样的,即都用了多个Control Block来管理指针资源, 从而导致重复释放. 这种情况下, 我们就需要enable_shared_from_this来实现上述需求. 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Resource : public enable_shared_from_this&lt;Resource&gt; {public: Resource(int res) : _res(res) { } ~Resource() { cout &lt;&lt; &quot;called dest.&quot; &lt;&lt; endl; } shared_ptr&lt;Resource&gt; getObject() { return shared_from_this(); }private: int _res;};int main() { { shared_ptr&lt;Resource&gt; sp = make_shared&lt;Resource&gt;(10); cout &lt;&lt; &quot;ref cnt = &quot; &lt;&lt; sp.use_count() &lt;&lt; endl; auto objSp = sp-&gt;getObject(); cout &lt;&lt; &quot;ref cnt = &quot; &lt;&lt; sp.use_count() &lt;&lt; endl; } cout &lt;&lt; &quot;Done\\n&quot;; return 0;}/* Output on Linux Ubuntu g++ 9.4.0ref cnt = 1ref cnt = 2called dest.Done*/ 需要实现上述需求的资源类需要公有继承enable_shared_from_this模板类, 然后使用shared_from_this方法(enable_shared_from_this模板类的公有方法)来获取一个指向其对象自身的shared_ptr对象. 我们简单来看以下enable_shared_from_this模板类的源码, 看看其是如何实现的上述功能的. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @brief Base class allowing use of member function shared_from_this. */template &lt;typename _Tp&gt;class enable_shared_from_this {protected: constexpr enable_shared_from_this() noexcept { } enable_shared_from_this(const enable_shared_from_this &amp;) noexcept { } enable_shared_from_this &amp; operator=(const enable_shared_from_this &amp;) noexcept { return *this; } ~enable_shared_from_this() { }public: /* 公有方法 */ shared_ptr&lt;_Tp&gt; shared_from_this() { return shared_ptr&lt;_Tp&gt;(this-&gt;_M_weak_this); } shared_ptr&lt;const _Tp&gt; shared_from_this() const { return shared_ptr&lt;const _Tp&gt;(this-&gt;_M_weak_this); }#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11#define __cpp_lib_enable_shared_from_this 201603 weak_ptr&lt;_Tp&gt; weak_from_this() noexcept { return this-&gt;_M_weak_this; } weak_ptr&lt;const _Tp&gt; weak_from_this() const noexcept { return this-&gt;_M_weak_this; }#endifprivate: template &lt;typename _Tp1&gt; void _M_weak_assign(_Tp1 *__p, const __shared_count&lt;&gt; &amp;__n) const noexcept { _M_weak_this._M_assign(__p, __n); } // Found by ADL when this is an associated class. friend const enable_shared_from_this * __enable_shared_from_this_base(const __shared_count&lt;&gt; &amp;, const enable_shared_from_this *__p) { return __p; } template &lt;typename, _Lock_policy&gt; friend class __shared_ptr; mutable weak_ptr&lt;_Tp&gt; _M_weak_this;}; 以上源码我们发现三点: enable_shared_from存在一个mutable成员变量weak_ptr&lt;_Tp&gt; _M_weak_this, 这样const对象也能够对其进行修改. enable_shared_from含有友元类__shared_ptr, 这样shared_ptr类能够访问enable_shared_from的私有成员变量. cpp17添加了weak_from_this()方法返回weak_ptr的拷贝, 然后使用weak_ptr.lock()就能安全的获取shared_ptr对象. 具体shared_from_this()函数的实现是很简单的, 其通过私有成员变量来构造shared_ptr对象然后返回. 那么该私有成员变量是何时初始化的呢? 它是在构造shared_ptr对象的时候被初始化的, 在初始化构造一个shared_ptr对象的时候, 可以根据type traits(std::enable_if 和 std::is_convertible)来实现. 如果这个资源类公有继承了std::enable_shared_from_this模板类, 那么就将父类中的_M_weak_this初始化绑定到创建出来的shared_ptr对象上去(友元类的声明让其能够访问私有成员变量), 这样就实现了_M_weak_this的安全初始化. 这种设计对于shared_ptr模板类来说是侵入式的. 最后给出一个讲解很好博客的图示和代码. 12345678910111213struct Article : std::enable_shared_from_this&lt;Article&gt; { //stuff..};void foo() { //Step 1 // '_M_weak_this' 是空的, 没有和 Control Block 相关联 auto pa = new Article; //Step 2 // '_M_weak_this' 被初始化, 与 Control Block 相关联 auto spa = std::shared_ptr&lt;Article&gt;(pa);} 需要注意的是, 公有继承的原因是_M_weak_this的初始化是在shared_ptr对象的构造函数中初始化的, 必须能够检测到该类是继承了enable_shared_from_this基类的. 另外, 必须通过shared_ptr来调用对象的shared_from_this, 因为_M_weak_this的初始化是在shared_ptr对象的构造函数中进行的, 如果还没有shared_ptr对象被构造, 那么调用shared_from_this()使用_M_weak_this来构造shared_ptr会造成std::bad_weak_ptr异常, 原因是_M_weak_this还没有和某个Contorl Block相关联. 当然如果使用cpp17, 可以用weak_from_this()来获取weak_ptr自行lock()并判断来保证安全, 不过还是建议统一先构造shared_ptr对象, 再安全的使用shared_from_this方法. 总结当一个类需要”共享自己”的时候, enable_shared_from_this模板类就是标准库提供的强大工具. 它可以安全的管理和构造我们所需的shared_ptr对象, 不过还是有一些问题是需要注意的. 首先我们必须先构造shared_ptr对象, 然后使用类的shared_from_this方法, 因为必须保证enable_shared_from_this基类的_M_weak_this被初始化. 其次我们不能在类的构造函数中调用shared_from_this, 因为此时_M_weak_this可能还未初始化. 而且必须公有继承enable_shared_from_this. 最后对象的生命周期管理是多线程(异步)编程中必须关注的一个问题, cpp提供的智能指针和enable_shared_from_this等模板类很友好的实现了我们的需求, 不过仍然需要注意一些坑点. 向往侯捷老师说的胸中自有丘壑的境界水平, 努力做到知其然知其所以然, 才能提升自身的视野和水平呀. 参考cppRef图文讲解blog","link":"/2022/04/26/cpp/%5Bcpp%5D%E8%B5%84%E6%BA%90%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E7%B1%BB-enable-shared-from-this/"},{"title":"[cpp]STL容器简单学习","text":"简单总结学习一下STL中常用的容器, 主要分为序列式容器和关联式容器. 序列式容器vector动态数组. 其模板类中包含了三根指针, 分别指向begin、end和end of storage. vector的大小size = end - begin, 其容量cap = end of storage - begin. 12345struct _Vector_impl_data { pointer _M_start; // begin pointer _M_finish; // end pointer _M_end_of_storage; // end of storage} 我们来看一个标准库中的使用场景: 1234567891011121314// [23.2.4.2] capacity/** Returns the number of elements in the %vector. */size_typesize() const _GLIBCXX_NOEXCEPT{ return size_type(this-&gt;_M_impl._M_finish - this-&gt;_M_impl._M_start); }/*** Returns the total number of elements that the %vector can* hold before needing to allocate more memory.*/size_typecapacity() const _GLIBCXX_NOEXCEPT{ return size_type(this-&gt;_M_impl._M_end_of_storage - this-&gt;_M_impl._M_start); } 很简单直接的计算vector的size和caoacity的方式. push_back的实现: 1234567891011121314151617181920212223242526272829/*** @brief Add data to the end of the %vector.* @param __x Data to be added.** This is a typical stack operation. The function creates an* element at the end of the %vector and assigns the given data* to it. Due to the nature of a %vector this operation can be* done in constant time if the %vector has preallocated space* available.*/voidpush_back(const value_type&amp; __x){if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage){ _GLIBCXX_ASAN_ANNOTATE_GROW(1); _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish, __x); ++this-&gt;_M_impl._M_finish; _GLIBCXX_ASAN_ANNOTATE_GREW(1);}else _M_realloc_insert(end(), __x);}#if __cplusplus &gt;= 201103Lvoid push_back(value_type&amp;&amp; __x){ emplace_back(std::move(__x)); } 如果是cpp版本大于11且push_back的是右值, 那么就直接调用emplace_back. 否则使用const &amp;来接受参数, 在finish处构造; 因空间不足导致重新分配内存后继续构造. 由上可见, 在64位机器上, sizeof(vector&lt;T&gt;)的大小为24. list双向链表. cpp中list的实现为双端队列. STL的实现中对于模板和不依赖模板的部分进行了分离, 使得代码结构更加分离, 减少代码重复. 先来看看不依赖模板的类和结构体, 主要是链表结点中的指针域和链表结点头. 123456789101112131415/// Common part of a node in the %list.struct _List_node_base{ _List_node_base* _M_next; _List_node_base* _M_prev; // ...}/// The %list node header.struct _List_node_header : public _List_node_base { std::size_t _M_size; // ...private: _List_node_base* _M_base() { return this; }} 需要模板的部分依赖于具体实例化的类型, 主要有ListNode(存储数据, 继承_List_node_base, 即其包含指针域)、ListIterator(完成迭代器的功能, , -&gt;, ++, – 等操作符的重载)、*ListBase(完成List内存结点分配, 结点数量维护等基础功能, 向List提供实现类ListImpl)和List(公有继承ListBase, 使用ListBase中的基础函数完成List所需的功能). ListNode123456789101112131415/// An actual node in the %list.template&lt;typename _Tp&gt;struct _List_node : public __detail::_List_node_base{#if __cplusplus &gt;= 201103L // 数据存储 __gnu_cxx::__aligned_membuf&lt;_Tp&gt; _M_storage; _Tp* _M_valptr() { return _M_storage._M_ptr(); } _Tp const* _M_valptr() const { return _M_storage._M_ptr(); }#else _Tp _M_data; _Tp* _M_valptr() { return std::__addressof(_M_data); } _Tp const* _M_valptr() const { return std::__addressof(_M_data); }#endif}; ListIterator选取了_List_iterator的部分源码. 123456789101112131415161718192021222324252627282930313233/*** @brief A list::iterator.** All the functions are op overloads.*/template&lt;typename _Tp&gt;struct _List_iterator{ typedef _List_iterator&lt;_Tp&gt; _Self; typedef _List_node&lt;_Tp&gt; _Node; typedef ptrdiff_t difference_type; typedef std::bidirectional_iterator_tag iterator_category; typedef _Tp value_type; typedef _Tp* pointer; typedef _Tp&amp; reference; // Must downcast from _List_node_base to _List_node to get to value. reference operator*() const _GLIBCXX_NOEXCEPT { return *static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_valptr(); } pointer operator-&gt;() const _GLIBCXX_NOEXCEPT { return static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_valptr(); } _Self&amp; operator++() _GLIBCXX_NOEXCEPT { _M_node = _M_node-&gt;_M_next; return *this; } // The only member points to the %list element. __detail::_List_node_base* _M_node;}; 可见_List_iterator使用_List_node_base(非模板类)来实现指针域的功能(通过运算符重载). ListBase1234567891011121314151617181920212223/// See bits/stl_deque.h's _Deque_base for an explanation.template&lt;typename _Tp, typename _Alloc&gt;class _List_base {protected: typedef typename __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::templaterebind&lt;_Tp&gt;::other _Tp_alloc_type; typedef __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt; _Tp_alloc_traits; typedef typename _Tp_alloc_traits::templaterebind&lt;_List_node&lt;_Tp&gt; &gt;::other _Node_alloc_type; typedef __gnu_cxx::__alloc_traits&lt;_Node_alloc_type&gt; _Node_alloc_traits;struct _List_impl: public _Node_alloc_type{ __detail::_List_node_header _M_node; // ...};_List_impl _M_impl;} 可见_List_base中的_List_impl中是包含_List_node_header(非模板类), 即链表的头节点, 里面不仅有next、prev指针域, 还有链表的结点数目计数. ListList是环形双向链表. 当为空时: this-&gt;_M_impl._M_node._M_next = this-&gt;_M_impl._M_node, 否则this-&gt;_M_impl._M_node指向末尾, 其next域指向begin(). 1234567891011121314template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt;class list : protected _List_base&lt;_Tp, _Alloc&gt; { using _Base::_M_impl; using _Base::_M_put_node; using _Base::_M_get_node; using _Base::_M_get_Node_allocator; // _M_node 指向 end 结点, 其next指向 begin iterator begin() _GLIBCXX_NOEXCEPT { return iterator(this-&gt;_M_impl._M_node._M_next); } iterator end() _GLIBCXX_NOEXCEPT { return iterator(&amp;this-&gt;_M_impl._M_node); }} string字符串. cpp中string为basic_string&lt;char&gt;的别名. 即typedef basic_string&lt;char&gt; string;. 因此我们查看``basic_string`是如何实现的即可. 1234567891011121314151617struct _Alloc_hider : allocator_type // TODO check __is_final{ pointer _M_p; // The actual data.};// basic_string&lt;char&gt;_Alloc_hider _M_dataplus;size_type _M_string_length;// sizeof(_CharT) = 1, 因此 _S_local_capacity = 15enum { _S_local_capacity = 15 / sizeof(_CharT) };/* M_local_buf 为栈上缓存, 当字符串长度超过15时, _M_allocated_capacity 为有效值, 表示其字符串容量 */union { _CharT _M_local_buf[_S_local_capacity + 1]; size_type _M_allocated_capacity;}; 我们可以发现_Alloc_hider为string内存的实现, 其结构体中的pointer _M_p指向字符串的首地址. 重要的是, 该模板类中还存在一个联合体(同一时刻只有一个值有效). 当字符串长度 &lt;= 15时, 其在栈上分配(local buf), 当长度超过15时, 其通过 _M_dataplus._M_p 指向字符串的其实地址(一般在堆中), 此时 _M_allocated_capacity 指示字符串的容量. 下面我们看一个具体应用场景(string移动构造函数)来验证我们的想法: 12345678910111213141516171819202122232425262728/*** @brief Move construct string.* @param __str Source string.** The newly-created string contains the exact contents of @a __str.* @a __str is a valid, but unspecified string.**/basic_string(basic_string&amp;&amp; __str) noexcept: _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator())){if (__str._M_is_local()){ traits_type::copy(_M_local_buf, __str._M_local_buf, _S_local_capacity + 1);}else{ _M_data(__str._M_data()); _M_capacity(__str._M_allocated_capacity);}// Must use _M_length() here not _M_set_length() because// basic_stringbuf relies on writing into unallocated capacity so// we mess up the contents if we put a '\\0' in the string._M_length(__str.length());__str._M_data(__str._M_local_data());__str._M_set_length(0);} 如果移动的string为local string(即长度 &lt;= 15, 内容存储在union中), 则执行: traits_type::copy(_M_local_buf, __str._M_local_buf, _S_local_capacity + 1); 这里使用拷贝的原因是, 我们必须保证当前字符串的生命周期不依赖于被move的字符串, 必须使用当前栈上的存储空间来保存字符串; 另一方面, 其长度 &lt;= 15, 我们就应该通过拷贝来将其复制到uinon中, 这样处理起来是统一的. 如果不是local string(即长度 &gt; 15, 内容存储在[_M_dataplus._M_p, _M_dataplus._M_p + _M_string_length)中, 我们将指向字符串的指针和容量参数进行拷贝即可. 最后我们拷贝字符串的长度(不受local还是非local的影响), 最后将被move的字符串清空. 最后当我们对空string取sizeof时, 由上可见, 其大小为 sizeof(pointer) + sizeof(size_type) + 16 = 8 + 8 + 16 = 32 (64位机器下). deque双端队列. 实现较为复杂, 这里给出一个比较好的回答的链接, 回答1和2的图示和代码已经能够说明其完整的实现. 其实现类似于拉链法哈希表的思路, 第一维中央控制器map中的每个值指向一个固定长度的一维数组, 在标准库的实现中指向的是_Deque_iterator, 再由_Deque_iterator指向具体的内存, 并且_Deque_iterator中first和last可以框定内存的范围, cur指向当前的位置(该chunk可能有些位置还未使用. 如果是map::start, 那么该节点的cur指向第一个数据, 且该chunk中cur左边的所有位置是unused, 右边的位置全部被使用了; 如果是map::finsh, 那么该节点的cur指向最后一个数据的下一位置, 且该chunk中cur左边位置全被使用了, 右边的位置是unused). deque的具体实现在_Deque_base::_Deque_impl中, 主要包含了四个变量: _Map_pointer _M_map: 指向中央控制器的指针. size_t _M_map_size: 中央控制器的大小. iterator _M_start: 指向中央控制器可用node中最左边的node. iterator _M_finish: 指向中央控制器可用node中最右边的node. 注意到的是, _Deque_iterator中也存储了指向中央控制器的指针: _Map_pointer _M_node, 通过该指针可以确定当前node在中央控制器中的位置, 并且实现random access. 为了降低复制(重新构造deque)的代价(该代价为申请新的中央控制器并修改_Deque_iterator中_M_node指针的指向). _M_start和_M_finish初始化的时候应尽可能靠近中央控制器的中心的, 这样在push_front和push_back的时候, 两边会有较为均衡的空间去使用. 另外注意到, 在_Deque_iterator存在如下别名定义: typedef std::random_access_iterator_tag iterator_category; 即deque支持随机访问, 使用该迭代器traits, 配合偏特化, 可以高效的实现一些函数. 如下所示: 12345678deque(initializer_list&lt;value_type&gt; __l,const allocator_type&amp; __a = allocator_type()): _Base(__a){_M_range_initialize(__l.begin(), __l.end(), random_access_iterator_tag());} 即支持随机访问的迭代器, 那么我们就可以向数组那样去初始化它. 如for (auto cur = begin(); cur &lt; end(); ++ cur)这样. 最后分析以下空deque的大小. 由上可见, deque的大小就是其中央控制器map的大小, map中由四个变量, map pointer和map size均为8字节, start和finsh的大小为四个指针的大小, 即32字节. 因此空deque的大小是80. 总结deque的实现还是比较精妙的, 很值得学习的. 首先是类的结构的设计,deque自身只提供向外的接口, 其调用deque_base的具体实现和函数来完成这些接口, 而且通过引入deque_iterator, 使得具体数据存储的功能划分更为明确, 而且利用_M_cur和_M_node可以很高效的完成deque中一些函数的实现. 当中央控制器的node不够时, 复制现有的deque的代价是很低的, 因为我们无需复制底层存储数据的内存, 只需要复制中央控制器以及修改deque_iterator中_M_node指针的指向即可. stack 和 queue栈和队列. 这两个是标准的容器适配器, 其拥有一个deque. 它们的功能都由deque来实现. 栈和队列只不过是对强大的deque的接口进行了必要的封装, 提供其期望的函数. 1234567891011121314/** queue的模板类*/template&lt;typename _Tp, typename _Sequence = deque&lt;_Tp&gt; &gt;/// @c c is the underlying container._Sequence c;/** stack的模板类*/template&lt;typename _Tp, typename _Sequence = deque&lt;_Tp&gt; &gt;// See queue::c for notes on this name._Sequence c; 关联式容器关联式容器主要分为基于哈希表的unordered_set和unordered_set和基于红黑树的map和set. 哈希表是通过拉链法实现的, 这里给出一个解释比较直观的文章 下面给出一个demo. 使用自定义哈希和自定义比较器来使用unordered_map和map. 需要注意的是, unordered_map和map的key类型是const的, 即我们不能通过迭代器或结构化绑定等方式来修改key的值, 同时哈希函数的结构体实现需要添加const声明, 让const对象也可以访问. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#include &lt;cstddef&gt;#include &lt;functional&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;using namespace std;struct Point { int x, y; Point (int _x, int _y) : x(_x), y(_y) {} /* 按照 x从小到大排 */ bool operator &lt; (const Point&amp; p) const { return x &lt; p.x; } /* unordered_map 需要判断元素是否相同 */ bool operator == (const Point&amp; p) const { return p.x == x and p.y == y; }};/* 自定义hash函数 */struct HashPoint { size_t operator () (const Point&amp; p) const { auto str = to_string(p.x) + &quot;_&quot; + to_string(p.y); hash&lt;string&gt; _hs; return _hs(str); }};int main() { unordered_map&lt;Point, int, HashPoint&gt; cnt; Point a(1, 2); Point b(1, 2); Point c(2, 3); Point d(2, 3); ++ cnt[a]; ++ cnt[b]; ++ cnt[c]; ++ cnt[d]; // size = 2 cout &lt;&lt; &quot;cnt size = &quot; &lt;&lt; cnt.size() &lt;&lt; &quot;\\n&quot;; for (auto&amp; [k, v] : cnt) printf(&quot;x = %d, y = %d, cnt = %d\\n&quot;, k.x, k.y, v); cout &lt;&lt; &quot;======================\\n&quot;; map&lt;Point, int&gt; mp; ++ mp[a]; ++ mp[b]; ++ mp[c]; ++ mp[d]; for (auto&amp; [k, v] : mp) printf(&quot;x = %d, y = %d, cnt = %d\\n&quot;, k.x, k.y, v); /*使用*/ auto comp = [] (const Point&amp; a, const Point&amp; b) { return a.y &lt; b.y; }; map&lt;Point, int, decltype(comp)&gt; mpComp(comp); ++ mpComp[a]; ++ mpComp[b]; ++ mpComp[c]; ++ mpComp[d]; cout &lt;&lt; &quot;======================\\n&quot;; for (auto&amp; [k, v] : mpComp) printf(&quot;x = %d, y = %d, cnt = %d\\n&quot;, k.x, k.y, v); return 0;}/*cnt size = 2x = 2, y = 3, cnt = 2x = 1, y = 2, cnt = 2======================x = 1, y = 2, cnt = 2x = 2, y = 3, cnt = 2======================x = 1, y = 2, cnt = 2x = 2, y = 3, cnt = 2*/ 实验环境 Linux 20.04.1-Ubuntu g++ (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0","link":"/2022/05/10/cpp/%5Bcpp%5DSTL%E5%AE%B9%E5%99%A8%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"},{"title":"[LeetCode-周赛]297","text":"Rank : 218 / 5904Solved : 4/4 竞赛链接 计算应缴税款总额思路模拟. 按照题意, 从前到后模拟即可. Code12345678910111213141516class Solution {public: double calculateTax(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int sum) { double ans = 0.0; int prev = 0; for (auto&amp; num : nums) { int cur = min(num[0] - prev, sum); ans += cur * num[1] * 0.01; prev = num[0]; sum -= cur; } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(1)$ 网格中的最小路径代价思路动态规划: 1. 状态表示: 定义f[i][j]为走到(i, j)点时的最小代价. 答案即为最后一行的最小值. 2. 状态计算: 用当前行去更新下一行的状态. 即已知f[i][j], 去更新所有(i, j)能走到的位置(即下一行). $$ f[i + 1][k] = min(f[i + 1][k], f[i][j] + nums[i + 1][k] + cost[nums[i][j]][k]), \\ k \\in [0, m - 1]$$ Code123456789101112131415161718class Solution {public: int minPathCost(vector&lt;vector&lt;int&gt;&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; cost) { int n = nums.size(), m = nums[0].size(); vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m, 1e9)); for (int i = 0; i &lt; n - 1; i ++ ) for (int j = 0; j &lt; m; j ++ ) { if (i == 0) f[i][j] = nums[i][j]; for (int k = 0; k &lt; m; k ++ ) f[i + 1][k] = min(f[i + 1][k], f[i][j] + nums[i + 1][k] + cost[nums[i][j]][k]); } return *min_element(f[n - 1].begin(), f[n - 1].end()); }}; 复杂度分析 时间复杂度$O(N * M^2)$ 空间复杂度$O(N * M)$ 公平分发饼干思路DFS. 深搜剪枝. Code12345678910111213141516171819202122232425262728class Solution {public: int ans; int n; void dfs(int u, vector&lt;int&gt;&amp; cnt, int k, vector&lt;int&gt;&amp; nums) { int mx = *max_element(cnt.begin(), cnt.end()); if (u == n) { ans = min(ans, mx); return ; } if (mx &gt;= ans) return ; for (int i = 0; i &lt; k; i ++ ) { cnt[i] += nums[u]; dfs(u + 1, cnt, k, nums); cnt[i] -= nums[u]; } } int distributeCookies(vector&lt;int&gt;&amp; nums, int k) { this -&gt; n = nums.size(); ans = reduce(nums.begin(), nums.end()); vector&lt;int&gt; cnt(k, 0); dfs(0, cnt, k, nums); return ans; }}; 复杂度分析 时间复杂度$不会分析$ 空间复杂度$O(K)$ 公司命名思路枚举每一个字符串作为ideaA, 求合法的ideaB. 假设当前字符串为HaTa(Ha表示首字母). 那么能作为ideaB的首字符的选择是有限的, 假设ideaB的首字符为Hx, 那么HxTa一定没出现过. 这样就知道了所有可选的Hx. 现在的问题是: Hx的可选后缀Tx, 多少个HaTx是合法的. 这个问题可以用补集的思想做. 因为我们知道全集: 以Ha开头的字符串的个数; 以及其补集: 出现过多少个形如HaTx的字符串. 全集很好处理. 补集的话直观来看, 就是HxTx字符串中, 出现过多少个HaTx. 这个我们只需对每一个后缀处理出其可能的前缀首字母(26种可能), 然后这些前缀两两之间会对补集有1的贡献. Code123456789101112131415161718192021222324252627282930313233343536using LL = long long;class Solution {public: int cnt[26], sub[26][26]; long long distinctNames(vector&lt;string&gt;&amp; str) { memset(cnt, 0, sizeof(cnt)); memset(sub, 0, sizeof(sub)); unordered_map&lt;string, set&lt;int&gt;&gt; mp; for (auto&amp; s : str) { string tmp = s.substr(1); mp[tmp].insert(s[0]); cnt[s[0] - 'a'] ++; } for (auto&amp; [_, v] : mp) { for (auto&amp; a : v) for (auto&amp; b : v) sub[a - 'a'][b - 'a'] ++ ; } LL ans = 0; for (auto&amp; s : str) { string tmp = s.substr(1); int ha = s[0]; for (char hx = 'a'; hx &lt;= 'z'; hx ++ ) { if (mp[tmp].count(hx)) continue; int cur = cnt[hx - 'a'] - sub[hx - 'a'][ha - 'a']; ans += cur; } } return ans; }}; 复杂度分析 时间复杂度$O(M * M * N), M = 26$ 空间复杂度$O(M * N)$ 欢迎讨论指正","link":"/2022/06/12/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D297/"}],"tags":[{"name":"工具软件","slug":"工具软件","link":"/tags/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"字符串分割","slug":"字符串分割","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/"},{"name":"状态机","slug":"状态机","link":"/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"优先队列","slug":"优先队列","link":"/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"枚举","slug":"枚举","link":"/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"周赛","slug":"周赛","link":"/tags/%E5%91%A8%E8%B5%9B/"},{"name":"二分搜索","slug":"二分搜索","link":"/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"},{"name":"状态压缩","slug":"状态压缩","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"哈希表","slug":"哈希表","link":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"深度优先搜索","slug":"深度优先搜索","link":"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"平衡树","slug":"平衡树","link":"/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"递推","slug":"递推","link":"/tags/%E9%80%92%E6%8E%A8/"},{"name":"状态压缩动态规划","slug":"状态压缩动态规划","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"语言基础","slug":"语言基础","link":"/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"无锁队列","slug":"无锁队列","link":"/tags/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"},{"name":"进程通信","slug":"进程通信","link":"/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"},{"name":"匿名管道","slug":"匿名管道","link":"/tags/%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93/"},{"name":"命名管道","slug":"命名管道","link":"/tags/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93/"},{"name":"共享主存","slug":"共享主存","link":"/tags/%E5%85%B1%E4%BA%AB%E4%B8%BB%E5%AD%98/"},{"name":"生产者-消费者","slug":"生产者-消费者","link":"/tags/%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85/"},{"name":"八股文","slug":"八股文","link":"/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"AcWing Cup","slug":"AcWing-Cup","link":"/tags/AcWing-Cup/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"同步原语","slug":"同步原语","link":"/tags/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/"},{"name":"RAII","slug":"RAII","link":"/tags/RAII/"},{"name":"资源管理类","slug":"资源管理类","link":"/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB/"},{"name":"区间最值","slug":"区间最值","link":"/tags/%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC/"},{"name":"0-1BFS","slug":"0-1BFS","link":"/tags/0-1BFS/"},{"name":"enable_shared_from_this","slug":"enable-shared-from-this","link":"/tags/enable-shared-from-this/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"}],"categories":[{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"cpp","slug":"cpp","link":"/categories/cpp/"},{"name":"algo","slug":"algo","link":"/categories/algo/"},{"name":"LeetCode","slug":"algo/LeetCode","link":"/categories/algo/LeetCode/"},{"name":"周赛","slug":"algo/LeetCode/周赛","link":"/categories/algo/LeetCode/%E5%91%A8%E8%B5%9B/"},{"name":"每日一题","slug":"algo/LeetCode/每日一题","link":"/categories/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"系列合集","slug":"algo/LeetCode/系列合集","link":"/categories/algo/LeetCode/%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"ConcurrencyAndDistribution","slug":"ConcurrencyAndDistribution","link":"/categories/ConcurrencyAndDistribution/"},{"name":"残酷八股文","slug":"残酷八股文","link":"/categories/%E6%AE%8B%E9%85%B7%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"AcWing","slug":"algo/AcWing","link":"/categories/algo/AcWing/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"随笔杂谈","slug":"随笔杂谈","link":"/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88/"}]}