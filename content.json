{"pages":[{"title":"","text":"不积跬步, 无以至千里; 不积小流, 无以成江海。 本blog用来记录我自己的学习过程和感悟, 欢迎关注。","link":"/about/index.html"},{"title":"","text":"申请友链须知 本站友链信息如下，按如下格式提供申请信息： 网站图标：https://csjsss.github.io/img/tx.JPG 网站名称：Jsss 网站地址：https://csjsss.github.io/ 网站简介：BIT-CS硕士在读 加载中...","link":"/friend/index.html"},{"title":"有什么想对我说的, 就留个言吧~","text":"","link":"/message/index.html"}],"posts":[{"title":"Windows下实用工具软件合集","text":"整理分享一下平时我在Windows下使用的实用工具软件. Everything: 文件搜索神器Everything是一款简洁轻便的文件搜索软件. 特性 界面干净简洁 快速搜索 轻量级 使用示例 PowerToys: 微软开源实用工具PowerToys是Windows下一组实用工具的集合. 由微软官方发布的免费工具集合. 包含PowerToys Run、键盘管理器(键映射)和文件资源管理器(文件预览)等多种实用工具.官方文档与教程 特性 免费开源 微软官方开发维护 使用示例 Zeal: 离线文档浏览器Zeal是针对软件开发人员的离线文档浏览器. 特性 跨平台 多语言支持 使用示例 mathpix snipping tool: 公式识别软件通过mathpix snipping tool可以很方便的截图论文中的公式, 转化为LaTex可编辑文本, 能够显著提高读写论文效率. 特性 界面简约 快速高效 使用示例 WizTree: 磁盘空间分析器WiZTree是一款高效的磁盘空间扫描分析软件, 扫描速度极快, 界面简洁易操作. 特性 界面简约、中文界面 快速高效 文件名搜索 ScreenToGif: 高效的Gif制作器ScreenToGif是便捷的制作Gif软件的工具, 上述所有演示Gif均由该软件制作。选中屏幕上的指定区域, 轻松录制一段Gif, 并且编辑的功能完善强大. 功能强大 简洁高效","link":"/2021/11/18/Windows/Windows%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%90%88%E9%9B%86/"},{"title":"[cpp]便捷的字符串分割方法","text":"前言不像python的str提供的内置split方法一样方便的进行字符串分割，c++的string模板库没有直接提供分割字符串的成员方法。偶然在看《c++prime》时看到string模板库提供getline方法, 利用方法可以实现自定义分隔符分割字符串。 使用getline进行分割getline函数接受三个参数，分别是input(the stream to get data from), str(the string to put the data into), delim(the delimiter character) 。该函数返回值是input。 其中input是istream类型，比如cin, istringstream等继承自istream的类，分割符为char型字符。 为了获取带空格的字符串，一般使用getline(cin, str)进行读取字符串。读取待分割字串到str中后，我们需要用其实例化一个istringstream作为getline的input才能完成分割。 分割过程中需要注意一点: 若待分割字符串中包含连续的分割字符，这种情况会得到空字符串。多数情况下我们不期望得到空字符串，因此需要判断分割得到的字符串是否为空。 DemoCode123456789101112131415161718#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;int main() { string line, word; getline(cin, line); istringstream input(line); while (getline(input, word, ' ')) { if (!word.empty()) cout &lt;&lt; &quot;word : &quot; &lt;&lt; word &lt;&lt; endl; } return 0;} 结果 欢迎讨论指正","link":"/2021/10/27/cpp/%5Bcpp%5D%E4%BE%BF%E6%8D%B7%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95/"},{"title":"[LeetCode]买卖股票合集","text":"简单整理一下LeetCode上买卖股票系列题目. 包含买卖股票的最佳时机、买卖股票的最佳时机 II、买卖股票的最佳时机 III、买卖股票的最佳时机 IV、最佳买卖股票时机含冷冻期和买卖股票的最佳时机含手续费共六题. 买卖股票的最佳时机题目描述给出数组price, 其中price[i]表示第i天股票的价格. 只能选择某一天买入然后之后的某一天卖出, 求最大利润. 思路 贪心. 如果在第i天卖出, 那么一定希望买入的时候价格最低, 因此使用维护一个前缀最小值即可. 状态机动态规划 状态机关心的时当前处于何种状态, 以及所有可能的状态转移和条件 动态规划 状态定义 f[i][0][0]: 表示第i天没持有股票, 且没完成一次交易的最大利润(一定为0). f[i][1][0]: 表示第i天持有股票, 且没完成一次交易的最大利润. f[i][0][1]: 表示第i天没持有股票, 且完成一次交易的最大利润. f[i][1][1]: 表示第i天持有股票, 且完成一次交易的最大利润. 状态转移 $f[i][0][0] = f[i - 1][0][0] = 0$ $f[i][1][0] = max(f[i - 1][1][0], -price[i])$, 表示要么是第i - 1天持有, 要么是第i天买入. $f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + price[i])$, 表示要么是第i - 1天完成一次交易, 要么是第i天卖出后完成了一次交易. $f[i][1][1] = max(f[i - 1][1][1], f[i - 1][0][1] - price[i])$, 表示要么是第i - 1天持有, 要么是第i天买入. 使用三维的原因是必须保证只能完成一次交易, 因此需要对状态进行拆分. 状态的表示是持有股票或不持有股票, 而买入卖出是动作, 是状态转移的条件. 状态初始化中, 由于第一天无法完成一次交易, 因此$f[1][0][1]=f[1][1][1]=-INF$. 由于$f[i][1][1]$无法转移到其他任何状态, 而且其也不会是答案, 因此其为无效状态, 无需计算. Code1234567891011121314151617/* 贪心思路, 记录前缀最小值即可. 时间复杂度O(N) 空间复杂度O(1)*/class Solution {public: int maxProfit(vector&lt;int&gt;&amp; p) { // ans至少为0, 即可以不买不卖 int ans = 0, mn = p[0]; for (int i = 1; i &lt; (int)p.size(); i ++ ){ ans = max(ans, p[i] - mn); mn = min(mn, p[i]); } return ans; }}; 1234567891011121314151617// 状态机动态规划const int N = 1e5 + 5;class Solution {public: int f[N][2][2]; int maxProfit(vector&lt;int&gt;&amp; p) { int n = p.size(); f[1][0][1] = f[1][1][1] = -1e9; f[1][1][0] = -p[0]; for (int i = 2; i &lt;= n; i ++ ) { f[i][0][0] = f[i - 1][0][0]; f[i][1][0] = max(f[i - 1][1][0], -p[i - 1]); f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + p[i - 1]); } return max(f[n][0][1], f[n][0][0]); }}; 复杂度分析(状态机动态规划) 时间复杂度$O(N)$ 空间复杂度$O(N)$ 买卖股票的最佳时机 II题目描述基本题意与第一题相同, 只是多了个条件: 可以完成任意交易. 思路 本题无需关注交易次数, 只需关注在每个时间点所处的状态以及所有可能的转移及条件, 因此简单修改第一题状态机动态规划做法即可. 状态机动态规划 状态定义: f[i][0]: 表示第i天没持有股票时候的最大收益 f[i][1]: 表示第i天持有股票时候的最大收益 状态转移: $f[i][0] = max(f[i - 1][0], f[i - 1][1] + price[i])$, 表示第i天不持有可以从第i - 1天不持有或者第i - 1天持有但第i天卖掉转移而来. $f[i][1] = max(f[i - 1][1], f[i - 1][0] - price[i])$, 表示第i天持有可以从第i - 1天持有或者第i - 1天不持有但第i天买入转移而来. 最终答案: f[n][0] Code12345678910111213class Solution {public: int maxProfit(vector&lt;int&gt;&amp; p) { int n = p.size(); vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(2, 0)); f[0][0] = 0, f[0][1] = -p[0]; for (int i = 1; i &lt; n; i ++ ){ f[i][0] = max(f[i - 1][0], f[i - 1][1] + p[i]); f[i][1] = max(f[i - 1][1], f[i - 1][0] - p[i]); } return f[n - 1][0]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 买卖股票的最佳时机 III题目描述基本题意与第一题相同, 只是多了个条件: 最多完成两笔交易. 思路 第一题解法中使用三维状态来标记完成交易的次数, 本题只是第一题的简单扩展, 在第一题基础上稍加修改即可. 状态机动态规划 状态定义: $f[i][0][0]$: 表示第i天不持有股票, 且完成0笔交易时的最大收益(一定为0, 无效状态) $f[i][1][0]$: 表示第i天持有股票, 且完成0笔交易时的最大收益 $f[i][0][1]$: 表示第i天不持有股票, 且完成1笔交易时的最大收益 $f[i][0][2]$: 表示第i天不持有股票, 且完成2笔交易时的最大收益 $f[i][1][1]$: 表示第i天持有股票, 且完成1笔交易时的最大收益 $f[i][1][2]$: 表示第i天持有股票, 且完成2笔交易时的最大收益(无效状态) 状态转移: $f[i][1][0] = max(f[i - 1][1][0], f[i - 1][0][0] - p[i])$, 表示第i天持有可以从第i - 1天持有或者第i - 1天不持有但第i天买入转移而来. $f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + p[i])$, 转移同上, 要么前一天同状态转移过来, 要么前一天某状态通过买入/卖出转移过来. $f[i][0][2] = max(f[i - 1][0][2], f[i - 1][1][1] + p[i])$ $f[i][1][1] = max(f[i - 1][1][1], f[i - 1][0][1] - p[i])$ 由于第一天无法完成交易, 因此需要初始化第一天的某些状态为非法状态. Code12345678910111213141516171819202122232425const int N = 1e5 + 5;class Solution {public: int f[N][2][3]; int maxProfit(vector&lt;int&gt;&amp; p) { int n = p.size(); // 初始化 // 第一天持有股票 f[1][1][0] = -p[0]; // 第一天无法完成交易 f[1][0][1] = f[1][0][2] = f[1][1][1] = f[1][1][2] = -1e9; for (int i = 2; i &lt;= n; i ++ ) { int cur = p[i - 1]; // 第i天有股票, 交易了0次 f[i][1][0] = max(f[i - 1][1][0], - cur); // 第i天无股票, 交易了1次 f[i][0][1] = max(f[i - 1][0][1], f[i - 1][1][0] + cur); // 第i天无股票, 交易了2次 f[i][0][2] = max(f[i - 1][0][2], f[i - 1][1][1] + cur); // 第i天有股票, 交易了1次 f[i][1][1] = max(f[i - 1][1][1], f[i - 1][0][1] - cur); } return max({f[n][0][0], f[n][0][1], f[n][0][2]}); }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 买卖股票的最佳时机 IV题目描述基本题意与第一题相同, 只是多了个条件: 最多完成k笔交易. 思路 第一题状态机动态规划解法与第三题的推广版本, 完全一致的思路, 照抄即可. 状态机动态规划 状态定义: $f[i][0][j]$: 表示第i天不持有股票, 且完成j笔交易时的最大收益 $f[i][1][j]$: 表示第i天持有股票, 且完成j笔交易时的最大收益 状态转移: $f[i][0][j] = max(f[i - 1][0][j], f[i - 1][1][j - 1] + p[i])$ $f[i][1][j] = max(f[i - 1][1][j], f[i - 1][0][j] - p[i])$ Code1234567891011121314151617181920212223const int N = 1010, K = 110;class Solution {public: int f[N][2][K]; int maxProfit(int k, vector&lt;int&gt;&amp; p) { memset(f, -0x3f, sizeof(f)); int n = p.size(); for (int i = 0; i &lt;= n; i ++ ) f[n][0][0] = 0; for (int i = 1; i &lt;= n; i ++ ) { int cur = p[i - 1]; f[i][1][0] = max(f[i - 1][1][0], -cur); for (int j = 1; j &lt;= k; j ++ ) { f[i][0][j] = max(f[i - 1][0][j], f[i - 1][1][j - 1] + cur); f[i][1][j] = max(f[i - 1][1][j], f[i - 1][0][j] - cur); } } int ans = 0; for (int i = 1; i &lt;= k; i ++ ) ans = max(ans, f[n][0][i]); return ans; }}; 复杂度分析 时间复杂度$O(N * K)$ 空间复杂度$O(N * K)$ 最佳买卖股票时机含冷冻期题目描述基本题意与第一题相同, 只是多了条件: 可以买卖任意次, 但卖出股票后，无法在第二天买入股票 (即冷冻期为 1 天)。 思路 基本为第二题的扩展. 考虑如何将冷冻期为 1 天用状态表达出来即可. 状态机动态规划 状态定义: $f[i][0]$: 表示第i天不持有股票, 且无冷冻期, 时候的最大收益. $f[i][1]$: 表示第i天不持有股票, 且在冷冻期(第i - 1天卖出), 时候的最大收益. $f[i][2]$: 表示第i天持有股票时候的最大收益 状态转移: $f[i][0] = max(f[i - 1][0], f[i - 1][1])$ $f[i][1] = f[i - 1][2] + p[i]$ $f[i][2] = max(f[i - 1][2], f[i - 1][0] - p[i])$ Code12345678910111213141516class Solution {public: int maxProfit(vector&lt;int&gt;&amp; p) { int n = p.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(3, 0)); // 初始化: f[1][1] = -1e9; f[1][2] = -p[0]; for (int i = 2; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][2] + p[i - 1]; f[i][2] = max(f[i - 1][2], f[i - 1][0] - p[i - 1]); } return max(f[n][0], f[n][1]); }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 买卖股票的最佳时机含手续费题目描述基本题意与第一题相同, 只是多了条件: 可以买卖任意次, 且一次买入卖出需要支付手续费。 思路 第二题的简单扩展. 卖出阶段支付手续费即可. 状态机动态规划 状态定义: $f[i][0]$: 表示第i天不持有股票时候的最大收益. $f[i][1]$: 表示第i天持有股票时候的最大收益. 状态转移: $f[i][0] = max(f[i - 1][0], f[i - 1][1] + p[i] - fee)$ $f[i][1] = max(f[i - 1][1], f[i - 1][0] - p[i])$ Code123456789101112131415const int N = 1e5 + 5;class Solution {public: int f[N][2]; int maxProfit(vector&lt;int&gt;&amp; p, int fee) { int n = p.size(); f[1][1] = -p[0]; for (int i = 2; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1] + p[i - 1] - fee); f[i][1] = max(f[i - 1][1], f[i - 1][0] - p[i - 1]); } return f[n][0]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 参考资料 B站yxc 欢迎讨论指正","link":"/2021/11/23/algo/LeetCode/%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/%5BLeetCode%5D%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E5%90%88%E9%9B%86/"},{"title":"[LeetCode]打家劫舍合集","text":"简单整理一下LeetCode上打家劫舍系列题目, 该系列作为状态机动态规划的入门题相当的好. 打家劫舍题目描述有一行非负数, 不能选连续两个数, 求选的数之和的最大值. 思路整体思路上使用状态机的思路解决. 状态机关心的是当前处于何种状态, 所有可能的状态转移方式与条件. 结合本题, 我们使用状态机动态规划解决本题. 动态规划 状态定义: $f[i][0]$表示考虑了前i个数, 且不拿i号位置的情况下取得的最大价值 $f[i][1]$表示考虑了前i个数, 且拿i号位置的情况下取得的最大价值 状态转移: 若不拿i号位置, 则i - 1位置可拿可不拿, 因此$f[i][0] = max(f[i - 1][0], f[i - 1][1])$ 若拿i号位置, 则i - 1位置必不能被拿, 因此$f[i][1] = f[i - 1][0] + nums[i]$ 最后的答案为$max(f[n][0], f[n][1])$ 任何一种拿与不拿的决策, 均对应于有限状态机中不同状态之间的一条转移边. Code12345678910111213// 上述解法class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(2, 0)); for (int i = 1; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][0] + nums[i - 1]; } return max(f[n][0], f[n][1]); }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$(注意到当前状态只依赖于上一位置状态, 因此可以使用两个变量保存上一位置状态, 优化成$O(1)$) 打家劫舍 II题目描述基本题意与第一题类型, 只不过多了一个限制: 首尾不能同时拿. 思路依照第一题的思路, 我们继续使用状态机动态规划解决. 只不过需要多一维的状态, 用于指示1号位置是否被拿, 因为这关系到最后一个位置的转移条件. 动态规划 状态定义: $f[i][0][0]$表示i号位1号位都没拿. $f[i][0][1]$表示i号位没拿, 1号位拿了. $f[i][1][0]$表示i号位拿了, 1号位没拿. $f[i][1][1]$表示i号位1号位都拿了. 状态转移： 对于$f[i][0][0]$, 则$i - 1$位无限制, 因此$f[i][0][0] = max(f[i - 1][1][0], f[i - 1][0][0])$. 对于$f[i][0][1]$, 则$i - 1$位无限制, 因此$f[i][0][1] = max(f[i - 1][1][1], f[i - 1][0][1])$. 对于$f[i][1][0]$, 则$i - 1$位不能选, 因此$f[i][1][0] = f[i - 1][0][0] + nums[i - 1]$. 对于$f[i][1][1]$, 则$i - 1$位不能选, 因此$f[i][1][1] = f[i - 1][0][1] + nums[i - 1]$.对于i = n: 由于1号位和n号位不能同时选, 因此转移需要单独考虑. Code12345678910111213141516171819class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n + 1, vector&lt;vector&lt;int&gt;&gt;(2, vector&lt;int&gt;(2, 0))); f[1][1][1] = nums[0]; for (int i = 2; i &lt; n; i ++ ) { f[i][0][0] = max(f[i - 1][1][0], f[i - 1][0][0]); f[i][0][1] = max(f[i - 1][1][1], f[i - 1][0][1]); f[i][1][0] = f[i - 1][0][0] + nums[i - 1]; f[i][1][1] = f[i - 1][0][1] + nums[i - 1]; } // 单独考虑n号位 f[n][0][0] = max(f[n - 1][1][0], f[n - 1][0][0]); f[n][0][1] = max(f[n - 1][1][1], f[n - 1][0][1]); f[n][1][0] = f[n - 1][0][0] + nums[n - 1]; return max({f[n][0][0], f[n][0][1], f[n][1][0]}); }}; 123456789101112131415161718192021222324252627282930/* 这里简单提一下另外一种做法, 类似于第一题. 考虑到 1 和 n 不能同时被拿, 因此最优解有以下可能 1. 拿1不拿n 2. 拿n不拿1 3. 1和n不拿 因此可以考虑在1 -&gt; n - 1上和 2 -&gt; n上分别使用第一题的解法做一遍. 因为求解的是最大值, 这两个子问题有所重复的无所谓的(他们都包含第三种情况), 只需不遗漏的计算所有可能即可.*/class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(), ans = 0; if (n == 1) return nums.back(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(2, 0)); // 1 -&gt; n - 1 for (int i = 1; i &lt; n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][0] + nums[i - 1]; } ans = max({ans, f[n - 1][0], f[n - 1][1]}); // 2 -&gt; n f[1][0] = f[1][1] = 0; for (int i = 2; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][0] + nums[i - 1]; } return max({ans, f[n][0], f[n][1]}); }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 打家劫舍 III思路状态机结合树形动态规划的题目.使用树形动态规划解决. 树形动态规划 状态定义: $f[u][0]$表示考虑以u为根的子树中, 且u没被选的情况下最大价值. $f[u][1]$表示考虑以u为根的子树中, 且u被选的情况下最大价值. 状态计算 对于$f[u][0]$, 由于没有拿父节点u, 因此对于任意子节点v, 都可以考虑拿他和不拿他, 因此有转移:$$ f[u][0] = \\sum_{v \\in son[u]}max(f[v][0], f[v][1])$$ 对于$f[u][1]$, 由于拿了父节点u, 因此对于任意子节点v, 都不能拿他, 因此有转移:$$ f[u][1] = \\sum_{v \\in son[u]} f[v][0]$$ Code123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: unordered_map&lt;TreeNode*, vector&lt;int&gt;&gt; f; void dfs(TreeNode* u) { f[u] = vector&lt;int&gt;(2, 0); f[u][1] = u -&gt; val; for (auto&amp; son : {u -&gt; left, u -&gt; right}) { if (son == nullptr) continue; dfs(son); f[u][0] += max(f[son][0], f[son][1]); f[u][1] += f[son][0]; } } int rob(TreeNode* root) { dfs(root); return max(f[root][0], f[root][1]); }}; 复杂度分析 时间复杂度$O(N)$: DFS过程中, 每个节点只会被遍历一次 空间复杂度$O(N)$ 参考资料 B站yxc 欢迎讨论指正","link":"/2021/11/19/algo/LeetCode/%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/%5BLeetCode%5D%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%90%88%E9%9B%86/"},{"title":"[LeetCode]跳跃游戏合集","text":"简单整理一下LeetCode上跳跃游戏系列题目. 包含跳跃游戏、跳跃游戏II、跳跃游戏III、跳跃游戏IV、跳跃游戏V、跳跃游戏VI、跳跃游戏VII共七题. 跳跃游戏题目描述开始位于1号点, 每次在i号点最远可以跳跃nums[i]单位距离, 判断能否跳到n号点. 思路 我们可以把每个下标看成一个点, 每次在i号点跳跃认为是从i连边到j, 且$j\\in [max(1, i - nums[i]),\\ min(n, i + nums[i])]$. 这样问题转化成判断是否存在至少一条从1号点到n号点的路径, 即1号点与n号点是否联通. 暴力使用BFS等算法求解的时候, 正确性是毫无疑问的, 但时间复杂度过高$O(N^2)$, 会TLE. 暴力时间复杂度高的原因是: 每个点会被遍历多次, 如果优化每个点被遍历的次数, 那么问题就得到了解决. 结合题意, 有以下观察: 如果当前位于i号点, 那么1 - i之间的所有点已经可达了(即被遍历过了). 假设是从j点跳到了i点($j &lt; i$), 那么j - i之间的所有点可以被j遍历到, 问题规模减小到1 - j, 归纳下去即可证明. 有了观察1, 当我们位于i号点的时候, 只需关心它向右能跳到的点. i向右最远能跳到$R = min(n, i + nums[i])$. 我们从R倒着向i遍历: 若该点没被访问过, 置为True, 继续向前遍历. 若该点已经被访问过了, 则可由观察1得到, 该点左边的点全被访问过, 退出循环即可. 最终对于每个点, 我们至多遍历一次. Code12345678910111213141516// 写法1class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;bool&gt; f(n, false); f[0] = true; for (int i = 0; i &lt; n; i ++ ) if (f[i]){ int j = min(n - 1, nums[i] + i); while (f[j] == false) f[j --] = true; } return f[n - 1]; }}; 123456789101112131415161718192021/* 写法2:稍微优化上述写法 记录可行的跳的最远的位置 Mx 是哪 利用观察1, 只要当前点i &lt;= Mx, 则当前点一定可达.*/class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;bool&gt; f(n, false); f[0] = true; int Mx = nums[0]; for (int i = 1; i &lt; n; i ++ ) { if (Mx &gt;= i) { f[i] = true; Mx = max(Mx, i + nums[i]); } } return f[n - 1]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 跳跃游戏 II题目描述开始位于1号点, 每次在i号点最远可以跳跃nums[i]单位距离, 判断跳到n号的最少跳跃次数(保证可以到达). 思路有了第一题的分析过程, 这题可以很自然的使用第一题的分析思路: 只需求1号点到n号点的最短路. 利用BFS的性质: 每个点第一次被遍历的时候一定是该点的最短距离. 用第一题思路实现即可. Code12345678910111213141516// 解法1: 上述思路的实现class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n, -1); f[0] = 0; for (int i = 0; i &lt; n; i ++ ) { int R = min(n - 1, i + nums[i]); while (f[R] == -1) f[R --] = f[i] + 1; } return f[n - 1]; }}; 12345678910111213141516171819202122232425262728293031/* 解法2： 简单提一下另外一种思路: dp或者最短路的想法 使用优先队列记录所有可达的点的信息: 最短距离以及它所能跳到的最远点 当遍历到i的时候, 贪心的从优先队列中取最短距离最小的点： 若它能到到达i, 则更新i 否则直接弹出优先队列, 因为它不可能更新i之后的任意一个点. 这样每个点最多 入/出 优先队列一次. 时间复杂度为 O(N * logN) 空间复杂度为 O(N)*/class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { int n = size(nums); vector&lt;int&gt; f(n, 1e9); priority_queue&lt;pair&lt;int, int&gt;&gt; heap; heap.emplace(0, nums[0]); f[0] = 0; for (int i = 1; i &lt; n; i ++ ){ auto [t, ed] = heap.top(); while (heap.size() &amp;&amp; ed &lt; i){ heap.pop(); t = heap.top().first; ed = heap.top().second; } f[i] = -t + 1; heap.emplace(-f[i], i + nums[i]); } return f[n - 1]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 跳跃游戏 III题目描述开始位于start号点, 每次在i号点可以跳到i + nums[i]或i - nums[i], 判断能否跳到nums[k] = 0的某个点. 思路有了前面题目的分析, 这题就是简单的BFS. 每个点最多出去两条边, 暴力BFS即可. Code1234567891011121314151617181920212223242526class Solution {public: bool canReach(vector&lt;int&gt;&amp; arr, int st) { int n = arr.size(); vector&lt;bool&gt; f(n, false); queue&lt;int&gt; qu; f[st] = true; qu.push(st); while (qu.size()) { auto t = qu.front(); qu.pop(); if (t + arr[t] &lt; n and t + arr[t] &gt;= 0 and f[t + arr[t]] == false) f[t + arr[t]] = true, qu.push(t + arr[t]); if (t - arr[t] &lt; n and t - arr[t] &gt;= 0 and f[t - arr[t]] == false) f[t - arr[t]] = true, qu.push(t - arr[t]); } bool flag = false; for (int i = 0; i &lt; n; i ++ ) { if (arr[i] == 0 and f[i]) flag = true; } return flag; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 跳跃游戏 IV题目描述开始位于1号点, 每次在i号点可以跳到i + 1、i - 1、j(满足nums[i] == nums[j]), 求解跳到n号点的最短步数. 思路题目求解的是最短路, 自然就往最短路算法上想(BFS、Dijkstra等). 由于本题边权均为1, 因此考虑使用BFS算法求解. 由题目可知, 所有值相同的点之间存在一条代价为1的边. 因此我们先使用哈希表得到所有值相同的点, 接着BFS即可. 注意优化的一点: BFS第一次遍历到的时候, 其最短路就已经确定了. 因此我们遍历了一遍某一个值相同的集合后, 直接从哈希表删除该集合即可. Code12345678910111213141516171819202122232425262728293031const int INF = 1e8;class Solution {public: int minJumps(vector&lt;int&gt;&amp; arr) { unordered_map&lt;int, vector&lt;int&gt;&gt; mp; int n = arr.size(); for (int i = 0; i &lt; n; i ++ ) { int c = arr[i]; mp[c].push_back(i); } vector&lt;int&gt; f(n, INF); queue&lt;int&gt; qu; f[0] = 0; qu.push(0); while (qu.size()) { auto t = qu.front(); qu.pop(); if (t + 1 &lt; n and f[t + 1] == INF) f[t + 1] = f[t] + 1, qu.push(t + 1); if (t - 1 &gt;= 0 and f[t - 1] == INF) f[t - 1] = f[t] + 1, qu.push(t - 1); for (auto&amp; c : mp[arr[t]]) { if (f[c] == INF) f[c] = f[t] + 1, qu.push(c); } mp.erase(arr[t]); } return f[n - 1]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 跳跃游戏 V题目描述在i号点可以跳到j号的要求是: arr[i] &gt; arr[j] $abs(i - j) &lt;= d$ $i - j$ 之间除i以外的点的值均小于$arr[i]$ 可以从任意点开始, 求解最多能跳多少个点. 思路 观察到数据范围为1000, 因此使用$O(N^2)$的算法求解即可. 依然利用前面题目的思路, 将每个下标视作一个点. i号点能跳到j号点, 则认为存在i指向j的一条有向边. 关键的约束条件为$arr[i] &gt; arr[j]$, 这样的话构建出的图一定为有向无环图(DAG). 问题转化成求有向无环图上的一条最长路径. 因为存在拓扑序, 因此按照序列递推(动态规划, DP)求解即可. 定义f[u]为走到u点时的最大值. 若存在有向边$v \\rightarrow u$, 则有: $$f[u] = max(f[u], f[v] + 1)$$ 因为按照拓扑序的顺序递推, 因此当计算u点时, 其所依赖的点v已经全部被计算过了, 保证了正确性. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {public: int maxJumps(vector&lt;int&gt;&amp; arr, int d) { int n = arr.size(); vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, 0)); vector&lt;int&gt; in(n, 0), f(n, 1); // O(n^2)预处理有向边 for (int i = 0; i &lt; n; i ++ ) { // L for (int j = i - 1, Mx = arr[i] - 1; j &gt;= max(0, i - d); j -- ) { Mx = max(Mx, arr[j]); if (Mx &gt;= arr[i]) break; g[i][j] = 1; in[j] ++ ; } // R for (int j = i + 1, Mx = arr[i] - 1; j &lt;= min(n - 1, i + d); j ++ ) { Mx = max(Mx, arr[j]); if (Mx &gt;= arr[i]) break; g[i][j] = 1; in[j] ++ ; } } // 拓扑排序 + 递推(DP) queue&lt;int&gt; qu; for (int i = 0; i &lt; n; i ++ ) { if (in[i] == 0) qu.push(i); } while (qu.size()) { auto t = qu.front(); qu.pop(); for (int i = 0; i &lt; n; i ++ ) { // t 能走到 i 点 if (g[t][i]) { f[i] = max(f[i], f[t] + 1); if (-- in[i] == 0) qu.push(i); } } } int ans = 0; for (int i = 0; i &lt; n; i ++ ) ans = max(ans, f[i]); return ans; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(N)$ 跳跃游戏 VI题目描述开始位于1号点, 每次最多往前跳k步, 求跳到n时的最大得分(最大数字之和). 思路 动态规划: 状态表示: 定义f[i]为走到i点时的最大得分. 答案即位f[n]. 状态计算：依据题目要求, 最多跳k步, 因此 $$ f[i] = max(f[j] + nums[i]), \\ j \\in [max(1, i - k), i - 1]$$ 朴素状态转移复杂度是$O(K)$, 会超时. 注意到转移要求的是滑动窗口内的最大值. 因此可以利用单调队列或优先队列(类似第二题解法2)优化. Code1234567891011121314151617181920class Solution {public: int maxResult(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;int&gt; f(n, 0); deque&lt;int&gt; dq; for (int i = 0; i &lt; n; i ++ ) { if (dq.size() and i - dq.front() &gt; k) dq.pop_front(); f[i] = nums[i]; if (dq.size()) f[i] = nums[i] + f[dq.front()]; while (dq.size() and f[dq.back()] &lt; f[i]) dq.pop_back(); dq.push_back(i); } return f[n - 1]; }}; 复杂度分析 时间复杂度$O(N)$(单调队列)、$O(N * logN)$(优先队列) 空间复杂度$O(N)$ 跳跃游戏 VII题目描述开始位于1号点, 每次向前跳的距离有限制, 判断能否跳到n号点. 思路 使用动态规划解决. 定义f[i]为是否能够跳到i位置, 只需判断是否存在$j \\in [i - maxJump, i - minJump]$, 使得$f[j] = True$成立. 为了快速判断是否存在j, 使用前缀和的思想. 记$s[i] = \\sum_{j = 0}^{i}f[i]$. 这样每次只需判断是否有$s[i - minJump] - s[i - maxJump - 1] &gt; 0$成立即可. Code12345678910111213141516class Solution {public: bool canReach(string str, int Mn, int Mx) { int n = str.size(); vector&lt;int&gt; f(n + 1, 0), s(n + 1, 0); f[1] = s[1] = 1; for (int i = 2; i &lt;= n; i ++ ) { if (str[i - 1] == '0') { if (s[max(0, i - Mn)] - s[max(0, i - Mx - 1)]) f[i] = 1; } s[i] = s[i - 1] + f[i]; } return f[n]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$","link":"/2021/11/17/algo/LeetCode/%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/%5BLeetCode%5D%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E5%90%88%E9%9B%86/"},{"title":"[LeetCode-1181]使数组严格递增","text":"原题链接 题目描述给定两个数组, 计算使得数组A严格递增的操作次数。 一次操作定义为: 选数组B任意一个数, 替换数组A任意一个数。 约定 arr1数组认为是数组A, 其长度为n arr2数组认为是数组B, 其包含不重复的元素个数为m 数组下标均从1开始 思路 一些观察: 数组B中的重复数是没有用的. 如果使用数组B中的重复数, 要么导致数组A不严格单调递增(操作到了不同位置), 要么导致操作次数增加(操作到了同一位置). 数组B的顺序是无所谓的. 问题转化 有了上述观察, 我们可以将问题首先进行转化. 首先将数组B中的重复元素去掉, 并对数组B排序, 记为$B’$. 这样问题可以转化成: 从数组$A$和数组$B’$(严格单调递增)中找到一条长度为$n$且严格单调递增的路线, 且路线上从A跳到B'的次数最少 转化后的问题可以使用动态规划来解决 动态规划 状态表示: $f[i][j][0]$:表示路线走了长度i, 考虑了数组$B’$的前j个数, 且最后走到数组$A$的i位置上. $f[i][j][1]$:表示路线走了长度i, 考虑了数组$B’$的前j个数, 且最后走到数组$B’$的j位置上. 状态计算: 根据定义首先有: $f[i][j][0]$ = $f[i][j - 1][0]$ 若$A[i] &gt; A[i - 1]$, 则有$f[i][j][0]$ = $f[i - 1][j][0]$ 若 $A[i] &gt; B’[j]$, 则有$f[i][j][0]$ = $f[i - 1][j][1]$ 对于$f[i][j][1]$: 若$B’[j] &gt; A[i - 1]$, 则有$f[i][j][1]$ = $f[i - 1][j - 1][0] + 1$. 表示第i步从$A$数组的i - 1位置跳到了$B’$的j位置 若$B’[j] &gt; B[j - 1]$, 则有$f[i][j][1]$ = $f[i - 1][j - 1][1] + 1$. 表示第i步从$B’$数组的j - 1位置跳到了$B’$的j位置 最后的答案 若最后一步在$A$数组上, 则答案为$f[n][m][0]$. 若最后一步在$B’$数组上, 枚举$f[n][j][1]$, 其中$j\\in[0, m)$. Code1234567891011121314151617181920212223242526272829303132333435363738const int N = 2010, INF = 0x3f3f3f3f;class Solution {public: int f[N][N][2]; int makeArrayIncreasing(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) { memset(f, 0x3f, sizeof(f)); sort(arr2.begin(), arr2.end()); arr2.resize(unique(arr2.begin(), arr2.end()) - arr2.begin()); int n = arr1.size(), m = arr2.size(); for (int i = 0; i &lt;= m; i ++ ) { f[0][i][0] = f[1][i][0] = 0; if (i) f[1][i][1] = 1; } for (int i = 2; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) { f[i][j][0] = f[i][j - 1][0]; if (arr1[i - 1] &gt; arr1[i - 2]) f[i][j][0] = min(f[i][j][0], f[i - 1][j][0]); if (arr1[i - 1] &gt; arr2[j - 1]) f[i][j][0] = min(f[i][j][0], f[i - 1][j][1]); if (arr2[j - 1] &gt; arr1[i - 2]) f[i][j][1] = f[i - 1][j - 1][0] + 1; if (j &gt;= 2 and arr2[j - 1] &gt; arr2[j - 2]) f[i][j][1] = min(f[i][j][1], f[i - 1][j - 1][1] + 1); } int ans = INF; for (int i = 1; i &lt;= m; i ++ ) ans = min({ans, f[n][i][0], f[n][i][1]}); if (ans == INF) ans = -1; return ans; }}; 复杂度分析 时间复杂度$O(n^2)$ 空间复杂度$O(n^2)$ 欢迎讨论指正","link":"/2021/11/11/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-1181%5D%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/"},{"title":"[LeetCode-1218]最长定差子序列","text":"原题链接 题目描述求数组中最长的等差子序列的长度, 且公差为定值 思路 因为公差为定值, 因此当子序列最后一个数确定时, 倒数第二个数一定是确定的, 我们可以使用一个数来代表所有以倒数第二个数为结尾的最长等差子序列. 使用动态规划解决： 状态表示: $f[i]$表示以i为结尾的最长的等差子序列 状态转移: $f[i] = f[i - d] + 1$ Code123456789101112class Solution {public: int longestSubsequence(vector&lt;int&gt;&amp; arr, int d) { unordered_map&lt;int, int&gt; f; int ans = 0; for (auto&amp; c : arr) { f[c] = 1 + f[c - d]; ans = max(ans, f[c]); } return ans; }}; 复杂度分析 时间复杂度$O(n)$ 空间复杂度$O(n)$ 欢迎讨论指正","link":"/2021/11/08/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-1218%5D%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"[LeetCode-319]灯泡开关","text":"原题链接 题目描述给出n个灯泡(初始全部熄灭)并且操作n次, 第i次把所有是i的倍数处的灯泡的开关状态取反. 求n次操作后亮着的灯泡数目. 思路 考虑某一个灯泡i在n次操作中被操作的次数, 可以发现该灯泡会被它的所有因子操作. 比如8会在第1、2、4、8次操作时操作. 若一个灯泡被操作k次, 那么该灯泡一定有k个不同的因子. 且该灯泡最后的状态唯一取决于k的奇偶. 即若k为偶数则灭, k为奇数则亮. 问题转化成求$1 - N$中含有奇数个不同因子的数的个数. 考虑到所有因子都是成对出现的, 若数K有奇数个不同的因子, 那么某个因子一定出现两次, 该因子一定是$\\sqrt K$, 即K必为完全平方数. 最后问题转化成求$1 - N$中完全平方数的个数. Code123456789101112using LL = long long;class Solution {public: int bulbSwitch(int n) { if (n == 0) return 0; int cnt = 0; for (LL i = 1; i * i &lt;= n; i ++ ) cnt ++ ; return cnt; }}; 复杂度分析 时间复杂度$O(\\sqrt N)$ 空间复杂度$O(1)$ 欢迎讨论指正","link":"/2021/11/15/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-319%5D%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3/"},{"title":"[LeetCode-237]删除链表中的节点","text":"原题链接 题目描述给出单链表的某个非尾节点, 删除该节点 思路 由于给出的是单链表, 所以我们无法得知被删除节点的前驱节点信息, 只能”曲线救国” 可以将值向前平移一个单位, 删除末尾节点即可 Code1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: void deleteNode(ListNode* node) { // 当前节点不为尾节点, 所以一定有后继节点 ListNode* Nxt = node -&gt; next; ListNode* cur = node; ListNode* prev = nullptr; // 还有后继节点的时候, 进行值前移 while (Nxt) { cur -&gt; val = Nxt -&gt; val; prev = cur; cur = Nxt; Nxt = Nxt -&gt; next; } // 最后删除尾节点即可（退出循环的时候, cur指向尾节点, Nxt为nullptr, 而prev指向尾节点之前的节点） prev -&gt; next = nullptr; }}; 复杂度分析 时间复杂度$O(N)$, 遍历一遍链表即可完成删除操作 空间复杂度$O(1)$, 只使用常数空间存储指针变量Nxt、cur、prev即可","link":"/2021/11/02/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-237%5D%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"title":"[LeetCode-575]分糖果","text":"原题链接 题目描述总共有偶数个数字, 从中选择一半的数字且数字的种类最多. 思路 贪心: 总共选的数字的个数是固定的, 对于每一种数字可以贪心的只选择一个, 这样后面可供选择的余地就越大. Code123456789101112class Solution {public: int distributeCandies(vector&lt;int&gt;&amp; nums) { // 哈希表统计每个数字的个数 unordered_map&lt;int, int&gt; mp; for (auto&amp; num : nums) mp[num] ++ ; int s = nums.size() / 2; return min(s, (int)mp.size()); }}; 复杂度分析 时间复杂度$O(n)$, 只需遍历数组统计类别 空间复杂度$O(n)$, 哈希表所需空间为$O(n)$ 欢迎讨论指正","link":"/2021/11/01/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-575%5D%E5%88%86%E7%B3%96%E6%9E%9C/"},{"title":"[LeetCode-598]范围求和II","text":"原题链接 题目描述多次给矩阵M的某个子矩阵全部加1, 求最后矩阵中最大值出现的次数 思路 注意到关键的一点: 每次加的子矩阵的左上角均为[0, 0], 因此n次操作后, 最大值一定全部出现在以[0, 0]为左上角的某个子矩阵中, 我们只需确定这个子矩阵的长宽即可 这个子矩阵其实是每次操作的交集, 只有这个交集中的位置才能保证每次都被加1 x和y操作的交集是独立的, 分开求解即可 Code1234567891011class Solution {public: int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) { int x = m, y = n; for (auto&amp; op : ops) { x = min(x, op[0]); y = min(y, op[1]); } return x * y; }}; 复杂度分析 时间复杂度$O(N * M)$: 遍历矩阵即可求出答案 空间复杂度$O(1)$: 仅需常数空间存储x和y的交集 欢迎讨论指正","link":"/2021/11/07/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-598%5D%E8%8C%83%E5%9B%B4%E6%B1%82%E5%92%8CII/"},{"title":"[LeetCode-629]K个逆序对数组","text":"原题链接 题目描述由 $1-n$ 组成的排列中, 有多少个排列的逆序对个数是 $k$ 思路看完题目和数据范围基本就能确定是动态规划. 因为可行方案可能很多很多, 无法枚举. 而从集合角度1(动态规划)进行计算, 会帮助我们省去很多不必要的枚举. 使用一个数来表示一类有共同点的方案, 是动态规划优化问题的特点. 动态规划 状态表示: $f[i][j]$ : 表示考虑前 $1 - i$ 个数, 且逆序对个数为 $j$ 时的方案数. 状态计算:状态计算的思路是枚举最后一个不同点1: 即考虑将数字i放在什么位置. 放置i位置的可能方式如下: 由上图可见, 若将 $i$ 放置在 $i - k$下标处, 这会造成 $k - 1$个逆序对(数 $i$与 下标$\\in[i - k + 1, i]$处的数构成逆序对) 因此可得: $f[i][j]$ = $\\sum_{k=0}^{i - 1} f[i - 1][j - k]$ 由上分析可见, 状态为$O(n^2)$, 转移为$O(n)$, 总时间复杂度为$O(n^3)$, 会超时. 利用前缀和优化状态转移: 记$s[i][j]$ = $\\sum_{k=0}^j f[i][k]$, 可得状态计算：$$ $$ Code1234567891011121314151617181920212223const int N = 1010, MOD = 1e9 + 7;class Solution {public: int f[N][N], s[N][N]; int kInversePairs(int n, int k) { for (int i = 0; i &lt;= n; i ++ ) f[i][0] = s[i][0] = 1; for (int i = 1; i &lt;= n; i ++ ) { for (int j = 1; j &lt;= k; j ++ ) s[i - 1][j] = (s[i - 1][j - 1] + f[i - 1][j]) % MOD; for (int j = 1; j &lt;= k; j ++ ) { if (i &gt; j) f[i][j] = s[i - 1][j]; else f[i][j] = (s[i - 1][j] - s[i - 1][j - i]) % MOD; } } int ans = f[n][k]; ans = (ans + MOD) % MOD; return ans; }}; 复杂度分析 时间复杂度$O(N * K)$ 空间复杂度$O(N * K)$ 参考资料 [1] B站yxc 欢迎讨论指正","link":"/2021/11/11/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-629%5DK%E4%B8%AA%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E7%BB%84/"},{"title":"[LeetCode-869]重新排序得到2的幂","text":"原题链接 题目描述判断一个数字重新排列后能否成为2的某个幂次. 思路 模拟: 考虑到数据范围很小, 我们可以暴力枚举该数的所有排列, 然后判断该数是否为2的幂次. 模拟: 考虑到2的幂次的个数很少, 我们可以首先预处理出来所有的2的幂次, 然后判断该数是否为某个2的幂次。由于数字可以重新排列, 因此只需记录词频, 即若两个数词频相同, 则一个数一定可以通过重新排列变成另外一个数. Code 解法一123456789101112131415161718192021222324252627282930class Solution {public: static const int M = 11; // 辅助函数: 获取x的十进制表示 vector&lt;int&gt; get(int x) { vector&lt;int&gt; ret; while (x) { ret.push_back(x % 10); x /= 10; } return ret; } bool reorderedPowerOf2(int n) { // 记录所有合法方案的十进制表示 set&lt;vector&lt;int&gt;&gt; st; for (int i = 0; i &lt; 31; i ++ ) st.insert(get(1 &lt;&lt; i)); vector&lt;int&gt; cur = get(n); sort(cur.begin(), cur.end()); int ret = 0; // cpp利用next_permutation()函数暴力枚举该数的所有排列 do { ret += st.count(cur); } while (next_permutation(cur.begin(), cur.end())) ; return ret; }}; 解法二123456789101112131415161718192021222324class Solution {public: static const int M = 11; // 辅助函数: 统计数x的词频 vector&lt;int&gt; get(int x) { vector&lt;int&gt; ret(M, 0); while (x) { ret[x % 10] ++ ; x /= 10; } return ret; } bool reorderedPowerOf2(int n) { // 预处理所有合法的方案的词频 set&lt;vector&lt;int&gt;&gt; st; for (int i = 0; i &lt; 31; i ++ ) st.insert(get(1 &lt;&lt; i)); // 获得当前数的词频 vector&lt;int&gt; cur = get(n); if (st.find(cur) != st.end()) return true; return false; }}; 复杂度分析(解法2)其中C为30, N为1e9. 时间复杂度$O(ClogN)$, 首先预处理所有合法方案$O(ClogN)$, 接着查set表$O(logC * logN)$ 空间复杂度$O(ClogN)$, 使用set存储所有合法的2的幂次的词频, 共有C个合法方案, 每个方案的长度不超过logN 欢迎讨论指正","link":"/2021/10/28/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%5BLeetCode-869%5D%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/"},{"title":"[LeetCode-周赛]266","text":"Rank : 152/4384Solved: 4/4 竞赛链接 统计字符串中的元音子字符串思路 注意到数据范围很小, 直接$O(n^2)$枚举所有子串, 然后$O(n)$判断该子串是否符合要求即可 Code1234567891011121314151617181920212223class Solution {public: int countVowelSubstrings(string s) { int ans = 0, n = s.size(); for (int i = 0; i &lt; n; i ++ ) for (int j = i; j &lt; n; j ++ ) { string tmp = s.substr(i, j - i + 1); int cnt = 0; bool flag = true; for (auto&amp; c : {'a', 'e' ,'i' ,'o', 'u'}) { int cur = count(tmp.begin(), tmp.end(), c); cnt += cur; // 子串不含某个元音字母则不满足条件 if (cur == 0) flag = false; } // cnt记录字符串中所有元音字符的数量 if (flag) ans += cnt == tmp.size(); } return ans; }}; 复杂度分析 时间复杂度$O(n^3)$ 空间复杂度$O(1)$ 所有子字符串中的元音思路 遍历字符串, 枚举每个元音字符对答案的贡献 某个i位置的元音字符贡献为包含i位置的所有子串的个数 由乘法原理, 子串的个数为$(i + 1) * (n - i)$ Code1234567891011121314151617using LL = long long;class Solution {public: long long countVowels(string s) { set&lt;int&gt; str = {'a', 'e' ,'i' ,'o', 'u'}; LL ans = 0, n = s.size(); for (int i = 0; i &lt; n; i ++ ) { char cur = s[i]; int l = i; int r = n - i - 1; if (str.count(cur)) ans += 1ll * (l + 1) * (r + 1); } return ans; }}; 复杂度分析 时间复杂度$O(n)$ 空间复杂度$O(1)$ 分配给商店的最多商品的最小值思路 看到最大值最小立马想到二分 二分答案: 对于答案x, 所有的商店的上界不超过x 枚举所有商品, i号商品至少需要$\\lceil \\frac{quantities[i]}{x} \\rceil$ 个商店 Code1234567891011121314151617181920class Solution {public: int minimizedMaximum(int n, vector&lt;int&gt;&amp; nums) { int m = nums.size(); int l = 1, r = 1e5; while (l &lt; r) { int mid = (r - l) / 2 + l; int cnt = 0; // cpp上取整方式之一 for (auto&amp; num : nums) cnt += (num + mid - 1) / mid; if (cnt &lt;= n) r = mid; else l = mid + 1; } return r; }}; 复杂度分析 时间复杂度$O(N * log1e5)$ 空间复杂度$O(1)$ 最大化一张图中的路径价值思路 动态规划: $dist[i][j][k]$: 表示当前在i点, 还剩余j时间，走过的点的状态是k时候的最大价值 由于只能按照时间递减的顺序走, 因此从大到小遍历时间 状态转移: 若当前状态是$dist[i][j][k]$, 枚举i号点的所有邻接点u, 更新$dist[u][j - costTime][k’]$ 若已经走过了u点, 即k[u] = true, 则$dist[u][j - costTime][k] = max(dist[u][j - costTime][k], dist[i][j][k])$ 若没有走过u点, 即k[u] = false, 则$dist[u][j - costTime][k’] = max(dist[u][j - costTime][k’], dist[i][j][k] + value[u])$, 其中$k’ = k | (1 &lt;&lt; u)$ 实现细节:用二进制表示状态k, 但无法用int或者long long等基础数据类型存储, 这里我使用了bitset存储状态 Code123456789101112131415161718192021222324252627282930313233343536373839404142const int N = 1005, M = 105;using PII = pair&lt;int, int&gt;;class Solution {public: unordered_map&lt;bitset&lt;N&gt;, int&gt; dist[N][M]; int maximalPathQuality(vector&lt;int&gt;&amp; val, vector&lt;vector&lt;int&gt;&gt;&amp; edge, int Mx) { int n = val.size(); vector&lt;vector&lt;PII&gt;&gt; g(n); for (auto&amp; e : edge) { int a = e[0], b = e[1], c = e[2]; g[a].emplace_back(b, c); g[b].emplace_back(a, c); } dist[0][Mx][bitset&lt;N&gt;(1)] = val[0]; for (int Time = Mx; Time &gt;= 0; Time -- ) { for (int i = 0; i &lt; n; i ++ ) for (auto&amp; [st, v] : dist[i][Time]) for (auto&amp; [nxt, cost] : g[i]) { if (Time &lt; cost) continue; if (st[nxt] == 0) { bitset&lt;N&gt; tmp = st; tmp[nxt] = 1; dist[nxt][Time - cost][tmp] = max(dist[nxt][Time - cost][tmp], dist[i][Time][st] + val[nxt]); } else dist[nxt][Time - cost][st] = max(dist[nxt][Time - cost][st], dist[i][Time][st]); } } // 最后答案枚举0号点的状态即可 int ans = val[0]; for (int r = Mx; r &gt;= 0; r -- ) for (auto&amp; [_, v] : dist[0][r]) ans = max(ans, v); return ans; }}; 复杂度分析 时间复杂度$O(M * N * C)$: M为maxTime, N为点数, C为有效状态数 空间复杂度$O(M * N * C)$: M为maxTime, N为点数, C为有效状态数 欢迎讨论指正","link":"/2021/11/07/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D266/"},{"title":"[LeetCode-周赛]267","text":"Rank : 131/4360Solved : 4/4 竞赛链接 买票需要的时间思路注意到数据范围均很小, 因此直接使用双端队列(deque)模拟题意即可. Code1234567891011121314151617181920212223using PII = pair&lt;int, int&gt;;class Solution {public: int timeRequiredToBuy(vector&lt;int&gt;&amp; nums, int k) { deque&lt;PII&gt; dq; int n = nums.size(), ans = 0; for (int i = 0; i &lt; n; i ++ ) dq.emplace_back(nums[i], i); int cnt = 0; while (true) { auto [t, idx] = dq.front(); dq.pop_front(); cnt ++ ; if (t == 1 and idx == k) return cnt; if (t &gt; 1) dq.emplace_back(t - 1, idx); } return -1; }}; 复杂度分析 时间复杂度$O(N * Max(nums))$ 空间复杂度$O(N)$ 反转偶数长度组的节点思路使用vector模拟题意, 注意反转的是偶数长度的组(错看成偶数编号的组, 白WA了两次) Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseEvenLengthGroups(ListNode* head) { ListNode* p = head; vector&lt;int&gt; nums; while (p) { nums.push_back(p -&gt; val); p = p -&gt; next; } int n = nums.size(); vector&lt;int&gt; ans; // cnt是index, id是组的编号(1, 2, 3...) int cnt = 0, id = 1; while (cnt &lt; n) { if (id &amp; 1) { int len = min(n - 1, cnt + id - 1) - cnt + 1; if (len &amp; 1) { for (int k = cnt; k &lt;= min(n - 1, cnt + id - 1); k ++ ) ans.push_back(nums[k]); } else { for (int k = min(n - 1, cnt + id - 1); k &gt;= cnt; k --) ans.push_back(nums[k]); } cnt = min(n, cnt + id); } else { int len = min(n - 1, cnt + id - 1) - cnt + 1; if (len &amp; 1) { for (int k = cnt; k &lt;= min(n - 1, cnt + id - 1); k ++ ) ans.push_back(nums[k]); } else for (int k = min(n - 1, cnt + id - 1); k &gt;= cnt; k --) ans.push_back(nums[k]); cnt = min(n, cnt + id); } id += 1; } ListNode* ret = new ListNode(); p = nullptr; for (auto&amp; c : ans) { if (p == nullptr) { ret -&gt; val = c; p = ret; } else { ListNode* nxt = new ListNode(c); p -&gt; next = nxt; p = p -&gt; next; } } return ret; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 解码斜向换位密码思路模拟题意, 按照矩阵的方式填充好字符后. 遍历每条主对角线, 依次添加字符, 最后把末尾的空格去掉. Code123456789101112131415161718192021222324252627class Solution {public: string decodeCiphertext(string str, int row) { int len = str.size(); int col = len / row; vector&lt;vector&lt;char&gt;&gt; mat(row, vector&lt;char&gt;(col, ' ')); int x = 0, y = 0; for (auto&amp; c : str) { mat[x][y] = c; y ++ ; if (y == col) y = 0, x ++ ; } string ans; for (int i = 0; i &lt; col; i ++ ) { int x = 0, y = i; while (x &lt; row and y &lt; col) { ans.push_back(mat[x][y]); x ++, y ++; } } while (ans.size() and ans.back() == ' ') ans.pop_back(); return ans; }}; 复杂度分析 时间复杂度$O(N)$, N为str的长度 空间复杂度$O(N)$ 处理含限制条件的好友请求思路使用并查集维护连通性. 每次处理请求时, 若已经在一个联通块中则结果为True; 否则暴力判断是否有一条限制边连接了这两个连通块中的两个点. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344const int N = 1010;int p[N];class Solution {public: int find(int x) { return x == p[x] ? x : p[x] = find(p[x]); } vector&lt;bool&gt; friendRequests(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edge, vector&lt;vector&lt;int&gt;&gt;&amp; qu) { int m = edge.size(); for (int i = 0; i &lt; n; i ++ ) p[i] = i; vector&lt;bool&gt; ans; for (auto&amp; q : qu) { int x = q[0], y = q[1]; x = find(x), y = find(y); if (x == y) { ans.push_back(true); continue; } // x != y unordered_set&lt;int&gt; sx, sy; for (int i = 0; i &lt; n; i ++ ) { if (find(i) == x) sx.insert(i); if (find(i) == y) sy.insert(i); } bool flag = true; for (auto&amp; e : edge) { int u = e[0], v = e[1]; if ((sx.count(u) and sy.count(v)) or (sx.count(v) and sy.count(u))) flag = false; } ans.push_back(flag); if (flag) p[y] = x; } return ans; }}; 复杂度分析 时间复杂度$O(N * M)$, N为点数, M为请求数. 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2021/11/14/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D267/"},{"title":"[LeetCode-周赛]268","text":"Rank : 228/4397Solved : 4/4 竞赛链接 两栋颜色不同且距离最远的房子思路注意到数据范围很小, 两重循环枚举即可. Code123456789101112131415161718class Solution {public: int maxDistance(vector&lt;int&gt;&amp; c) { unordered_map&lt;int, int&gt; mp; int n = c.size(); int ans = 0; for (int i = 0; i &lt; n; i ++ ) { int col = c[i]; for (auto&amp; [cc, idx] : mp) { if (cc != col) ans = max(ans, i - idx); } if (mp.count(col) == 0) mp[col] = i; } return ans; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(N)$ 给植物浇水思路按照题意模拟即可. Code1234567891011121314151617181920class Solution {public: int wateringPlants(vector&lt;int&gt;&amp; nums, int cap) { int n = nums.size(); // all : 当前剩余 int ret = 0, all = cap; for (int i = 0; i &lt; n; i ++ ) { int cur = nums[i]; if (all &gt;= cur) { all -= cur; ret += 1; } else { all = cap; ret += i + i + 1; all -= cur; } } return ret; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(1)$ 区间内查询数字的频率思路以值作为key, 以下标作为val, 构建哈希表.每次查询在递增的下标上二分搜索即可 Code123456789101112131415161718192021class RangeFreqQuery {public: unordered_map&lt;int, vector&lt;int&gt;&gt; mp; RangeFreqQuery(vector&lt;int&gt;&amp; arr) { int n = arr.size(); for (int i = 0; i &lt; n; i ++ ) mp[arr[i]].push_back(i); } int query(int l, int r, int val) { auto L = lower_bound(mp[val].begin(), mp[val].end(), l) - mp[val].begin(); auto R = upper_bound(mp[val].begin(), mp[val].end(), r) - mp[val].begin(); return R - L; }};/** * Your RangeFreqQuery object will be instantiated and called as such: * RangeFreqQuery* obj = new RangeFreqQuery(arr); * int param_1 = obj-&gt;query(left,right,value); */ 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(Q * logN)$ k 镜像数字的和思路打表. 由于数据范围很小, 考虑枚举长度不超过12的十进制回文数(复杂度为1e6), 然后暴力判断每个10进制下的回文数是否在2-9进制下也回文. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const int M = 30;using LL = long long;vector&lt;vector&lt;LL&gt;&gt; nums;class Solution {public: void dfs(int len, int cur, string&amp; num) { int R = (len + 1) / 2; if (cur == R + 1) { string ss = num; if (len &amp; 1) { for (int idx = R - 1; idx &gt;= 1; idx -- ) ss.push_back(num[idx - 1]); } else { for (int idx = R; idx &gt;= 1; idx -- ) ss.push_back(num[idx - 1]); } LL val = stoll(ss); for (int k = 2; k &lt;= 9; k ++ ) { if (nums[k].size() == M) continue; LL cv = val; string s; while (cv) { s.push_back(char(cv % k + '0')); cv /= k; } string rs = s; reverse(rs.begin(), rs.end()); if (s == rs and rs[0] != '0') nums[k].push_back(val); } return ; } for (int i = 0; i &lt;= 9; i ++ ) { num.push_back(char(i + '0')); dfs(len, cur + 1, num); num.pop_back(); } } void init() { if (nums.size()) return ; nums.resize(10); for (int len = 1; len &lt;= 12; len ++ ) { for (int i = 1; i &lt;= 9; i ++ ) { string s = to_string(i); dfs(len, 2, s); } } } long long kMirror(int k, int n) { init(); LL ret = 0ll; for (int i = 0; i &lt; n; i ++ ) ret += nums[k][i]; return ret; }}; 复杂度分析 时间复杂度$O(1e6)$ 空间复杂度$O(N * K)$ 欢迎讨论指正","link":"/2021/11/23/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D268/"},{"title":"[LeetCode-周赛]271","text":"Rank : 201/4561Solved : 4/4 竞赛链接 环和杆思路对每个杆使用哈希表记录出现的环种类即可. Code123456789101112131415161718class Solution {public: int countPoints(string s) { unordered_map&lt;int, unordered_set&lt;char&gt;&gt; cnt; int n = s.size(); for (int i = 0; i &lt; n; i += 2) { char col = s[i]; int idx = s[i + 1]; cnt[idx].insert(col); } int ans = 0; for (auto&amp; [k, v] : cnt) if (v.size() == 3) ans += 1; return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 子数组范围和思路由于数据范围很小, 因此使用暴力的方法即可.可以使用单调栈分开统计最小和最大值的贡献, 时间和空间复杂度均为$O(N)$. Code12345678910111213141516171819using LL = long long;class Solution {public: long long subArrayRanges(vector&lt;int&gt;&amp; nums) { int n = nums.size(); LL ans = 0; for (int i = 0; i &lt; n; i ++ ) { int Mn = INT_MAX, Mx = INT_MIN; for (int j = i; j &lt; n; j ++ ) { Mn = min(Mn, nums[j]); Mx = max(Mx, nums[j]); ans += Mx - Mn; } } return ans; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(N)$ 给植物浇水 II思路阅读理解模拟题. 按题意模拟即可. Code1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: int minimumRefill(vector&lt;int&gt;&amp; nums, int a, int b) { int n = nums.size(); int L = 0, R = n - 1; // cA cB 灌水次数 int cA = 0, cB = 0; // curA curB 当前水量 int curA = a, curB = b; while (L &lt;= R) { if (L == R) { // Bob if (curB &gt; curA) { if (curB &lt; nums[L]) cB += 1; } else { // Alice if (curA &lt; nums[L]) cA += 1; } break; } if (curA &gt;= nums[L]) { curA -= nums[L]; } else { curA = a - nums[L]; cA += 1; } if (curB &gt;= nums[R]) { curB -= nums[R]; } else { curB = b - nums[R]; cB += 1; } L += 1, R -= 1; } return cA + cB; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 摘水果思路没看清楚题目范围, 还写了个离散化, 小亏. 具体思路使用前缀和的技巧, 暴力枚举所有的方案, 求这些方案的最大值即可. 我的方法是枚举终点. 特殊计算一直往左走和一直往右走. 若终点小于等于starPos, 则先往右走, 然后再折回到终点最优. 若终点大于等于starPos, 则先往左走, 然后掉头往右走最优. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using LL = long long;class Solution {public: vector&lt;int&gt; all; int get(int x) { return lower_bound(all.begin(), all.end(), x) - all.begin() + 1; } int maxTotalFruits(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int stP, int k) { int n = nums.size(); for (int i = 0; i &lt; n; i ++ ) all.push_back(nums[i][0]); for (int i = stP - k; i &lt;= stP + k; i ++ ) all.push_back(i); sort(all.begin(), all.end()); all.erase(unique(all.begin(), all.end()), all.end()); int M = all.size(); vector&lt;LL&gt; sum(M + 1, 0ll); for (int i = 0; i &lt; n; i ++ ) { int idx = get(nums[i][0]); sum[idx] = nums[i][1]; } for (int i = 1; i &lt;= M; i ++ ) sum[i] += sum[i - 1]; LL ans = 0; // Left int curIdx = get(stP), leftIdx = get(stP - k), rightIdx = get(stP + k); ans = sum[curIdx] - sum[leftIdx - 1]; // Right ans = max(ans, sum[rightIdx] - sum[curIdx - 1]); for (int ed = stP - k + 1; ed &lt; stP + k; ed ++ ) { int start; if (ed &lt;= stP) { start = stP + (k - (stP - ed)) / 2; ans = max(ans, sum[get(start)] - sum[get(ed) - 1]); // cout &lt;&lt; ed &lt;&lt; ' ' &lt;&lt; start &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; } if (ed &gt;= stP) { start = stP - (k - (ed - stP)) / 2; ans = max(ans, sum[get(ed)] - sum[get(start) - 1]); // cout &lt;&lt; ed &lt;&lt; ' ' &lt;&lt; start &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; } } return ans; }}; 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2021/12/15/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D271/"},{"title":"[LeetCode-周赛]273","text":"Rank : 301/4367Solved : 4/4 竞赛链接 反转两次的数字思路模拟题意. cpp可以使用to_string和stoi函数方便的进行字符串和int之间的转换. Code12345678910111213class Solution {public: bool isSameAfterReversals(int num) { string nums = to_string(num); reverse(nums.begin(), nums.end()); int r1 = stoi(nums); string r2 = to_string(r1); reverse(r2.begin(), r2.end()); if (num == stoi(r2)) return true; return false; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 执行所有后缀指令思路由于数据范围很小, 因此直接按照题意模拟. Code1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;int&gt; executeInstructions(int n, vector&lt;int&gt;&amp; st, string s) { int sx = st[0], sy = st[1]; int m = s.size(); vector&lt;int&gt; ans; for (int i = 0; i &lt; m; i ++ ) { int x = sx, y = sy, cur = 0; for (int j = i; j &lt; m; j ++ ) { if (s[j] == 'L') y -= 1; if (s[j] == 'R') y += 1; if (s[j] == 'U') x -= 1; if (s[j] == 'D') x += 1; if (x &gt;= 0 and x &lt; n and y &gt;= 0 and y &lt; n) cur ++ ; else break; } ans.push_back(cur); } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 相同元素的间隔之和思路首先可以将问题一分为二: 分别统计左边和右边, 最后两者相加即可.以左边为例. 我们可以使用前缀和的思想完成统计. 具体思路为: 记left[i]为nums[i]左边与其的间隔之和. cnt[nums[i]]为i极其左边与nums[i]值相等的个数. 若当前枚举到下标i, 其值为nums[i], 若其左边最后一个与其值相同的下标为j, 则有:$$sum[i] = sum[j] + cnt[nums[i]] * (i - j) $$ 上式表示所有所有与nums[i]相同的下标, 先考虑其到j处的距离距离之和(由sum的定义可知为sum[j]); 然后再统计j到i处的距离之和, 其为(i - j) * cnt[nums[i]]. 主要思想是利用历史信息, 分两步部分统计(先到j, 再到i), 其中使用前缀和进行优化. 最后将left和right相加即可. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546using LL = long long;class Solution {public: vector&lt;long long&gt; getDistances(vector&lt;int&gt;&amp; arr) { int n = arr.size(); vector&lt;LL&gt; sum(n + 1, 0L); unordered_map&lt;int, int&gt; mp; // 记录每个数最后一次出现的位置 unordered_map&lt;int, int&gt; cnt; // Left for (int i = 1; i &lt;= n; i ++ ) { int cur = arr[i - 1]; if (mp.count(cur) == 0) { mp[cur] = i; cnt[cur] ++ ; continue; } int idx = mp[cur], num = cnt[cur]; sum[i] = sum[idx] + 1ll * num * (i - idx); mp[cur] = i; cnt[cur] ++ ; } // Right mp.clear(); cnt.clear(); vector&lt;LL&gt; ans(n, 0L); // 先把左边的加到答案里, 然后算右边的 for (int i = 0; i &lt; n; i ++ ) ans[i] += sum[i + 1]; sum = vector&lt;LL&gt;(n + 1, 0L); for (int i = n; i &gt;= 1; i -- ) { int cur = arr[i - 1]; if (mp.count(cur) == 0) { mp[cur] = i; cnt[cur] ++ ; continue; } int idx = mp[cur], num = cnt[cur]; sum[i] = sum[idx] + 1ll * num * (idx - i); mp[cur] = i; cnt[cur] ++ ; } for (int i = 0; i &lt; n; i ++ ) ans[i] += sum[i + 1]; return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 还原原数组思路首先观察数据范围可知, 可以使用$O(N^2)$的算法解决.由于将原数组左右k和右移k后, 对应位置的数差值固定为2k.因此如果我们知道k的具体值的话, 问题就转化成: 给定k值的情况下, 判断数组能否还原出原数组. 判断可以从贪心的小到大考虑: 若考虑到x了, 则将x放入lower数组, 将x + 2k放入higher数组, 若无x + 2k则失败。使用map或者multiset判断的时间复杂度为$O(NlogN)$ 对于k值, 可以考虑枚举所有可能的k值. 由于数组的最大值必定为higher的最大值, 最小值必定为lower的最小值. 因此可以枚举higher的最小值或者lower的最大值, 从而计算出k. 时间复杂度$O(N)$. 最后算法整体时间复杂度为$O(N^2logN)$. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution {public: vector&lt;int&gt; recoverArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); n /= 2; // Max -&gt; higher, Min -&gt; lower int HMx = *max_element(nums.begin(), nums.end()); int LMn = *min_element(nums.begin(), nums.end()); if (n == 1) return {LMn + (HMx - LMn) / 2}; set&lt;int&gt; st(nums.begin(), nums.end()); map&lt;int, int&gt; cnt; for (auto&amp; num : nums) cnt[num] ++ ; // 从大到小枚举LMx, 计算k for (auto it = st.rbegin(); it != st.rend(); it ++ ) { int LMx = *it; if (LMx == HMx) continue; int d = HMx - LMx; if (d % 2 or cnt[HMx] &gt; cnt[LMx]) continue; int k = d / 2; bool flag = true; // lower map&lt;int, int&gt; exist; // map&lt;int, int&gt; cur = cnt; for (auto&amp; [_k, _v] : cnt) { if (_v == 0) continue; if (cnt.count(_k + 2 * k) == 0 or cnt[_k + 2 * k] &lt; _v) { flag = false; break; } else { cnt[_k + 2 * k] -= _v; exist[_k] = _v; } } // 复原全局的cnt for (auto&amp; [_k, _v] : exist) cnt[_k + 2 * k] += _v; if (flag) { // cout &lt;&lt; &quot;find &quot; &lt;&lt; k &lt;&lt; ' ' &lt;&lt; HMx &lt;&lt; ' ' &lt;&lt; LMx &lt;&lt; endl; vector&lt;int&gt; ans; // lower exist[LMn] = cnt[LMn]; for (auto&amp; [l, time] : exist) ans.insert(ans.end(), time, l + k); return ans; } } return {}; }}; 实现的过程中使用exist来存储lower数组, 如果没有找到答案, 则将exist的内容复原到原来的mapcnt中, 这样可以减少cnt的重复拷贝, 将运行时间从超时边缘(1972ms)优化成28ms. 复杂度分析 时间复杂度$O(N^2logN)$ 空间复杂度$O(N^2)$ 欢迎讨论指正","link":"/2021/12/27/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D273/"},{"title":"[LeetCode-周赛]276","text":"Rank : 273/5243Solved : 4/4 竞赛链接 将字符串拆分为若干长度为 k 的组思路模拟题意, 如果最后一段的长度不足就补齐. Code123456789101112131415161718class Solution {public: vector&lt;string&gt; divideString(string s, int k, char fill) { vector&lt;string&gt; ans; string cur; int n = s.size(); for (int i = 0; i &lt; n; i ++ ) { cur.push_back(s[i]); if (cur.size() == k) ans.push_back(cur), cur = &quot;&quot;; } while (cur.size() and cur.size() &lt; k) cur.push_back(fill); if (cur.size() == k) ans.push_back(cur); return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 得到目标值的最少行动次数思路写完记忆化才发现其实是贪心. 首先倒着做, 求从target变成1的最小花费. 然后贪心的做 当前数能被2整除且有整除次数, 则整除 否则就减一 (无整除次数直接可以返回答案) Code1234567891011121314151617181920212223242526272829const int INF = 1e9;class Solution {public: unordered_map&lt;int, unordered_map&lt;int,int&gt;&gt; f; int dfs(int x, int cnt) { if (cnt == 0) return x - 1; if (f.count(x) and f[x].count(cnt)) return f[x][cnt]; int&amp; v = f[x][cnt]; // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; endl; v = INF; if ((x % 2) == 0 and cnt) v = min(v, dfs(x / 2, cnt - 1) + 1); else v = min(v, dfs(x - 1, cnt) + 1); return v; } int minMoves(int tar, int cnt) { if (cnt == 0) return tar - 1; int ans = INF; for (int i = 0; i &lt;= cnt; i ++ ) f[1][i] = 0; ans = dfs(tar, cnt); return ans; }}; 复杂度分析 时间复杂度$O(logN)$ 空间复杂度$O(logN * maxDoubles)$ 解决智力问题思路首先可以想到使用动态规划, 因为选的方式无法穷举, 而且选与不选之间的状态转移也比较清楚.麻烦的是如果正向做, 求f[i]的时候, 计算选择i的时候, 我们要找一个j, 使得在j处选择后可以在i处选择, 且f[j]最大.反向做就比较友好, 避免了找j的过程. 动态规划: 状态定义: f[i]表示考虑$i到n - 1$之间物品时候的最大价值. 状态转移: 可以不拿i处的或只拿i处的: $f[i] = max(f[i + 1], cur)$ 可以拿了i处后继续拿后面的(如果可以): $f[i] = max(f[i], f[i + questions[i][1] + 1] + cur)$ Code123456789101112131415161718using LL = long long;class Solution {public: long long mostPoints(vector&lt;vector&lt;int&gt;&gt;&amp; qu) { int n = qu.size(); vector&lt;LL&gt; f(n); f[n - 1] = qu[n - 1][0]; for (int i = n - 2; i &gt;= 0; i -- ) { int r = i + qu[i][1] + 1; LL cur = qu[i][0]; f[i] = max(f[i + 1], cur); // 不越界才可以拿后面的 if (r &lt; n) f[i] = max(f[i], f[r] + cur); } return f[0]; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 同时运行 N 台电脑的最长时间思路没有思路的时候就想想二分 哈哈!答案具有二段性, 如果答案为k, 则所有小于等于k的都能被凑出来, 而大于k的无法凑出来.因此可以二分答案, 然后判断这个数组能否凑出n个mid. 判断过程中, 如果某个值大于等于mid, 则凑出个数 + 1;否则双指针连续求和, 求出一段之和大于等于mid, 然后关键是这一段之和大于mid的部分可以被其他电脑所使用. 因此大于mid的部分的可以继续使用. Code123456789101112131415161718192021222324252627282930313233343536373839404142using LL = long long;class Solution {public: long long maxRunTime(int n, vector&lt;int&gt;&amp; nums) { int m = nums.size(); if (m &lt; n) return 0; sort(nums.begin(), nums.end()); LL sum = 0; for (auto&amp; c : nums) sum += c; LL L = 0, R = sum; while (L &lt; R) { LL mid = (L + R + 1) &gt;&gt; 1; LL cur = 0, cnt = 0; for (int i = 0; i &lt; m; ) { if (nums[i] &gt;= mid) { cnt ++ ; i ++ ; continue; } int j = i; while (j &lt; m and cur &lt; mid) { cur += nums[j]; j ++ ; } if (cur &gt;= mid) { cnt ++ ; cur -= mid; } i = j; } if (cnt &gt;= n) L = mid; else R = mid - 1; } return R; }}; 复杂度分析 时间复杂度$O(NlogN)$ 空间复杂度$O(1)$ 欢迎讨论指正","link":"/2022/01/16/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D276/"},{"title":"[LeetCode-周赛]第65场双周赛","text":"Rank : 235/2676Solved : 3/4 竞赛链接 检查两个字符串是否几乎相等思路模拟题意. 使用哈希表或数组统计词频, 然后比较词频之差的绝对值是否超过3. Code12345678910111213141516class Solution {public: bool checkAlmostEquivalent(string w1, string w2) { unordered_map&lt;char, int&gt; m1, m2; for (auto&amp; c : w1) m1[c] ++ ; for (auto&amp; c : w2) m2[c] ++ ; for (char c = 'a'; c &lt;= 'z'; c ++ ) { int d = abs(m1[c] - m2[c]); if (d &gt; 3) return false; } return true; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(\\vert S\\vert)$, $\\vert S\\vert$为字符集大小 模拟行走机器人 II思路模拟. 一开始眼瞎没注意到数据范围, 每一步都按照题目要求模拟, 然后TLE了. 接着优化, 优化的方式写了两点。 一种是步长对周长取余, 因为每次都是绕外圈走, 因此可以认为余数是真正移动了的步数, 这种优化要注意移动方向的改变, 在四个角上移动了k圈后, 可能会发生移动方向的改变. 比如在左下角(0, 0), 只有初始朝北的时候, 绕k圈后会朝西; 其他朝向绕k圈后都会朝南. 还有一种是一次走好几步, 比如当前向北, 算一下向北最多能走几步. 若可以走完, 就一次走完. 若向北走不完, 则走到上界后修改方向, 递归走剩下的步数。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};class Robot {public: map&lt;int, string&gt; mp; int idx; int x, y; int W, H; // 周长 int all; Robot(int width, int height) { W = width, H = height; x = 0, y = 0; idx = 1; mp[0] = &quot;North&quot;; mp[1] = &quot;East&quot;; mp[2] = &quot;South&quot;; mp[3] = &quot;West&quot;; all = 2 * (W + H) - 4; } bool check(int x, int y) { return x &gt;= 0 and x &lt; W and y &gt;= 0 and y &lt; H; } void move(int num) { num %= all; if (num == 0) { if (x == 0 and y == 0) { if (getDir() == &quot;North&quot;) idx = 3; else idx = 2; } if (x == 0 and y == H - 1) { if (getDir() == &quot;East&quot;) idx = 0; else idx = 3; } if (x == W - 1 and y == 0) { if (getDir() == &quot;West&quot;) idx = 2; else idx = 1; } if (x == W - 1 and y == H - 1) { if (getDir() == &quot;South&quot;) idx = 1; else idx = 0; } } string c = getDir(); if (c == &quot;North&quot;) { int Mx = H - 1 - y; if (Mx &gt;= num) { y += num; return ; } else { y = H - 1; idx = 3; return move(num - Mx); } } if (c == &quot;South&quot;) { int Mx = y; if (Mx &gt;= num) { y -= num; return ; } else { y = 0; idx = 1; return move(num - Mx); } } if (c == &quot;West&quot;) { int Mx = x; if (Mx &gt;= num) { x -= num; return ; } else { x = 0; idx = 2; return move(num - Mx); } } if (c == &quot;East&quot;) { int Mx = W - x - 1; if (Mx &gt;= num) { x += num; return ; } else { x = W - 1; idx = 0; return move(num - Mx); } } for (int i = 1; i &lt;= num; ) { int nx = x + dx[idx], ny = y + dy[idx]; if (check(nx, ny)) { i += 1; x = nx, y = ny; continue; } idx -= 1; if (idx == -1) idx = 3; } } vector&lt;int&gt; getPos() { return {x, y}; } string getDir() { return mp[idx]; }};/** * Your Robot object will be instantiated and called as such: * Robot* obj = new Robot(width, height); * obj-&gt;move(num); * vector&lt;int&gt; param_2 = obj-&gt;getPos(); * string param_3 = obj-&gt;getDir(); */ 复杂度分析 时间复杂度$O(N)$, N次调用move, 每次最多走三个阶段(自身递归的次数不超过3) 空间复杂度$O(1)$ 每一个查询的最大美丽值思路经典题. 可以使用树状数组在线算法做, 也可以使用递推等离线算法做. 在线算法(树状数组): 离散化查询点和价格点后, 需要查询每一个查询点之前的前缀最大值, 可以使用树状数组维护前缀最大值. 离散算法(递推):将查询点和价格点放在一起排序, 相同价格的话查询点放在后面. 这样每个查询点之前的价格点是确定的, 使用一个变量遍历递推一下即可. Code1234567891011121314151617181920212223242526272829// 离线算法: 排序 + 递推using TII = tuple&lt;int, int, int&gt;;class Solution {public: vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; nums, vector&lt;int&gt;&amp; qu) { vector&lt;TII&gt; all; for (auto&amp; c : nums) all.emplace_back(c[0], c[1], 0); int m = qu.size(); for (int i = 0; i &lt; m; i ++ ) all.emplace_back(qu[i], INT_MAX, i); sort(all.begin(), all.end()); int Mx = 0; vector&lt;int&gt; ans(m); for (auto&amp; [c, t, idx] : all) { // t 指示类型 if (t == INT_MAX) { ans[idx] = Mx; } else { Mx = max(Mx, t); } } return ans; }}; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 在线算法. 注意树状数组的范围要开到题目范围的两倍(查询点 + 价格点).const int N = 2e5 + 5;class Solution {public: int tr[N], M; int lowbit(int x) { return x &amp; -x; } void add(int x, int c) { for (int i = x; i &lt;= M; i += lowbit(i)) tr[i] = max(tr[i], c); } int query(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res = max(res, tr[i]); return res; } vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; nums, vector&lt;int&gt;&amp; qu) { int n = nums.size(); vector&lt;int&gt; all = qu; for (auto&amp; c : nums) all.push_back(c[0]); sort(all.begin(), all.end()); all.erase(unique(all.begin(), all.end()), all.end()); M = all.size(); auto get = [&amp;] (int x) { return lower_bound(all.begin(), all.end(), x) - all.begin() + 1; }; for (auto&amp; c : nums) { int idx = get(c[0]), val = c[1]; add(idx, val); } vector&lt;int&gt; ans; for (auto&amp; q : qu) { int idx = get(q); int cur = query(idx); ans.push_back(cur); } return ans; }}; 复杂度分析 时间复杂度$O(N * logN)$, 树状数组的查询和更新操作均为$logN$, 最多执行$N次$. 空间复杂度$O(N)$ 你可以安排的最多任务数目思路首先可以发现答案具有二段性. 若答案为k, 则所有小于等于k的任务数都能完成, 所有大于k的任务数均不能完成. 因此考虑二分答案. 这样问题转化成判断能否完成mid个任务.首先贪心的选择最强的mid个工人和最弱的mid个任务. 我们需要找到一种方式, 使得工人和任务一一匹配. 这里贪心的从小到大考虑每个工人, 若当前工人可以完成当前最弱工作, 则让工人去完成它; 若无法完成, 则这位工人需要吃药, 吃完药后我们二分的找到小于等于他体力值的最大任务, 贪心的选择这个任务给他完成. 最后判断吃药次数cnt是否不超过mid. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344// 上述贪心方式class Solution {public: int maxTaskAssign(vector&lt;int&gt;&amp; task, vector&lt;int&gt;&amp; work, int cnt, int sth) { sort(task.begin(), task.end()); sort(work.begin(), work.end()); int n = task.size(), m = work.size(); int l = 0, r = min(n, m); auto check = [&amp;] (int x) { int need = 0; multiset&lt;int&gt; st; for (int i = 0; i &lt; x; i ++ ) st.insert(task[i]); for (int i = m - x; i &lt; m; i ++ ) { int cur = work[i]; if (cur &gt;= *st.begin()) { st.erase(st.begin()); continue; } auto idx = st.lower_bound(cur + sth + 1); if (idx == st.begin()) return false; -- idx; st.erase(idx); need += 1; } return need &lt;= cnt; }; while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return r; }}; 12345678910111213141516171819202122232425262728293031323334353637383940414243// 题解区大佬的解法, 从大到小枚举任务, 贪心的选工人去完成它.class Solution {public: int maxTaskAssign(vector&lt;int&gt;&amp; task, vector&lt;int&gt;&amp; work, int cnt, int sth) { sort(task.begin(), task.end()); sort(work.begin(), work.end()); int n = task.size(), m = work.size(); int l = 0, r = min(n, m); auto check = [&amp;] (int x) { int need = 0; multiset&lt;int&gt; st; for (int i = m - x; i &lt; m; i ++ ) st.insert(work[i]); for (int i = x - 1; i &gt;= 0; i -- ) { auto it = st.lower_bound(task[i]); if (it != st.end()) { st.erase(it); continue; } need ++ ; it = st.lower_bound(task[i] - sth); if (it == st.end()) return false; st.erase(it); } return need &lt;= cnt; }; while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return r; }}; 复杂度分析 时间复杂度$O(N * log^{2}N)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2021/11/14/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D%E7%AC%AC65%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"[LeetCode-周赛]第67场双周赛","text":"Rank : 178/2923Solved : 4/4 竞赛链接 找到和最大的长度为 K 的子序列思路排序后可知最大的k个数是确定的(是哪些数以及其个数确定), 但是其相对位置是不定的. 因此需要使用某种数据结构确定后的k个值(必须选的)记录一下, 然后遍历原数组. 若当前值还可以出现, 则加入答案, 当前值出现几次减一. 若当前值不可以出现了, 跳过即可. 支持上述操作的数据结构可以是哈希表、multiset等. Code1234567891011121314151617181920class Solution {public: vector&lt;int&gt; maxSubsequence(vector&lt;int&gt;&amp; nums, int k) { vector&lt;int&gt; cc = nums; sort(cc.begin(), cc.end(), greater&lt;int&gt;()); unordered_map&lt;int, int&gt; cnt; int n = nums.size(); for (int i = 0; i &lt; k; i ++ ) cnt[cc[i]] += 1; vector&lt;int&gt; ret; for (int i = 0; i &lt; n; i ++ ) { if (cnt[nums[i]] &gt; 0) { cnt[nums[i]] -= 1; ret.push_back(nums[i]); } } return ret; }}; 复杂度分析 时间复杂度$O(N * logN)$(排序的时间复杂度) 空间复杂度$O(N)$ 适合打劫银行的日子思路很有特点的一类题型.这类题型通常求数组中满足条件限制的所有下标. 条件限制通常为该下标处左右两边的一些性质. 本题的限制在从i往左右两边看, 连续time天都必须是非递减的. 解决这类题型的通用方法一般是先将问题进行转化, 然后使用递推(动态规划), 最后遍历数组找符合要求的下标. 考虑到左右对称, 以下就以左边为例进行分析. 问题转化. i往坐看连续time天都是非递减的, 可以将问题转化成i往坐看, 最多多少天非递减. 通过将问题转化成一个最值问题, 使用最值进行判定. 递推. 记**L[i]**为在i处往左看, 非递减的最大长度. 简单动态规划即可~ 若$nums[i] &lt;= nums[i - 1]$. 则 $L[i] = L[i - 1] + 1$ 若$nums[i] &gt; nums[i - 1]$. 则 $L[i] = 0$ 遍历原数组使用 L 和 R 求解符合要求的下标即可. Code12345678910111213141516171819202122232425class Solution {public: vector&lt;int&gt; goodDaysToRobBank(vector&lt;int&gt;&amp; nums, int time){ int n = nums.size(); vector&lt;int&gt; L(n, 0), R(n, 0); for (int i = 1; i &lt; n; i ++ ) { if (nums[i] &lt;= nums[i - 1]) L[i] = L[i - 1] + 1; } for (int i = n - 2; i &gt;= 0; i -- ) { if (nums[i] &lt;= nums[i + 1]) R[i] = R[i + 1] + 1; } vector&lt;int&gt; ret; for (int i = 0; i &lt; n; i ++ ) { if (i - time &gt;= 0 and i + time &lt; n) { if (L[i] &gt;= time and R[i] &gt;= time) ret.push_back(i); } } return ret; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 引爆最多的炸弹思路做题的时候题意理解错了, 上来直接并查集求最大的联通分量. WA的很快啊! 仔细看样例1才发现, 引爆不具有对称性. A引爆B时, B不一定引爆A. 首先将问题转化成一个图论问题(有向图). 每个圆看作一个点, 每条引爆关系看作一条边. 若A能引爆B, 则从点A连出一条边指向B.考虑到数据范围很小, 构建完有向图后, 直接对每个点暴力使用DFS, 计算以该点出发最多能到的点的个数. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution {public: int vis[100005]; vector&lt;vector&lt;int&gt;&gt; g; void dfs(int u) { vis[u] = 1; for (auto&amp; v : g[u]) { if (vis[v] == 0) dfs(v); } } int maximumDetonation(vector&lt;vector&lt;int&gt;&gt;&amp; nums) { int n = nums.size(); g.resize(n); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) { if (i == j) continue; long long dist = 1ll *(nums[i][0] - nums[j][0]) * (nums[i][0] - nums[j][0]) + 1ll * (nums[i][1] - nums[j][1]) * (nums[i][1] - nums[j][1]); long long r = 1ll * nums[i][2] * nums[i][2]; if (dist &lt;= r) { g[i].push_back(j); // cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; endl; } } int ret = 1; for (int i = 0; i &lt; n; i ++ ) { memset(vis, 0, sizeof(vis)); dfs(i); int cur = 0; for (int j = 0; j &lt; n; j ++ ) if (vis[j] == 1) cur += 1; ret = max(ret, cur); } return ret; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(N)$ 序列顺序查询思路使用平衡树的Get Value By Rank即可完成, 比赛中使用了python的sortedcontainers第三方库偷鸡了. Code123456789101112131415161718192021from sortedcontainers import SortedListclass SORTracker: def __init__(self): self.sl = SortedList() self.idx = 0 def add(self, name: str, score: int) -&gt; None: self.sl.add((-score, name)) def get(self) -&gt; str: ret = self.sl[self.idx] self.idx += 1 return ret[1]# Your SORTracker object will be instantiated and called as such:# obj = SORTracker()# obj.add(name,score)# param_2 = obj.get() 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2021/12/15/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D%E7%AC%AC67%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"[LeetCode-周赛]第70场双周赛","text":"Rank : 302/3638Solved : 4/4 竞赛链接 打折购买糖果的最小开销思路贪心. 还没有买到的糖果中, 最大和次大无法通过免费的方式获得, 必须通过买的方式, 买最大和次大的话贪心选择拿第三大作为免费的即可. Code123456789101112131415class Solution {public: int minimumCost(vector&lt;int&gt;&amp; cost) { sort(cost.begin(), cost.end(), greater&lt;int&gt;()); int ans = 0, n = cost.size(); for (int i = 0; i &lt; n; i += 3) { ans += cost[i]; if (i + 1 &lt; n) ans += cost[i + 1]; } return ans; }}; 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(1)$ 统计隐藏数组数目思路差分的运用. 通过对差分数组求其前缀和, 我们可以得到原数组中每个数与hidden[0]的差值. 然后通过枚举所有可能的hidden[0], 判断hidden[0]在某个取值下是否符合题意. 判断的方法是判断这种情况下最大值和最小值是否在合法范围内. Code1234567891011121314151617181920using LL = long long;class Solution {public: int numberOfArrays(vector&lt;int&gt;&amp; d, int L, int R) { int n = d.size(); vector&lt;LL&gt; sb(n); sb[0] = d[0]; for (int i = 1; i &lt; n; i ++ ) sb[i] = sb[i - 1] + d[i]; LL Mx = *max_element(begin(sb), end(sb)), Mn = *min_element(begin(sb), end(sb)); int ans = 0; for (int i = L; i &lt;= R; i ++ ) { LL curL = Mn + i, curR = Mx + i; if (curL &gt;= L and curL &lt;= R and curR &gt;= L and curR &lt;= R) ans += 1; } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 价格范围内最高排名的 K 样物品思路先求起点到每个点的最短路. 可以通过BFS算法求解. 接着按照题目的要求对合法点进行排序即可. cpp中可以使用set搭配使用tuple(结构化绑定, 写法简洁)或者vector实现. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using PII = pair&lt;int, int&gt;;using TII = tuple&lt;int, int, int, int&gt;;const int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};const int INF = 1e9;class Solution {public: vector&lt;vector&lt;int&gt;&gt; highestRankedKItems(vector&lt;vector&lt;int&gt;&gt;&amp; g, vector&lt;int&gt;&amp; p, vector&lt;int&gt;&amp; start, int k) { int L = p[0], R = p[1]; int n = g.size(), m = g[0].size(); int sx = start[0], sy = start[1]; vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(m, INF)); dist[sx][sy] = 0; queue&lt;PII&gt; qu; qu.emplace(sx, sy); while (qu.size()) { auto [x, y] = qu.front(); qu.pop(); for (int i = 0; i &lt; 4; i ++ ) { int nx = x + dx[i], ny = y + dy[i]; if (nx &gt;= 0 and nx &lt; n and ny &gt;= 0 and ny &lt; m and g[nx][ny]) { if (dist[nx][ny] == INF) { dist[nx][ny] = dist[x][y] + 1; qu.emplace(nx, ny); } } } } set&lt;TII&gt; st; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) { if (dist[i][j] == INF or g[i][j] &gt; R or g[i][j] &lt; L or g[i][j] == 1) continue; st.emplace(dist[i][j], g[i][j], i, j); } vector&lt;vector&lt;int&gt;&gt; ans; for (auto&amp; [d, p, i, j] : st) { if (ans.size() &lt; k) ans.push_back({i, j}); else break; } return ans; }}; 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ 分隔长廊的方案数思路前缀和优化动态规划. 首先将S看成1, P看成0, 对原数组求其前缀和. 并将前缀和存入map中.接着定义f[i]表示考虑前i个位置且在下标i的右边放屏风的方案数。为了求解f[i], 需要考虑上一个屏风所放的位置.若i之前有k个座位, 则第一个可以放屏风的位置是$L = mp[k - 2]$, 最后一个可以放屏风的位置是$R = mp[k - 1] - 1$.则有$f[i] = \\sum_{j=L}^{R}f[j]$, 由于其是一段连续的区间和, 因此可以使用前缀和的技巧进行优化. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int MOD = 1e9 + 7;using LL = long long;class Solution {public: int numberOfWays(string str) { int n = str.size(); vector&lt;int&gt; s(n + 1, 0); unordered_map&lt;int, int&gt; mp; mp[0] = 0; for (int i = 1; i &lt;= n; i ++ ) { int cur = (str[i - 1] == 'S'); s[i] = s[i - 1] + cur; // 哈希表记录每个前缀和出现的坐标 if (!mp.count(s[i])) mp[s[i]] = i; } int all = s[n]; if (all % 2) return 0; int ans = 0; vector&lt;LL&gt; f(n + 1); // 注：根据定义, f[0] = 1. f[0] = 1; for (int i = 1; i &lt;= n; i ++ ) { int cur = s[i]; f[i] = f[i - 1]; if (cur &lt; 2) continue; int L = mp[cur - 2], R = mp[cur - 1] - 1; int val; // 会存在下标越界的情况, 根据定义L可以去到0 if (L - 1 &lt;= 0) val = f[R]; else val = f[R] - f[L - 1]; if (i == n) ans = val % MOD; // f数组自身当作其前缀和数组 f[i] = (f[i] + val) % MOD; } // MOD成非负数 ans = (ans + MOD) % MOD; return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2022/01/22/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D%E7%AC%AC70%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"[LeetCode-周赛]277","text":"Rank : 859/5059Solved : 4/4 竞赛链接 元素计数思路模拟.统计严格大于最小值且严格小于最大值的数的个数. Code123456789101112class Solution {public: int countElements(vector&lt;int&gt;&amp; nums) { int Mx = *max_element(begin(nums), end(nums)), Mn = *min_element(begin(nums), end(nums)); int ans = 0; for (auto&amp; c : nums) { if (c != Mx and c != Mn) ans ++ ; } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(1)$ 按符号重排数组思路模拟. 将正数和负数分开存入数组, 然后按序构造答案. Code12345678910111213141516171819class Solution {public: vector&lt;int&gt; rearrangeArray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; neg, pos; for (auto&amp; c : nums) if (c &gt; 0) pos.push_back(c); else neg.push_back(c); vector&lt;int&gt; ans; int n = pos.size(); for (int i = 0; i &lt; n; i ++ ) { ans.push_back(pos[i]); ans.push_back(neg[i]); } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 找出数组中的所有孤独数字思路模拟. 使用哈希表计数并且判断x + 1和x - 1是否存在. Code12345678910111213141516class Solution {public: vector&lt;int&gt; findLonely(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; mp; for (auto&amp; c : nums) mp[c] ++ ; vector&lt;int&gt; ans; for (auto&amp; [k, v] : mp) { if (v &gt; 1) continue; if (mp.count(k + 1) == 0 and mp.count(k - 1) == 0) ans.push_back(k); } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 基于陈述统计最多好人数思路枚举. 使用二进制枚举好人可能的方案, 然后判断好人的陈述是否存在矛盾。坏人的陈述是不需要判断的, 因为他可能说真, 也可能说假, 即陈述对好坏划分是没有影响的。(比赛的时候理解错题了, 以为要么全真, 要么全假, 搞晕了) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: int maximumGood(vector&lt;vector&lt;int&gt;&gt;&amp; nums) { int n = nums.size(); int ans = 0; vector&lt;vector&lt;int&gt;&gt; state(n); for (int i = 0; i &lt; n; i ++ ) { int good = 0, bad = 0; for (int j = 0; j &lt; n; j ++ ) { if (nums[i][j] == 1) good |= (1 &lt;&lt; j); if (nums[i][j] == 0) bad |= (1 &lt;&lt; j); } state[i].push_back(good); state[i].push_back(bad); } for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ) { int cnt = __builtin_popcount(i); int good = 0, bad = 0; for (int j = 0; j &lt; n; j ++ ) { if (i &gt;&gt; j &amp; 1) good |= (1 &lt;&lt; j); else bad |= (1 &lt;&lt; j); } bool flag = true; for (int j = 0; j &lt; n; j ++ ) { if (i &gt;&gt; j &amp; 1) { if ((state[j][0] | good) != good) flag = false; if ((state[j][1] | bad) != bad) flag = false; } } if (flag) ans = max(ans, cnt); } return ans; }}; 复杂度分析 时间复杂度$O(N * 2^N)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2022/01/23/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D277/"},{"title":"[LeetCode-周赛]第71场双周赛","text":"Rank : 239/3028Solved : 4/4 竞赛链接 拆分数位后四位数字的最小和思路使用双重循环枚举new1, 然后使用单循环枚举new2, 注意此时每个new1对应两个new2. Code1234567891011121314151617181920212223242526class Solution {public: int minimumSum(int num) { int ans = INT_MAX; string s = to_string(num); int n = s.size(); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) { if (i == j) continue; string s1; s1.push_back(s[i]); s1.push_back(s[j]); string s2; for (int k = 0; k &lt; n; k ++ ) { if (k != i and k != j) s2.push_back(s[k]); } ans = min(ans, stoi(s1) + stoi(s2)); reverse(begin(s2), end(s2)); ans = min(ans, stoi(s1) + stoi(s2)); } return ans; }}; 复杂度分析 时间复杂度$O(N^3)$ 空间复杂度$O(N)$ 根据给定数字划分数组思路枚举. 将小于pivot、等于pivot和大于pivot的分别插入vector中, 然后合并即可. Code12345678910111213141516171819class Solution {public: vector&lt;int&gt; pivotArray(vector&lt;int&gt;&amp; nums, int p) { vector&lt;int&gt; a, b, c; for (auto&amp; num : nums) { if (num &lt; p) a.push_back(num); if (num == p) b.push_back(num); if (num &gt; p) c.push_back(num); } for (auto&amp; num : b) a.push_back(num); for (auto&amp; num : c) a.push_back(num); return a; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 设置时间的最少代价思路枚举时间, 首先注意前导0可以不要, 因此长度不足4的时候要注意分和秒的计算. 最后注意push的顺序(读错题WA了一发). Code123456789101112131415161718192021222324252627282930313233343536373839404142434445const int M = 10;class Solution {public: int minCostSetTime(int start, int moveCost, int pushCost, int tar) { int ans = INT_MAX; for (int i = 1; i &lt; 10000; i ++ ) { string s = to_string(i); string mill, sec; for (int j = s.size() -1; j &gt;= 0; j -- ) { if (sec.size() &lt; 2) sec.push_back(s[j]); else mill.push_back(s[j]); } reverse(begin(sec), end(sec)); reverse(begin(mill), end(mill)); int time = stoi(sec); if (mill.size()) time += stoi(mill) * 60; if (time != tar) continue; vector&lt;int&gt; cnt(M); for (auto&amp; c : s) cnt[c - '0'] ++ ; int cur = 0, prev = start + '0'; for (int j = 0; j &lt; s.size(); j ++) { cur += pushCost; if (s[j] != prev) cur += moveCost; prev = s[j]; } ans = min(ans, cur); // cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; cur &lt;&lt; endl; } return ans; }}; 复杂度分析 时间复杂度$O(M * N)$, M = 10, N = 10000 空间复杂度$O(M)$ 删除元素后和的最小差值思路首先枚举切割的位置, 右数组的开头可取的范围是从n + 1到2n + 1. 接着对于某个位置, 其差值的最小值是: 左边取最大的n个数, 而右边取最小的n个数.由于需要动态计算, 因此可以使用递推(动态规划)的思想提前预处理出来. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344using LL = long long;class Solution {public: long long minimumDifference(vector&lt;int&gt;&amp; nums) { multiset&lt;int&gt; left, right; int n = nums.size() / 3; vector&lt;LL&gt; L(3 * n + 1), R(3 * n + 1); LL sl = 0, sr = 0; for (int i = 1; i &lt;= n; i ++ ) left.insert(nums[i - 1]), sl += nums[i - 1], L[i] = sl; for (int i = 3 * n; i &gt; 2 * n; i -- ) right.insert(nums[i - 1]), sr += nums[i - 1], R[i] = sr; for (int i = n + 1; i &lt;= 2 * n; i ++ ) { int cur = nums[i - 1], Mx = *left.rbegin(); if (cur &lt; Mx) { sl = sl - Mx + cur; left.erase(left.find(Mx)); left.insert(cur); } L[i] = min(L[i - 1], sl); } for (int i = 2 * n; i &gt; n; i -- ) { int cur = nums[i - 1], Mn = *right.begin(); if (cur &gt; Mn) { sr = sr - Mn + cur; right.erase(right.find(Mn)); right.insert(cur); } R[i] = max(R[i + 1], sr); } LL ans = LLONG_MAX; for (int i = n + 1; i &lt;= 2 * n + 1; i ++ ) ans = min(ans, L[i - 1] - R[i]); return ans; }}; 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2022/02/05/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D%E7%AC%AC71%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"[LeetCode-周赛]279","text":"Rank : 226/4132Solved : 4/4 竞赛链接 对奇偶下标分别排序思路使用两个数组实现分别排序, 然后奇偶拼接即可. Code123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; sortEvenOdd(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; a, b; for (int i = 0; i &lt; n; i ++ ) { if (i % 2) b.push_back(nums[i]); else a.push_back(nums[i]); } sort(begin(a), end(a)); sort(begin(b), end(b), greater&lt;int&gt;()); vector&lt;int&gt; ret; for (int i = 0, j = 0; i &lt; a.size(); i ++, j ++ ) { ret.push_back(a[i]); if (j &lt; b.size()) ret.push_back(b[j]); } return ret; }}; 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ 重排数字的最小值思路贪心. 如果是负数, 则数字从大到小排序. 如果是正数, 从从小到大排序(注意前导零), 如果存在前导零, 则从小到大遍历, 将第一个非0数组与开头的0交换. Code123456789101112131415161718192021class Solution {public: long long smallestNumber(long long num) { string s = to_string(num); if (num &lt; 0) { sort(begin(s), end(s), greater&lt;char&gt;()); return -stoll(s); } sort(begin(s), end(s)); for (int i = 0; i &lt; s.size(); i ++ ) { if (s[i] != '0') { if (i == 0) break; swap(s[i], s[0]); break; } } return stoll(s); }}; 复杂度分析 时间复杂度$O(N * logN)$, 其中$N = log_{10}{num}$ 空间复杂度$O(N)$ 设计位集思路模拟. 可以通过数组vector以及1和0的计数器共同模拟除了翻转以外的所有操作. 麻烦的是翻转, 其无法暴力模拟. 因此可以设置一个flag, 表示是否翻转了. 某一位的值通过该位的值和flag共同决定. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Bitset {public: vector&lt;int&gt; s; int o, zero; int f; Bitset(int size) { f = 0; zero = size; o = 0; s.resize(size); } void fix(int idx) { int val = (s[idx] + f) % 2; if (val == 0) s[idx] = 1 - s[idx], o ++ , zero -- ; } void unfix(int idx) { int val = (s[idx] + f) % 2; if (val) s[idx] = 1 - s[idx], o -- , zero ++ ; } void flip() { swap(o, zero); f = (f + 1) % 2; } bool all() { return o == s.size(); } bool one() { return o; } int count() { return o; } string toString() { string ans; for (auto&amp; c : s) { int cur = (c + f) % 2; ans.push_back(cur + '0'); } return ans; }};/** * Your Bitset object will be instantiated and called as such: * Bitset* obj = new Bitset(size); * obj-&gt;fix(idx); * obj-&gt;unfix(idx); * obj-&gt;flip(); * bool param_4 = obj-&gt;all(); * bool param_5 = obj-&gt;one(); * int param_6 = obj-&gt;count(); * string param_7 = obj-&gt;toString(); */ 复杂度分析 时间复杂度$O(M * N + P)$, 其中M是toString的调用次数, P是其他操作的调用次数之和. 空间复杂度$O(N)$ 移除所有载有违禁货物车厢所需的最少时间思路首先枚举. 枚举1操作的结束位置, 对于某个1操作, 其对应了很多很多2和3操作的组合(2操作的边界以及1和2操作边界内的3操作), 但我们只关心其中的最少值对应的2和3操作的组合. 首先如果枚举到了i, 设2操作的边界为j(j &gt; i), 则有$Cost[i, j] = (i) + (n - j + 1) + (2 * (sum[j - 1] - sum[i]))$.其中sum是字符串的前缀和数组. 整理可得$Cost[i, j] = i + n - 2 * sum[i] + 2 * sum[j - 1] - (j - 1), j &gt; i$. 因此我们关心的是2 * sum[j - 1] - (j - 1), 只要让其取最小值即可. 这可以通过预处理的方式轻松实现. 记f[i] = 2 * sum[i] - i, 计算出f数组后处理其后缀最小值即可. Code12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int minimumTime(string s) { int n = s.size(); vector&lt;int&gt; sum(n + 1); for (int i = 1; i &lt;= n; i ++ ) { int cur = s[i - 1] - '0'; sum[i] = sum[i - 1] + cur; } // Mn: f数组的后缀最小值 vector&lt;int&gt; f(n + 2), Mn(n + 2); for (int i = 1; i &lt;= n; i ++ ) f[i] = 2 * sum[i] - i; // for (int i = 1; i &lt;= n; i ++ ) // cout &lt;&lt; &quot;f &quot; &lt;&lt; i &lt;&lt; ' ' &lt;&lt; f[i] &lt;&lt; endl; f[n + 1] = Mn[n + 1] = INT_MAX; for (int i = n; i &gt;= 0; i -- ) Mn[i] = min(f[i], Mn[i + 1]); // for (int i = 1; i &lt;= n; i ++ ) // cout &lt;&lt; &quot;min &quot; &lt;&lt; i &lt;&lt; ' ' &lt;&lt; Mn[i] &lt;&lt; endl; int ans = INT_MAX; for (int i = 0; i &lt;= n; i ++ ) { int cur = i + n - 2 * sum[i]; // cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; cur &lt;&lt; ' ' &lt;&lt; Mn[i] &lt;&lt; endl; cur += Mn[i]; ans = min(ans, cur); } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2022/02/06/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D279/"},{"title":"[LeetCode-周赛]280","text":"Rank : 379/5833Solved : 3/4 竞赛链接 得到 0 的操作数思路模拟. 按照题目要求模拟题意即可. Code123456789101112131415class Solution {public: int countOperations(int num1, int num2) { int step = 0; while (num1 and num2) { if (num1 &gt;= num2) num1 -= num2; else num2 -= num1; step ++ ; } return step; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(1)$ 使数组变成交替数组的最少操作数思路枚举. 首先可以发现题目要求奇数位置、偶数位置的值全部相同, 且奇数和偶数位置值不同. 因此我们只需计算最多能够保留多少个数字, 替换的次数为数组长度减去保留的数字个数。 为了计算保留了多少个数字, 枚举偶数位置保留哪一个数字, 然后计算奇数位置除去枚举数字后的频次最大值即可. Code123456789101112131415161718192021222324252627282930const int N = 1e5 + 5;class Solution {public: int cnt[N], L[N], R[N]; int minimumOperations(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; even; int n = nums.size(); for (int i = 0; i &lt; n; i ++ ) { if ((i &amp; 1) == 0) even[nums[i]] ++ ; else cnt[nums[i]] ++ ; } for (int i = 1; i &lt; N; i ++ ) L[i] = max(L[i - 1], cnt[i]); for (int i = N - 2; i &gt;= 1; i -- ) R[i] = max(R[i + 1], cnt[i]); int mx = 0; for (auto&amp; [k, v] : even) { int cur = v + max(L[k - 1], R[k + 1]); mx = max(mx, cur); } return n - mx; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 拿出最少数目的魔法豆思路枚举. 枚举最终的魔法豆数目, 计算小于该数目的总和以及严格大于该数目的总和. 小于该数目的总和可以使用前缀和计算. 严格大于该数目的总和部分需要预处理出个数, 然后用其前缀和减去个数乘以数目. Code12345678910111213141516171819202122232425262728293031using LL = long long;const int N = 1e5 + 5;class Solution {public: LL s[N], cnt[N]; long long minimumRemoval(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = 0; i &lt; n; i ++ ) { s[nums[i]] += nums[i]; cnt[nums[i]] += 1; } for (int i = 1; i &lt; N; i ++ ) s[i] += s[i - 1]; for (int i = N - 3; i &gt;= 1; i -- ) cnt[i] += cnt[i + 1]; LL ans = LLONG_MAX; for (int i = 0; i &lt; n; i ++ ) { int cur = nums[i]; LL left = s[cur - 1]; LL right = (s[N - 1] - s[cur]) - 1ll * cnt[cur + 1] * cur; ans = min(ans, left + right); } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ 数组的最大与和思路状态压缩DP. 由于每个篮子最多可以放两个, 因此构建2 * numSlots个篮子, 构建出的第一个和第numSlots个为原始的第一个篮子, 如果这两个篮子都放表示原来的第一个篮子放两个放满了. 用$f[i]$表示考虑构建出的篮子的状态为i, 且考虑了前cnt[i]个数字的最大价值.(cnt[i]表示状态i中1的个数, 即放数组的篮子个数). 为了计算f[i], 枚举nums[cnt[i]]放在了哪里即可. 赛时dp方程多定义了一维, 导致超时.赛后参考了0x3f佬的题解 Code1234567891011121314151617181920212223242526272829const int N = 20;int f[1 &lt;&lt; N];class Solution{public: int maximumANDSum(vector&lt;int&gt;&amp; nums, int numSlots) { int n = nums.size(); memset(f, 0, sizeof(f)); int m = numSlots * 2; for (int i = 0; i &lt; (1 &lt;&lt; m); i ++ ) { int cnt = __builtin_popcount(i); if (i &lt; 1 or cnt &gt; n) continue; for (int k = 0; k &lt; numSlots; k ++ ) { if (i &gt;&gt; k &amp; 1) f[i] = max(f[i], f[i - (1 &lt;&lt; k)] + (nums[cnt - 1] &amp; (k + 1))); int r = k + numSlots; if (i &gt;&gt; r &amp; 1) f[i] = max(f[i], f[i - (1 &lt;&lt; r)] + (nums[cnt - 1] &amp; (k + 1))); } } int ans = 0; for (int i = 0; i &lt; 1 &lt;&lt; m ; i ++ ) if (__builtin_popcount(i) == n) ans = max(ans, f[i]); return ans; }}; 赛时TLE代码 12345678910111213141516171819202122232425const int N = 20;int f[1 &lt;&lt; N][N];class Solution{public: int maximumANDSum(vector&lt;int&gt;&amp; nums, int numSlots) { int n = nums.size(); memset(f, 0, sizeof(f)); int m = numSlots * 2; for (int i = 0; i &lt; (1 &lt;&lt; m); i ++ ) { for (int j = 1; j &lt;= n; j ++ ) { for (int k = 0; k &lt; numSlots; k ++ ) { if (i &gt;&gt; k &amp; 1) f[i][j] = max(f[i][j], f[i - (1 &lt;&lt; k)][j - 1] + (nums[j - 1] &amp; (k + 1))); int r = k + numSlots; if (i &gt;&gt; r &amp; 1) f[i][j] = max(f[i][j], f[i - (1 &lt;&lt; r)][j - 1] + (nums[j - 1] &amp; (k + 1))); } } } int all = (1 &lt;&lt; m) - 1; return f[all][n]; }}; 复杂度分析 时间复杂度$O(N * 2^N)$ 空间复杂度$O(2^N)$ 欢迎讨论指正","link":"/2022/02/13/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D280/"},{"title":"[cpp]语言基础","text":"cpp语言的特点 cpp是一个语言联邦. 其是过程式语言（兼容包含c语言）、面向对象语言（有面向对象语言的封装、继承和多态的特点）、泛型语言（包含标准模板库STL, 有容器、迭代器、算法、适配器、仿函数和分配器）、函数式语言（cpp11引入匿名函数的特性）和元编程语言（TODO: 不懂). cpp是不断发展的语言, cpp11、cpp14、cpp17、cpp20引入了很多新的特性. cpp中struct和class的区别在cpp中struct和class只有很细微的差别. 从使用习惯上来说. strcut一般用作数据结构集合的描述, class用作类的定义（对象的封装）. struct中默认访问控制权限是 public 的, 而class默认访问控制权限是 private 的. 如: 123456struct A{ int iNum; // 默认访问控制权限是 public}class B{ int iNum; // 默认访问控制权限是 private} class 继承默认是 private 继承，而 struct 继承默认是 public 继承 class 支持泛型模板编程. 如STL. include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别 区别： 尖括号&lt;&gt;的头文件是系统文件，双引号””的头文件是自定义文件。 编译器预处理阶段查找头文件的路径不一样。 查找路径： 使用尖括号&lt;&gt;的头文件的查找路径：编译器设置的头文件路径(g++中通过-I参数, 如include opencv等第三方库时)–&gt;系统变量(如iostream、algorithm等编译器自带头文件)。 使用双引号””的头文件的查找路径：当前目录–&gt;编译器设置的头文件路径–&gt;系统变量 cpp结构体和C结构体的区别区别： C的结构体内不允许有函数存在，cpp允许有内部成员函数，且允许该函数是虚函数。 C的结构体对内部成员变量的访问权限只能是public，而cpp允许public,protected,private三种。 C语言的结构体是不可以继承的，cpp的结构体是可以从其他的结构体或者类继承过来的。 C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 cpp 中可以省略 struct 关键字直接使用。 导入C函数的关键字是什么，cpp编译时和C有什么不同？ 关键字：在cpp中，导入C函数的关键字是extern，表达形式为extern “C”， extern “C”的主要作用就是为了能够正确实现cpp代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是cpp的。 编译区别：由于cpp支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 1234567891011121314151617181920212223242526272829303132333435363738394041// 1. extern.h#ifndef __EXTERN#define __EXTERN// extern 声明extern int x;int mul(int x, int y);#endif /* __EXTERN */// 2. extern.cpp #include &quot;extern.h&quot;// 变量x的定义int x = 10;int mul(int x, int y) { return x * y;}// 3. main.cpp#include &lt;iostream&gt;using namespace std;// 声明是外部变量和函数, 在链接的时候重解析extern int x;extern int mul(int x, int y);int main() { cout &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; mul(x, x) &lt;&lt; endl; return 0;}/* 最终的效果: main.cpp 没有直接include extern.h, 通过 extern 方法访问了其函数和变量*/ 编译命令和执行结果 1234$ g++ main.cpp extern.cpp -o main.exe$ ./main.exe10100 cpp从代码到可执行二进制文件的过程cpp和C语言类似，一个cpp程序从源码到执行文件，有四个过程，预编译、编译、汇编、链接. 预编译：这个过程主要的处理操作如下：（1） 将所有的#define删除，并且展开所有的宏定义（2） 处理所有的条件预编译指令，如#if、#ifdef（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。（4） 过滤所有的注释（5） 添加行号和文件名标识。 编译：这个过程主要的处理操作如下：（1） 词法分析：将源代码的字符序列分割成一系列的记号。（2） 语法分析：对记号进行语法分析，产生语法树。（3） 语义分析：判断表达式是否有意义。（4） 代码优化：（5） 目标代码生成：生成汇编代码。（6） 目标代码优化： 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。 链接分为静态链接和动态链接。 静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。 优点: 速度快 缺点: 多次复制, 浪费空间 动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。 优点: 节省空间 缺点: 执行时才链接, 需要重定位寻址, 速度较慢. static关键字的作用cpp中static有限定作用域和改变存储特性的作用. 全局静态变量: static作用于全局变量时, 限定了该变量的作用范围为本文件. 若未初始化, 则存储于全局未初始化段(bss), 并初始化为0. 若初始化了, 则存储于data段. 局部静态变量: static作用于局部变量时, 改变了该变量的存储特性, 若未初始化, 则存储于全局未初始化段(bss), 并初始化为0. 若初始化了, 则存储于data段. 且该变量只会初始化一次. 这样的效果像是限定了作用域的全局变量, 而且避免了全局变量在其他区域被访问和修改. 静态函数: static作用于函数时, 限定了该函数的作用域, 其只能作用于该文件. 静态成员变量: static作用于类成员变量时, 其是申明, 必须要在外部进行定义. 这种方式改变了该变量的存储特性, 变成了类变量, 无需通过对象即可访问, 即变成了只能通过类进行访问的全局变量. 静态成员函数: static作用域类成员函数时, 该函数即为类函数, 无需通过对象即可访问, 而且只能访问静态成员变量, 且不能是虚函数, 且没有this指针. 数组和指针的区别 赋值：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝 存储方式: 数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，数组的存储空间，不是在静态区就是在栈上。 指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针所指向的存储空间大小不能确定, 而指针自身的存储空间大小是确定的。 求sizeof: 数组所占存储空间的内存大小：sizeof（数据类型）* 数组大小, $数组大小=sizeof(数组名) / sizeof(数据类型)$ 在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。 什么是函数指针，如何定义函数指针，有什么使用场景 概念：函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。 定义形式如下:123int func(int a); int (*f)(int a); // 定义函数指针变量ff = &amp;func; 函数指针的应用场景：回调（callback）。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫Callback。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;// 定义函数指针类型, 参数为一个int, 返回值为inttypedef int (*FuncPointer) (int x);int addOne(int x) { return x + 1;}int addTwo(int x) { return x + 2;}// 函数指针作为函数的参数int addYouWant(FuncPointer fp, int x) { return fp(x);}int main() { FuncPointer fp; fp = addOne; cout &lt;&lt; fp(5) &lt;&lt; endl; fp = addTwo; cout &lt;&lt; fp(5) &lt;&lt; endl; cout &lt;&lt; addYouWant(addOne, 5) &lt;&lt; endl; cout &lt;&lt; fp &lt;&lt; endl; return 0;} 静态变量什么时候初始化作用域：cpp里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。 对于C语言的全局和静态变量(int, char, double等)，初始化发生在任何代码执行之前，属于编译期初始化.而cpp标准规定：全局或静态对象当且仅当对象首次用到时才进行构造初始化。 cpp规定，const的静态成员可以直接在类内初始化(编译器初始化)，而非const的静态成员需要在类外声明以初始化。对于后一种情况，我们一般选择在类的实现文件中初始化(运行期初始化)。 生命周期：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存。 nullptr调用成员函数可以吗？为什么？1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;class animal {public: void sleep() { cout &lt;&lt; &quot;animal sleep&quot; &lt;&lt; endl; } void breathe() { cout &lt;&lt; &quot;animal breathe haha&quot; &lt;&lt; endl; }};class fish : public animal {public: void breathe() { cout &lt;&lt; &quot;fish bubble&quot; &lt;&lt; endl; }};int main() { animal *pAn = nullptr; // 编译器静态绑定: animal::breathe(pAn) animal::breathe 不是虚函数且没有解引用的行为, 因此可以正常运行 pAn-&gt;breathe(); // 输出：animal breathe haha // fish::breathe(pFish) 不是虚函数且没有解引用的行为, 因此可以正常运行 fish *pFish = nullptr; pFish-&gt;breathe(); // 输出：fish bubble return 0;} 这是cpp的静态绑定, 因为在编译时对象就绑定了函数地址，和指针空不空没关系。pAn-&gt;breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。 什么是野指针，怎么产生的，如何避免？ 概念：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的） 产生原因：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误, 或者返回了函数中的指向栈中变量的指针(指针指向的内存被释放掉了)。或者使用未初始化的指针(指针未初始化)。 避免办法：（1）初始化置NULL（2）申请内存后判空（3）指针释放后置NULL（4）使用智能指针 内联函数和宏函数的区别宏定义不是函数，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；而内联函数本质上是一个函数，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。宏函数是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；而内联函数则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率宏定义是没有类型检查的，无论对还是错都是直接替换；而内联函数在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等 1、使用时的一些注意事项： 使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。 2、内联函数使用的条件： 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联, 即inline为内联建议。 12345678910111213141516#include &lt;cstdio&gt;// 宏函数#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))// 内联函数inline int max(int a, int b) { if (a &gt; b) return a; return b;} int main() { printf(&quot;macro function %d\\n&quot;, MAX(10, 5)); printf(&quot;inline function %d\\n&quot;, max(10, 5));} 运算符i++和++i的区别 赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。 效率不同：后置++执行速度比前置的慢。 i++ 不能作为左值，而 ++i 可以 两者都不是原子操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;ostream&gt;using namespace std;template &lt;typename T&gt;class Interger { T val;public: Interger (T v) : val(v){} T getVal() const { return this -&gt; val; } // ++ i Interger&amp; operator ++ () { this -&gt; val += 1; return *this; } // i ++ Interger operator ++ (int) { Interger&lt;T&gt; tmp(this -&gt; val); this -&gt; val += 1; return tmp; }};template &lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const Interger&lt;T&gt;&amp; u) { os &lt;&lt; u.getVal(); return os;}int main() { Interger&lt;int&gt; a(10), b(10); cout &lt;&lt; a ++ &lt;&lt; endl; cout &lt;&lt; ++ b &lt;&lt; endl; Interger&lt;float&gt; c(3.14); cout &lt;&lt; c ++ &lt;&lt; endl; cout &lt;&lt; ++ c &lt;&lt; endl; return 0;/* 输出10113.145.14*/} new和malloc的区别，各自底层实现原理 new是操作符(cpp关键字)，而malloc是c语言的库函数(cstdlib)。 new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。 malloc需要给定申请内存的大小，返回的指针(void *)需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。 new可以被重载(operator new)；malloc不行 new分配内存更直接和安全。 new发生错误抛出异常(bad_alloc)，malloc失败返回值为NULL new支持数组, 使用new[]和delete[]支持. new和delete在自由存储区上动态申请和分配内存, malloc和free在操作系统堆上动态申请和分配内存 new和delete可以调用malloc和free, 反之则否. malloc和free搭配使用. 其从操作系统的堆(Heap)内存区动态申请和释放内存空间. 当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址（有点像操作系统的空闲区链表）。 new和delete搭配使用. 其从 自由存储区 动态分配内存. 自由存储区是cpp中new和delete运算符分配和释放对象抽象出的概念. 操作系统的堆(Heap)和自由存储区并不等价. 大多数情况下, cpp编译器默认使用堆作为自由存储区, 也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来实现. 而可以通过重载new运算符, 改用其他内存来实现内存的分配, 例如全局变量做的对象池，这时自由存储区就区别于堆了。 new底层实现：关键字new在调用构造函数的时候实际上进行了如下的几个步骤： 通过operator new函数动态申请一块内存. 调用构造函数初始化这块内存（为这个新对象添加属性） 返回指向对象的指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;new&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;sstream&gt;using namespace std;class MyString {private: string str;public: MyString (const string&amp; s): str(s) { cout &lt;&lt; endl &lt;&lt; &quot;call mystring constructor function&quot; &lt;&lt; endl; } ~MyString () = default; static void* operator new (size_t size) throw() { cout &lt;&lt; endl &lt;&lt; &quot;call mystring operator new function!&quot; &lt;&lt; endl; // maclloc 函数实现 operator new void* p = malloc(size); // 编译器自带的全局operator new 实现 // void *p = ::operator new(size); if (p == NULL) throw bad_alloc(); return p; } static void* operator new (size_t size, void* p) { cout &lt;&lt; endl &lt;&lt; &quot;place ment new called!&quot; &lt;&lt; endl; return p; } // 通过getline实现字符串分割 vector&lt;string&gt; split(char delim) { stringstream ss(this -&gt; str); string word; vector&lt;string&gt; ans; while (getline(ss, word, delim)) ans.emplace_back(word); return ans; }};void printSplit(MyString* s, char delim) { // 通过delim字符进行分隔 auto ans = s -&gt; split(delim); cout &lt;&lt; &quot;string split result : &quot; &lt;&lt; endl; for (auto&amp; c : ans) cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;split string end !&quot; &lt;&lt; endl;}int main() { MyString* s = new MyString(&quot;I am using cpp.&quot;); printSplit(s, ' '); // placement new: 在一块已经分配好的内存上调用构造函数, 不涉及内存的动态申请 s = new (s) MyString(&quot;Testing,PlaceMent,New!&quot;); printSplit(s, ','); return 0;}/* 输出call mystring operator new function!call mystring constructor functionstring split result :Iamusingcpp.split string end !place ment new called!call mystring constructor functionstring split result :TestingPlaceMentNew!split string end !*/ const和define的区别const用于定义常量；而define用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的区别有： const生效于编译的阶段；define生效于预处理阶段。 const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。 const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。 函数指针和指针函数的区别 定义: 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。 写法 12指针函数：int *func(int x,int y);函数指针：int (*func)(int x,int y) Top-Level Const和Low-Level Const 顶层const表示指针是个常量, 这种指针称为指针常量. 底层const表示指针所指的对象是常量, 称为常量指针. 用于声明引用的const都是底层const, 简称为常量引用, 其能绑定到非常量对象、字面值和一般表达式上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;int main() { int i = 0; int* const p1 = &amp;i; // 顶层const, 常量指针, p1是常量 const int ci = 42; // 顶层const, 无法修改ci的值 const int *p2 = &amp;ci; // 底层const, 允许修改p2的值, 无法修改p2指向的值 const int* const p3 = p2; // 左边是底层const, 右边是顶层const, 无法修改p3以及修改p3指向的内容 const int&amp; r = ci; // 用于声明引用的const都是底层const int x = 10; // 常量引用绑定到左值上, 无法通过引用修改该变量 const int&amp; r1 = x; // 常量引用绑定到表达式上, 该表达式为右值, 因此常量引用绑定到了一个临时对象上 const int&amp; r2 = x ++ ; cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl; x = 1234; cout &lt;&lt; &quot;修改原变量 x 为 &quot; &lt;&lt; x &lt;&lt; &quot; 后, 常量引用r1值变成 &quot; &lt;&lt; r1 &lt;&lt; &quot; , 常量引用r2值变成 &quot; &lt;&lt; r2 &lt;&lt; endl; float f = 3.14; // 常量引用类型和原始类型不匹配 const int&amp; r3 = f; f = 4.567; cout &lt;&lt; &quot;修改f后, r3值为: &quot; &lt;&lt; r3 &lt;&lt; endl; // 常量引用绑定到类型匹配的const对象上去 const int cx = 4; const int&amp; r4 = cx; // 常量引用绑定到字面量上 const int&amp; r5 = 9527; return 0;/* 输出x = 11修改原变量 x 为 1234 后, 常量引用r1值变成 1234 , 常量引用r2值变成 10修改f后, r3值为: 3*/} 使用指针需要注意什么 定义指针时，先初始化为NULL, 防止使用未初始化的指针(野指针). 调用函数返回指针后, 判断指针是否为NULL, 如malloc. new一般不需要, 其失败的话会触发bad_alloc异常. 指针指向的内存回收后, 置指针为NULL. 如free一块动态内存后, 需要置NULL. 不返回指针栈区的指针. 防止指针悬挂. 指针作为访问数组的方式时, 需要自行确定访问区域是否合法, 访问越界的内存空间会造成不可预知的问题. 内联函数和函数的区别，内联函数的作用 内联函数比普通函数多了关键字inline 内联函数避免了函数调用的开销；普通函数有调用的开销 普通函数在被调用的时候，需要寻址（函数入口地址）；内联函数不需要寻址。 内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句；普通函数没有这个要求。 内联函数的作用：内联函数在调用时，是将调用表达式用内联函数体来替换(展开)。避免函数调用的开销。 cpp有几种传值方式，之间的区别是什么？传参方式有这三种：值传递、引用传递、指针传递 值传递：形参即使在函数体内值发生变化，也不会影响实参的值（拷贝）； 引用传递：形参在函数体内值发生变化，会影响实参的值； 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值； 值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。 c语言函数调用中参数入栈顺序1234567891011121314151617181920#include &lt;stdio.h&gt;void foo(int x, int y, int z){ printf(&quot;x = %d at [%X]\\n&quot;, x, &amp;x); printf(&quot;y = %d at [%X]\\n&quot;, y, &amp;y); printf(&quot;z = %d at [%X]\\n&quot;, z, &amp;z);}int main(int argc, char *argv[]){ foo(100, 200, 300); return 0; /* 输出x = 100 at [61FF10]y = 200 at [61FF14]z = 300 at [61FF18]*/} 系统栈是向低地址方向生长的. 因此z在栈底, 而x在栈顶. 从而可以推断出参数的入栈顺序是从右到左. 一般c/cpp编译器都用cdecl函数调用约定: 函数参数按照从右向左的顺序入栈，函数调用者负责清除栈中的参数. 从右到左的原因是可以方便的处理可变参数的问题(如printf函数). 这样栈顶就是最左边的参数, 在编译器就可以确定函数的参数相对于栈顶的相对地址reference. 参考资料牛客网dian神","link":"/2022/02/16/cpp/%5Bcpp%5D%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"title":"[LeetCode-周赛]第72场双周赛","text":"Rank : 91/4311Solved : 4/4 竞赛链接 统计数组中相等且可以被整除的数对思路模拟.数据范围和数值范围都很小, 直接$O(N^2)$枚举. Code1234567891011121314class Solution {public: int countPairs(vector&lt;int&gt;&amp; nums, int k) { int ans = 0; int n = nums.size(); for (int i = 0; i &lt; n; i ++ ) for (int j = i + 1; j &lt; n; j ++ ) { if (nums[i] == nums[j] and (i * j) % k == 0) ans ++ ; } return ans; }}; 复杂度分析 时间复杂度$O(N^2)$ 空间复杂度$O(1)$ 找到和为给定整数的三个连续整数思路如果连续整数为x - 1、x、和x + 1. 则和为3x必为3的倍数. Code12345678910class Solution {public: vector&lt;long long&gt; sumOfThree(long long num) { using LL = long long; if (num % 3) return {}; LL mid = num / 3; return {mid - 1, mid, mid + 1}; } }; 复杂度分析 时间复杂度$O(1)$ 空间复杂度$O(1)$ 拆分成最多数目的偶整数之和思路贪心. 如果是奇数则无解. 如果是偶数. 从小到大枚举[2, 4, 6, 8, ...]如果可以选择则贪心的选择当前数, 总和减去当前数. 如果最优解没有选择当前数, 选了比当前数大的数, 那么可以调整最优解选当前数, 这样选的可能多了1, 且选的总和多了一部分. 可以将多的这部分加到最优解的选的最大值上去. 逐步将最优解调整成贪心解. Code12345678910111213141516171819202122class Solution {public: vector&lt;long long&gt; maximumEvenSplit(long long s) { using LL = long long; if (s % 2 or s &lt; 0) return {}; if (s == 0) return {0}; vector&lt;LL&gt; ans; for (LL i = 2; ; i += 2) { if (s - i &gt; i) { ans.push_back(i); s -= i; } else { ans.push_back(s); break; } } return ans; }}; 复杂度分析 时间复杂度$O(\\sqrt{N})$ 空间复杂度$O(\\sqrt{N})$ 统计数组中好三元组数目思路首先将问题转换成一个数组上的问题.因为两个数组都是一个排列, 因此可将[0, n - 1]的值映射成其在nums1[]中的下标. 这样映射完成后, nums2中的一个数值递增三元组, 其映射前的数值在原来的nums1中一定是从前到后按序出现的并且在原nums2中是按下标递增出现的. 满足题目要求的好三元组. 另一方面, 在原nums1[]中的按下标递增的三元组, 按照上述映射后, 其映射值在映射后的nums2[]一定按值递增. 这样, 最终求映射后数组的数值递增三元组即可. 为了求数组的递增三元组, 枚举中间值, 求其左边严格小于当前值的个数left和右边严格大于当前值的个数right. 则以当前值为中间值的递增三元组的个数为$left * right$. 枚举所有的中间位置即可. 动态的快速求左边或者右边严格当前值的个数的方法，可以使用树状数组. 且这道题无需离散化映射, 因为是[0, n - 1]的排列, 将其映射成[1, n]即可. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152inline int lowbit(int x) { return x &amp; -x;}void add(vector&lt;int&gt;&amp; nums, int x, int c) { int n = nums.size(); for (int i = x; i &lt; n; i += lowbit(i)) nums[i] += c;}int query(vector&lt;int&gt;&amp; nums, int x) { int n = nums.size(); int ans = 0; for (int i = x; i; i -= lowbit(i)) ans += nums[i]; return ans;}class Solution {public: long long goodTriplets(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { using LL = long long; int n = nums1.size(); map&lt;int, int&gt; f; for (int i = 0; i &lt; n; i ++ ) f[nums1[i]] = i; for (auto&amp; c : nums2) c = f[c] + 1; LL ans = 0; vector&lt;int&gt; L(n + 1, 0), R(n + 1, 0); for (int i = 1; i &lt;= n; i ++ ) add(R, i, 1); for (int i = 0; i &lt; n; i ++ ) { int cur = nums2[i]; // remove from right add(R, cur, -1); int left = query(L, cur - 1), right = query(R, n) - query(R, cur); ans += 1ll * left * right; // add to left add(L, cur, 1); } return ans; }}; 复杂度分析 时间复杂度$O(N * logN)$ 空间复杂度$O(N)$ 欢迎讨论指正","link":"/2022/02/19/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D%E7%AC%AC72%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"进程间通信的方式","text":"进程之间为了同步交互, 就需要进行进程之间的通信, 由于每个进程拥有独立的虚拟地址空间, 并且通过进程对应的页表记录虚拟页和物理内存页的映射. 因此需要提供额外的资源, 这份资源可以让目标进程获取以及操作来帮助不同进行之间完成通信. 而根据提供资源方法的不同, 造成了不同的进程间通信方式. 匿名管道匿名管道是进程之间通信的方式之一. 其方式是创建一个匿名管道实现父子\\兄弟进程通信, 通过内核缓冲区提供这份公开的资源用于通信. 操作系统实现对这块缓冲区的管理. 使得写进程只管写, 读进程只管读, 屏蔽了底层的具体实现过程. 主要特点 实现父子\\兄弟进程之间的通信 单向通信 面向字节流的服务 依赖文件系统 管道内部保持同步机制 依附于进程, 无法单独存在 测试样例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define BUFFSIZE 1024char buff[BUFFSIZE];int main() { // 文件描述符: fd[0]指向管道的读端,fd[1]指向管道的写端。fd[1]的输出是fd[0]的输入 int fd[2]; if (pipe(fd) == -1) { fprintf(stderr, &quot;pipe error!&quot;); return -1; } // fork进程 pid_t pid = fork(); if (pid == 0) { // 子进程关闭写 close(fd[1]); while (1) { char* msg = &quot;read from father process: &quot;; write(1, msg, strlen(msg)); int s = read(fd[0], buff, BUFFSIZE - 1); if (s &lt;= 0) break; // 将读入的数据输出到标准输出 write(1, buff, s); } // 结束读 char* readone = &quot;son process read done.\\n&quot;; write(1, readone, strlen(readone)); } else { // 父进程关闭读 close(fd[0]); int s = 0; // 从标准输入读入: 0-标准输入, 1-标准输出, 2-标准错误 while (s = read(0, buff, BUFFSIZE - 1), buff[0] != '\\n') { char* msg = &quot;write to son process: &quot;; write(1, msg, strlen(msg)); write(fd[1], buff, s); } // 结束写 char* writedone = &quot;father process write done.\\n&quot;; write(1, writedone, strlen(writedone)); } return 0;}/* 输出read from father process: Hi, Jsss ~write to son process: Hi, Jsss ~read from father process: Work Hard !write to son process: Work Hard !read from father process: Happy Life ~write to son process: Happy Life ~read from father process: Good Bye ~write to son process: Good Bye ~read from father process: father process write done.son process read done.*/ 命名管道匿名管道的局限在于通信进程只能是具有血缘关系的进程. 而更常见的情况是需要通信的双方不含有血缘关系. 针对这种情况, 命名管道就发挥作用了. 我们可能会比较熟悉Linux中常用的管道符 |. 它能将前一个进程的输出作为输入传入下一个进程, 快速的完成我们的一些需求. 如: 在某文件中查找特定字符及其位置. 123456789101112131415161718192021# cat 输出文件内容作为 grep的输入$ cat ubuntu_setup_env.sh | grep sudo -n8:SUDOERS_FILE=/etc/sudoers11:sudo apt-get update14:sudo apt remove -y --purge openssh-server15:sudo apt install -y openssh-server18:sudo apt install -y cmake gcc clang gdb valgrind build-essential21:sudo cp $SSHD_FILE ${SSHD_FILE}.`date '+%Y-%m-%d_%H-%M-%S'`.back22:sudo sed -i '/^Port/ d' $SSHD_FILE23:sudo sed -i '/^ListenAddress/ d' $SSHD_FILE24:sudo sed -i '/^UsePrivilegeSeparation/ d' $SSHD_FILE25:sudo sed -i '/^PasswordAuthentication/ d' $SSHD_FILE26:echo &quot;# configured by CLion&quot; | sudo tee -a $SSHD_FILE27:echo &quot;ListenAddress ${SSHD_LISTEN_ADDRESS}&quot; | sudo tee -a $SSHD_FILE28:echo &quot;Port ${SSHD_PORT}&quot; | sudo tee -a $SSHD_FILE29:echo &quot;UsePrivilegeSeparation no&quot; | sudo tee -a $SSHD_FILE30:echo &quot;PasswordAuthentication yes&quot; | sudo tee -a $SSHD_FILE32:sudo service ssh --full-restart35:sed -i '/^sudo service ssh --full-restart/ d' ~/.bashrc36:echo &quot;%sudo ALL=(ALL) NOPASSWD: /usr/sbin/service ssh --full-restart&quot; | sudo tee -a $SUDOERS_FILE40: sudo service ssh --full-restart 查看进程的状态 1234$ ps aux | grep sshroot 377 0.0 0.0 12180 3068 ? Ss 19:21 0:00 sshd: /usr/sbin/sshd [listener] 0 of 10-100 startupsjsss 768 0.0 0.0 8164 728 pts/5 S+ 20:06 0:00 grep --color=auto ssh#USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 主要特点 单向通信 支持任意进程间通信 依赖于文件系统 测试样例1234567891011121314151617181920212223242526// read.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt; #define BUFFSIZE 1024char buff[BUFFSIZE];int main() { // 从管道读取 FILE* fp = fopen(&quot;fifo&quot;, &quot;r&quot;); if (fp == NULL) { fprintf(stderr, &quot;fopen error&quot;); return -1; } while (fgets(buff, BUFFSIZE - 1, fp) != NULL) printf(&quot;read from FIFO: %s\\n&quot;, buff); fclose(fp); printf(&quot;read over!&quot;); return 0;} 123456789101112131415161718192021222324252627282930313233// write.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include&lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt; #define BUFFSIZE 1024char buff[BUFFSIZE];int main() { // 文件必须不存在 int st = mkfifo(&quot;fifo&quot;, 0644); if (st != 0) { fprintf(stderr, &quot;mkfifo error\\n&quot;); return -1; } // 写入管道 FILE* fp = fopen(&quot;fifo&quot;, &quot;w&quot;); if (fp == NULL) { fprintf(stderr, &quot;fopen error\\n&quot;); return -1; } for (int i = 10; i &lt;= 20; i ++ ) fprintf(fp, &quot;cur = %d\\n&quot;, i); fclose(fp); printf(&quot;write over!\\n&quot;); return 0;} 1234567891011121314151617181920212223242526# 先写后读, 运行结果read from FIFO: cur = 10read from FIFO: cur = 11read from FIFO: cur = 12read from FIFO: cur = 13read from FIFO: cur = 14read from FIFO: cur = 15read from FIFO: cur = 16read from FIFO: cur = 17read from FIFO: cur = 18read from FIFO: cur = 19read from FIFO: cur = 20$ ls -alprw-r--r-- 1 jsss jsss 0 Feb 28 22:20 fifo# fifo的文件类型为p : 即命名管道文件 信号量信号量是本质上是一个计数器, 用于控制多个共享进程对临界资源的访问. 信号量是操作系统内核所处理的, 因此不同的进程都可以访问的到信号量及其值. 从而实现多进程间的同步. 信号量主要支持两种操作, 且这两种操作均为原子操作, 即不会被打断: P操作. P操作是申请资源, 让信号量的值减1. 如果信号量值大于0, 则申请成功; 如果值为小于等于0, 就阻塞等待, 直到信号量值大于0被唤醒. V操作. V操作是释放资源, 让信号量的值加1. 如果有进程被信号量阻塞, 则唤醒; 如果没有则给信号量值加1. 主要特点 操作系统提供了一组关于信号量的同步访问临界资源的函数 一般和共享内存方法搭配使用进行进程间通信 初始值为1的信号量可以看做互斥锁. 因为同一时刻最多一个进程可以申请持有该信号量. 需要显式删除. 可以在代码中使用semctl函数删除. 也可以在终端下使用ipcrm -s命令删除. 测试样例测试样例和共享内存一起在下面给出, 是一个简单的生产者-消费者模型. 共享内存共享内存允许多个进程共享同一个物理内存区域以实现进行之间的通信. 其核心思路是不同进程的页表中包含了同一块物理内存, 而虚拟内存页可以是不同的. 基本流程是先向内核申请一块共享内存区域, 接着将该内存区域映射到进程的虚拟地址空间, 从而实现不同进程操作同一块共享内存区域, 实现进程间通信. 主要特点 直接在内存中操作, 速度较快 支持任意进程间通信 未提供同步机制, 需要自行利用信号量等实现进程间同步 支持双向通信 需要显式删除. 可以在代码中使用shmctl函数删除. 也可以在终端下使用ipcrm -m命令删除. 测试样例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172// shmwrite#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;// 缓冲区大小#define MAXN 10// 生产者生产总数#define ALL 20// 临界资源typedef struct buff { int arr[MAXN]; int finish; int curIdx;} Buff;// 用作初始化信号量的结构union semun{ int val; //使用的值 struct semid_ds *buf; // IPC_STAT、IPC_SET 使用的缓存区 unsigned short *arry; // GETALL、SETALL 使用的数组 struct seminfo *__buf; // IPC_INFO(Linux特有) 使用的缓存区 }; // 信号量初始化为给定值int initSem(int semid, int value);// P操作函数int P(int semid);// V操作函数int V(int semid);// 获取信号量值int getSem(int semid);// 删除信号量int deleteSem(int semid);int main() { // 创建一块共享内存, 返回共享内存标识. 参数key_t是长整型（唯一非零）, 系统建立IPC通讯 （ 消息队列、 信号量和 共享内存） 时必须指定一个ID值. int shmid = shmget((key_t)9527, sizeof(Buff), IPC_CREAT | 0644); if (shmid == -1) { fprintf(stderr, &quot;create shared memory error!\\n&quot;); return -1; } // 将共享主存attach到当前进程, 即映射到当前进程的虚拟内存空间 // shm指针指向共享内存区 Buff* shm = (Buff*)shmat(shmid, 0, 0); shm -&gt; finish = 0, shm -&gt; curIdx = -1; if ((void*)shm == (void*)-1) { fprintf(stderr, &quot;shmat error!\\n&quot;); return -1; } /* 创建信号量用于同步临界区代码. 参数key是整数值（唯一非零），不相关的进程可以通过它访问一个信号量， 它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用semget()函数并提供一个键， 再由系统生成一个相应的信号标识符（semget()函数的返回值），只有semget()函数才直接使用信号量键， 所有其他的信号量函数使用由semget()函数返回的信号量标识符。如果多个程序使用相同的key值，key将负责协调工作。 empty 记录空缓冲区的数量，full 记录满缓冲区的数量 */ int semid_empty = semget((key_t)99999, 1, IPC_CREAT | 0644); int semid_full = semget((key_t)66666, 1, IPC_CREAT | 0644); int semid_mutex = semget((key_t)12345, 1, IPC_CREAT | 0644); // 初始化 if (initSem(semid_empty, MAXN) == -1 || initSem(semid_full, 0) == -1 || initSem(semid_mutex, 1) == -1) { fprintf(stderr, &quot;init sem error!\\n&quot;); return -1; } int cnt = 0; while (cnt &lt; ALL) { // 先检查是否可以生产 P(semid_empty); // 申请互斥锁mutex进行生产 P(semid_mutex); // 临界区 srand((unsigned int)time(NULL)); ++ (shm -&gt; curIdx); shm -&gt; arr[shm -&gt; curIdx] = cnt; ++ cnt; printf(&quot;produce cur-val = %d, curIdx = %d, empty size = %d\\n&quot;, cnt, shm-&gt;curIdx, getSem(semid_empty)); // 释放锁以及一块满缓冲区 V(semid_mutex); V(semid_full); } // 等待消费者消费完成 while (!(shm -&gt; finish)) {} //把共享内存从当前进程中分离 if (shmdt(shm) == -1) { fprintf(stderr, &quot;shmdt error!\\n&quot;); return -1; } // 删除共享内存 if (shmctl(shmid, IPC_RMID, 0) == -1) { fprintf(stderr, &quot;shmctl error!\\n&quot;); return -1; } // 删除信号量 if (deleteSem(semid_full) == -1 || deleteSem(semid_empty) == -1 || deleteSem(semid_mutex) == -1) { fprintf(stderr, &quot;deleteSem error!\\n&quot;); return -1; } printf(&quot;write done!\\n&quot;); return 0;}int initSem(int semid, int value) { // 信号量初始化 union semun sem; sem.val = value; // semctl函数使用 SETVAL 初始化信号量 if (semctl(semid, 0, SETVAL, sem) == -1 ) return -1; return 0;}int P(int semid) { struct sembuf sem; sem.sem_num = 0; // 信号量编号为0 sem.sem_op = -1; // -1 表示 P操作 sem.sem_flg = SEM_UNDO; // 通常设置为SEM_UNDO,使操作系统跟踪信号量，并在进程没有释放该信号量而终止时，操作系统释放信号量 if (semop(semid, &amp;sem, 1) == -1) return -1; return 0;}int V(int semid) { struct sembuf sem; sem.sem_num = 0; // 信号量编号为0 sem.sem_op = 1; // -1 表示 P操作 sem.sem_flg = SEM_UNDO; // 通常设置为SEM_UNDO,使操作系统跟踪信号量，并在进程没有释放该信号量而终止时，操作系统释放信号量 if (semop(semid, &amp;sem, 1) == -1) return -1; return 0; }int getSem(int semid) { int ret = semctl(semid, 0, GETVAL); return ret;}int deleteSem(int semid) { union semun sem; if (semctl(semid, 0, IPC_RMID, sem) == -1) return -1; return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156// shmread#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt; // 缓冲区大小#define MAXN 10// 生产者生产总数#define ALL 20// 临界资源typedef struct buff { int arr[MAXN]; int finish; int curIdx;} Buff;// 用作初始化信号量的结构union semun{ int val; //使用的值 struct semid_ds *buf; // IPC_STAT、IPC_SET 使用的缓存区 unsigned short *arry; // GETALL、SETALL 使用的数组 struct seminfo *__buf; // IPC_INFO(Linux特有) 使用的缓存区 }; // 信号量初始化为给定值int initSem(int semid, int value);// P操作函数int P(int semid);// V操作函数int V(int semid);// 获取信号量值int getSem(int semid);// 删除信号量int deleteSem(int semid);int main() { // 创建一块共享内存, 返回共享内存标识. 参数key_t是长整型（唯一非零）, 系统建立IPC通讯 （ 消息队列、 信号量和 共享内存） 时必须指定一个ID值. int shmid = shmget((key_t)9527, sizeof(Buff), IPC_CREAT | 0644); if (shmid == -1) { fprintf(stderr, &quot;create shared memory error!\\n&quot;); return -1; } // 将共享主存attach到当前进程, 即映射到当前进程的虚拟内存空间 // shm指针指向共享内存区 Buff* shm = (Buff*)shmat(shmid, 0, 0); if ((void*)shm == (void*)-1) { fprintf(stderr, &quot;shmat error!\\n&quot;); return -1; } /* 创建信号量用于同步临界区代码. 参数key是整数值（唯一非零），不相关的进程可以通过它访问一个信号量， 它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用semget()函数并提供一个键， 再由系统生成一个相应的信号标识符（semget()函数的返回值），只有semget()函数才直接使用信号量键， 所有其他的信号量函数使用由semget()函数返回的信号量标识符。如果多个程序使用相同的key值，key将负责协调工作。 empty 记录空缓冲区的数量，full 记录满缓冲区的数量 */ int semid_empty = semget((key_t)99999, 1, 0644); int semid_full = semget((key_t)66666, 1, 0644); int semid_mutex = semget((key_t)12345, 1, 0644); if (semid_full == -1 || semid_empty == -1 || semid_mutex == -1) { fprintf(stderr, &quot;semget error!\\n&quot;); return -1; } int cnt = 0; // 消费者进行消费 while (cnt &lt; ALL) { // 先检查是否可以消费 P(semid_full); // 申请互斥锁mutex进行消费 P(semid_mutex); // 临界区 ++ cnt; printf(&quot;consume cur-val = %d, curIdx = %d, full size = %d\\n&quot;, shm-&gt;arr[shm-&gt;curIdx] , shm-&gt;curIdx, getSem(semid_full)); -- (shm -&gt; curIdx); if (cnt == ALL) shm -&gt; finish = 1; // 释放锁以及一块空缓冲区 V(semid_mutex); V(semid_empty); } //把共享内存从当前进程中分离 if (shmdt(shm) == -1) { fprintf(stderr, &quot;shmdt error!\\n&quot;); return -1; } printf(&quot;read done!\\n&quot;); return 0;}int initSem(int semid, int value) { // 信号量初始化 union semun sem; sem.val = value; // semctl函数使用 SETVAL 初始化信号量 if (semctl(semid, 0, SETVAL, sem) == -1 ) return -1; return 0;}int P(int semid) { struct sembuf sem; sem.sem_num = 0; // 信号量编号为0 sem.sem_op = -1; // -1 表示 P操作 sem.sem_flg = SEM_UNDO; // 通常设置为SEM_UNDO,使操作系统跟踪信号量，并在进程没有释放该信号量而终止时，操作系统释放信号量 if (semop(semid, &amp;sem, 1) == -1) return -1; return 0;}int V(int semid) { struct sembuf sem; sem.sem_num = 0; // 信号量编号为0 sem.sem_op = 1; // 1 表示 V 操作 sem.sem_flg = SEM_UNDO; // 通常设置为SEM_UNDO,使操作系统跟踪信号量，并在进程没有释放该信号量而终止时，操作系统释放信号量 if (semop(semid, &amp;sem, 1) == -1) return -1; return 0; }int getSem(int semid) { int ret = semctl(semid, 0, GETVAL); return ret;}int deleteSem(int semid) { union semun sem; if (semctl(semid, 0, IPC_RMID, sem) == -1) return -1; return 0;} 执行结果: 12345678910111213141516171819202122$ ./shmwrite.o produce cur-val = 1, curIdx = 0, empty size = 9produce cur-val = 2, curIdx = 1, empty size = 8produce cur-val = 3, curIdx = 2, empty size = 7produce cur-val = 4, curIdx = 3, empty size = 6produce cur-val = 5, curIdx = 4, empty size = 5produce cur-val = 6, curIdx = 5, empty size = 4produce cur-val = 7, curIdx = 6, empty size = 3produce cur-val = 8, curIdx = 7, empty size = 2produce cur-val = 9, curIdx = 8, empty size = 1produce cur-val = 10, curIdx = 9, empty size = 0produce cur-val = 11, curIdx = 2, empty size = 7produce cur-val = 12, curIdx = 2, empty size = 7produce cur-val = 13, curIdx = 2, empty size = 7produce cur-val = 14, curIdx = 2, empty size = 7produce cur-val = 15, curIdx = 2, empty size = 7produce cur-val = 16, curIdx = 2, empty size = 7produce cur-val = 17, curIdx = 2, empty size = 7produce cur-val = 18, curIdx = 2, empty size = 7produce cur-val = 19, curIdx = 2, empty size = 7produce cur-val = 20, curIdx = 2, empty size = 7write done! 12345678910111213141516171819202122$ ./shmread.o consume cur-val = 9, curIdx = 9, full size = 9consume cur-val = 8, curIdx = 8, full size = 8consume cur-val = 7, curIdx = 7, full size = 7consume cur-val = 6, curIdx = 6, full size = 6consume cur-val = 5, curIdx = 5, full size = 5consume cur-val = 4, curIdx = 4, full size = 4consume cur-val = 3, curIdx = 3, full size = 3consume cur-val = 2, curIdx = 2, full size = 2consume cur-val = 10, curIdx = 2, full size = 2consume cur-val = 11, curIdx = 2, full size = 2consume cur-val = 12, curIdx = 2, full size = 2consume cur-val = 13, curIdx = 2, full size = 2consume cur-val = 14, curIdx = 2, full size = 2consume cur-val = 15, curIdx = 2, full size = 2consume cur-val = 16, curIdx = 2, full size = 2consume cur-val = 17, curIdx = 2, full size = 2consume cur-val = 18, curIdx = 2, full size = 2consume cur-val = 19, curIdx = 2, full size = 2consume cur-val = 1, curIdx = 1, full size = 1consume cur-val = 0, curIdx = 0, full size = 0read done! ipcs 查看共享内存和信号量的使用情况. 12345678910111213$ ipcs------ Message Queues --------key msqid owner perms used-bytes messages ------ Shared Memory Segments --------key shmid owner perms bytes nattch status 0x00002537 18 jsss 644 48 1 ------ Semaphore Arrays --------key semid owner perms nsems 0x0001869f 54 jsss 644 1 0x0001046a 55 jsss 644 1 0x00003039 56 jsss 644 1 执行流程: 先执行了shmwrite进行生产, 因此很快缓冲区被填满. 接着执行ipcs查看IPC的使用情况. 最后执行shmread进行消费, 消费了前八个后基本就是生产一个消费一个的动态平衡状态. 参考资料 信号量 信号量 信号量 共享内存","link":"/2022/02/28/OS/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"title":"无锁队列的原理和实现","text":"无锁队列是指多线程对于队列的操作无需添加粒度较大的独占锁mutex, 而是通过细粒度的CAS(compare and swap)原子操作实现多线程下的同步. 其主要思想是: 使用mutex的锁的代价太高, 那就使用更小粒度的锁, 甚至这个锁的粒度是一条赋值指令. 很多情况下, 一个完整事件的处理流程可以拆分成几个子事件. 虽然各子事件有顺序关系, 但无强烈的时间上的约束. 这样当该阶段处理完成后, 我们可以给下一个阶段传递一条消息. 下阶段接收到消息后, 再进行处理. 这里传递消息的数据结构可以是无锁队列. 保证了高并发和分布式场景下的快速处理需求和一定的前后顺序. 这就类似于生产者-消费者问题: 多个生产者产生多个事件, 给下一阶段的消费者处理. 本篇博客主要参考了酷壳陈皓关于无锁队列的讲解博客以及原始的论文-Implementing Lock-Free Queues和改进的论文-Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms. CAS操作Compare And Swap (CAS)是现代操作系统支持的原子性操作, 如X86中CMPXCHG汇编指令. 其实现逻辑如下: 12345678bool compare_and_swap(int *addr, int oldVal, int newVal){ if (*addr != oldVal) return false; *addr = newVal; return true;} addr指向内存中的某个变量, 如果该内存值为oldVal, 那么就将其置newVal并返回成功; 否则直接返回失败. 有了CAS操作, 多线程情况下我们可以保证某个共享变量值为我们期待值时才执行某些操作, 从而实现同步. GCC的CAS 12bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...) cpp11的CAS 123456template&lt; class T &gt;bool atomic_compare_exchange_weak( std::atomic* obj, T* expected, T desired );template&lt; class T &gt;bool atomic_compare_exchange_weak( volatile std::atomic* obj, T* expected, T desired ); 逻辑实现可以通过链表或数组实现. 数组实现的话由于数组大小需要指定而队列长度不一定知道, 因此需要实现循环队列. 存在一定的局限性. 基于链表的实现用链表实现队列的时候, 为了避免麻烦的边界判断, 我们可以添加头结点. 初始化时申请头结点, 并且head指针和tail指针均指向该结点. 入队操作 设入队新建结点的指针为p, 则p -&gt; next = nullptr, 入队操作需要两步实现. tail -&gt; next = p tail = p 为了保证第一步的并发正确性. 我们持续不断获取tail的快照, 记为cur. 直到CAS(cur -&gt; next, nullptr, p). 即如果cur -&gt; next = nullptr成立, 则当前cur一定为正确的tail. 接着我们将cur -&gt; next更新成p. 这样是正确的. 因为当某个线程执行完这一步后. tail指针还未更新成p, 这样其他所有线程都在轮询等待tail指针的next为空, 无法入队. 当轮询完成第一步后, 我们退出循环. 然后执行CAS(tail, cur, p). 即将尾指针置为新入队结点. 结点定义 12345678910 // 使用cpp11实现, 用了atomic类对象的方法实现CAS操作 // 结点定义 struct Node { T val; atomic&lt;Node*&gt; next; Node () : val(T()), next(atomic&lt;Node*&gt;(nullptr)) {} Node (const T&amp; _v) : val(_v), next(atomic&lt;Node*&gt;(nullptr)){} Node (const T&amp; _v, atomic&lt;Node*&gt; _next) : val(_v), next(_next) {}}; 入队(VERSION-1) 1234567891011121314151617// VERSION-1void enqueue(T _val) { // p指向插入结点 Node* p = new Node(_val); Node* cur; // Node* null = nullptr; while (true) { cur = tail.load(); // CAS(cur -&gt; next, nullptr, p) if (cur -&gt; next.compare_exchange_weak(null, p) == true) break; } // CAS(tail, cur, p) tail.compare_exchange_weak(cur, p);} 以上操作的流程会出现一个问题. 因为只有入队的线程才能将tail指针更新, 因此如果该线程入队后还未更新tail就结束了. 那么其他所有入队线程都将死锁. 因为他们CAS(cur -&gt; next, nullptr, p)时, cur -&gt; next一定不为空, 此时可能出现cur -&gt; next = p. 为了解决上述可能存在的问题. 我们主要解决思路是让其他线程也可以移动tail指针. 一个简单的方法是, 如果当前线程CAS(cur -&gt; next, nullptr, p)入队失败了, 那么说明当前cur不是真正的tail, 那么我们尝试CAS(tail, cur, cur -&gt; next). 即尝试让tail往后走. 然后再获取tail的快照, 按照之前的流程轮询(Retry-loop). 入队(VERSION-2) 123456789101112131415161718192021// VERSION-2void enqueue(T _val) { // p指向插入结点 Node* p = new Node(_val); Node* cur; // Node* null = nullptr; while (true) { cur = tail.load(); // CAS(cur -&gt; next, nullptr, p) if (cur -&gt; next.compare_exchange_weak(null, p) == true) break; // CAS(tail, cur, cur -&gt; next) else tail.compare_exchange_weak(cur, cur -&gt; next) } // CAS(tail, cur, p) tail.compare_exchange_weak(cur, p);} 较为复杂的方法是, 获取tail的快照cur, 并记录cur -&gt; next为next. 接着判断cur是否为tail. 如果不为就重新开始. 然后判断next是否为空. 如果不为空, 我们就尝试更新tail, 更新的语句是CAS(tail, cur, next). 如果为空. 我们就尝试CAS(tail -&gt; next, next, p)入队(此时next = nullptr). 入队(VERSION-3) 12345678910111213141516171819202122232425void enqueue (T _val) { // 插入结点为p Node* p = new Node(_val); Node *cur, *next; Node* null = nullptr; while (true) { // cur 指针为尾结点的快照 cur = tail.load(); // next 指针为为尾结点下一个结点 next = cur -&gt; next; // 如果尾指针被移动, 则重新获取cur和next (可能被其他线程移动了, 重新获取以减少CAS操作次数) if (cur != tail.load()) continue; if (next != nullptr) { // 当next指针不为空时, 尝试移动tail指针, 防止出现死锁 tail.compare_exchange_weak(cur, next); continue; } // 实现第一步操作: tail -&gt; next = p if (cur-&gt;next.compare_exchange_weak(null, p) == true) break; } // 实现第二步操作: tail = p tail.compare_exchange_weak(cur, p);}; 出队操作 出队操作类似于入队操作的思路. 我们首先获取head的快照cur. 然后判断cur -&gt; next是否为空, 如果为空说明此时队列为空, 返回队列为空的信号. 如果不为空, 我们CAS(head, cur, cur -&gt; next)来重置head的指针. 然后返回cur -&gt; next -&gt; val, 因为此时cur指向之前的头结点, cur -&gt; next -&gt; val为出队前的队头. 出队(VERSION-1) 1234567891011121314151617 bool dequeue (T&amp; _ret) { // 返回true: 出队成功, 返回值存在 _ret参数中 Node* cur; while (true) { cur = head.load(); if (cur -&gt; next == nullptr) return false; // CAS(head, cur, cur -&gt; next) if (head.compare_exchange_weak(cur, cur -&gt; next)) break; } _ret = cur -&gt; next -&gt; val; // 释放原头结点 delete cur; return true;} 上述思路存在几个问题. 首先比较严重的是, 如果我们CAS(head, cur, cur -&gt; next)成功了, 也就是逻辑上执行了head = head -&gt; next, 此时如果另外一个线程也执行了出队操作, 并且已经将队头free掉了. 那我们再访问cur -&gt; next -&gt; val时明显就出现了访问非法内存. 因此一个核心问题是: 在获取到其队头元素值之前, 其他线程不能执行出队操作. 为了保证队头结点不被free掉. 我们可以在CAS操作之前访问. 这样保证CAS操作成功后, 我们一定已经拿到了队头. 即使此时其他线程执行出队操作. 也不影响该线程的正确性. 具体而言, 我们定义一个next指针, 初始next = cur -&gt; next. 然后判断cur是否等于head. 如果不等于则重新获取快照(减少不必要的CAS操作). 如果等于, 接着判断next是否为空, 如果为空说明此时队列为空, 返回. 接着先记录next结点的值, 然后尝试通过CAS操作移动head. 即CAS(head, cur, cur -&gt; next). 出队(VERSION-2) 123456789101112131415161718192021222324 bool dequeue (T&amp; _ret) { Node *cur, *next; while (true) { cur = head.load(); next = cur-&gt;next; // 如果头指针被移动, 则重新获取其快照 (可能被其他线程移动了, 重新获取以减少CAS操作次数) if (cur != head.load()) continue; // 队列为空, 出队失败 if (next == nullptr) return false; // 在CAS操作前记录返回值, 如果在CAS操作之后则该结点有可能被其他线程free _ret = next-&gt;val; // 实现出队的操作. head = head -&gt; next if (head.compare_exchange_weak(cur, next)) break; } // 释放原头结点 delete cur; return true;} 上述版本还存在一个问题. 如果在判断next == nullptr时, 一个入队操作执行完成了第一步, 还没移动tail指针. 此时如果队列只有这个一个元素. 那么head = tail 且 next = p. 出队的话会将tail指向被free的原头结点. 具体图示可以查看酷壳陈皓关于无锁队列的讲解博客 解决的思路和入队解决死锁的思路是一样的. 即当我们发现head == tail 且 next != nullptr时, 我们尝试更新tail即可. 出队(VERSION-3) 123456789101112131415161718192021222324252627282930bool dequeue (T&amp; _ret) { Node *nowHead, *nowTail, *next; while (true) { nowHead = head.load(), nowTail = tail.load(); next = nowHead -&gt; next; // 如果头指针被移动, 则重新获取其快照 (可能被其他线程移动了, 重新获取以减少CAS操作次数) if (nowHead != head.load()) continue; // 队列为空, 出队失败 if (nowHead == nowTail and next == nullptr) return false; // tail指针未正确取值, 尝试移动tail if (nowHead == nowTail and next != nullptr) { tail.compare_exchange_weak(nowTail, next); continue; } // 在CAS操作前记录返回值, 如果在CAS操作之后则该结点有可能被其他线程free _ret = next-&gt;val; // 实现出队的操作. head = head -&gt; next if (head.compare_exchange_weak(nowHead, next)) break; } // 释放原头结点 delete nowHead; return true;} 代码实现首先通过上述分析, 使用cpp11进行了代码实现. 接着对实现的代码进行正确性测试、内存检查和性能测试. 正确性检查思路. 检查每个物品是否只入队一次且只出队一次. 内存检查. CLion中使用Valgrind的Memcheck工具在WSL环境下进行检查. 性能测试. 与使用mutex的版本进行比较. setting.h: 全局设置 123456789101112131415161718192021//// Created by Jsss on 2022/3/12.//#ifndef LOCKFREEQUEUE_SETTING_H#define LOCKFREEQUEUE_SETTING_H// 生产者数量int producerWorks = 4;// 消费者数量int consumerWorks = 4;// 每个生产者生产的个数int producerNums = 1e6;// 重复次数int epochs = 10;#endif //LOCKFREEQUEUE_SETTING_H LockFreeQueue.h: 无锁队列的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//// Created by Jsss on 2022/3/12.//#ifndef LOCKFREEQUEUE_LOCKFREEQUEUE_H#define LOCKFREEQUEUE_LOCKFREEQUEUE_H#pragma once#include &lt;atomic&gt;using std::atomic;template &lt;typename T&gt;class LockFreeQueue{public: struct Node { T val; atomic&lt;Node*&gt; next; Node () : val(T()), next(atomic&lt;Node*&gt;(nullptr)) {} Node (const T&amp; _v) : val(_v), next(atomic&lt;Node*&gt;(nullptr)){} Node (const T&amp; _v, atomic&lt;Node*&gt; _next) : val(_v), next(_next) {} }; LockFreeQueue () { Node* dummy = new Node; head.store(dummy); tail.store(dummy); }; // 入队操作 void enqueue (T _val) { // 插入结点为p Node* p = new Node(_val); Node *cur, *next; Node* null = nullptr; while (true) { // cur 指针为尾结点的快照 cur = tail.load(); // next 指针为为尾结点下一个结点 next = cur -&gt; next; // 如果尾指针被移动, 则重新获取cur和next (可能被其他线程移动了, 重新获取以减少CAS操作次数) if (cur != tail.load()) continue; if (next != nullptr) { // 当next指针不为空时, 尝试移动tail指针, 防止出现死锁 tail.compare_exchange_weak(cur, next); continue; } // 实现第一步操作: tail -&gt; next = p if (cur-&gt;next.compare_exchange_weak(null, p) == true) break; } // 实现第二步操作: tail = p tail.compare_exchange_weak(cur, p); }; // version 1// bool dequeue (T&amp; _ret) {// Node *nowHead, *next;//// while (true) {// nowHead = head.load();// next = nowHead-&gt;next;// // 如果头指针被移动, 则重新获取其快照 (可能被其他线程移动了, 重新获取以减少CAS操作次数)// if (nowHead != head.load())// continue;// // 队列为空, 出队失败// if (next == nullptr)// return false;// // 在CAS操作前记录返回值, 如果在CAS操作之后则该结点有可能被其他线程free// _ret = next-&gt;val;// // 实现出队的操作. head = head -&gt; next// if (head.compare_exchange_weak(nowHead, next))// break;// }// // 释放原头结点// delete nowHead;// return true;// } // version 2 bool dequeue (T&amp; _ret) { Node *nowHead, *nowTail, *next; while (true) { nowHead = head.load(), nowTail = tail.load(); next = nowHead -&gt; next; // 如果头指针被移动, 则重新获取其快照 (可能被其他线程移动了, 重新获取以减少CAS操作次数) if (nowHead != head.load()) continue; // 队列为空, 出队失败 if (nowHead == nowTail and next == nullptr) return false; // tail指针未正确取值, 尝试移动tail if (nowHead == nowTail and next != nullptr) { tail.compare_exchange_weak(nowTail, next); continue; } // 在CAS操作前记录返回值, 如果在CAS操作之后则该结点有可能被其他线程free _ret = next-&gt;val; // 实现出队的操作. head = head -&gt; next if (head.compare_exchange_weak(nowHead, next)) break; } // 释放原头结点 delete nowHead; return true; } // 删除拷贝构造函数和拷贝赋值函数 LockFreeQueue (const LockFreeQueue&amp; ) = delete; LockFreeQueue operator = (const LockFreeQueue&amp;) = delete;private: atomic&lt;Node*&gt; head, tail;};#endif //LOCKFREEQUEUE_LOCKFREEQUEUE_H check.cpp: 正确性检查 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//// Created by Jsss on 2022/3/12.//#include &lt;iostream&gt;#include &lt;vector&gt;#include &quot;LockFreeQueue.h&quot;#include &quot;setting.h&quot;#include &lt;thread&gt;#include &lt;chrono&gt;using std::vector;using std::thread;using std::cout;int all = producerWorks * producerNums;// 记录物品的生产和消费vector&lt;atomic&lt;int&gt;&gt; in(all), out(all);// 记录生产者和消费者完成数目atomic&lt;int&gt; prodFinish(0);LockFreeQueue&lt;int&gt; qu;void produce (int _id) { // 确定生产者生产编号的范围, 保证每个生产者生产的物品唯一 int L = _id * producerNums, R = (_id + 1) * producerNums - 1; for (int u = L; u &lt;= R; u ++ ) { qu.enqueue(u); in[u].fetch_add(1) ; } // 生产完毕则, finish个数 + 1 cout &lt;&lt; &quot;produce &quot; &lt;&lt; _id &lt;&lt; &quot; finish.\\n&quot;; prodFinish.fetch_add(1);}void consume () { // 必须使用CAS操作判断, 如果prodFinish的值不为producerWorks的数目, 即生产者还在生产, 就继续尝试消费 int cur;// while (prodFinish.load() &lt; producerWorks) { while (prodFinish.compare_exchange_weak(producerWorks, producerWorks) == false) { // 取成功则对应位置的 out + 1 while (qu.dequeue(cur)) out[cur].fetch_add(1); }}void lastConsume () { int cur; while (qu.dequeue(cur)) out[cur].fetch_add(1);}void check() { int inCnt = 0, outCnt = 0; for (int i = 0; i &lt; all; i ++ ) if (in[i].load() != 1) { cout &lt;&lt; &quot;produce object &quot; &lt;&lt; i &lt;&lt; &quot; error, val = &quot; &lt;&lt; in[i].load() &lt;&lt; '\\n'; inCnt ++ ; } for (int i = 0; i &lt; all; i ++ ) if (out[i].load() != 1) { cout &lt;&lt; &quot;consume object &quot; &lt;&lt; i &lt;&lt; &quot; error, val = &quot; &lt;&lt; out[i].load() &lt;&lt; '\\n'; outCnt ++ ; } cout &lt;&lt; &quot;\\nerror in count = &quot; &lt;&lt; inCnt &lt;&lt; '\\n'; cout &lt;&lt; &quot;error out count = &quot; &lt;&lt; outCnt &lt;&lt; '\\n';}int main() { std::chrono::time_point&lt;std::chrono::system_clock&gt; start_time = std::chrono::system_clock::now(); // 初始化in 和 out (atomic类禁止拷贝构造和移动构造, 使用atomic_init()函数实现其初始化) for (auto&amp; c : in) std::atomic_init(&amp;c, 0); for (auto&amp; c : out) std::atomic_init(&amp;c, 0); vector&lt;thread&gt; prod(producerWorks), cons(consumerWorks); for (int i = 0; i &lt; producerWorks; i ++ ) prod[i] = thread(produce, i); for (auto&amp; t : cons) t = thread(consume); for (auto&amp; t : prod) t.join(); for (auto&amp; t : cons) t.join(); // 当生产者生产完毕后, 添加最后一个消费者, 该消费者保证能够将剩下的物品消费完毕 lastConsume(); // 消费完毕后, 进行正确性检查. check(); std::chrono::time_point&lt;std::chrono::system_clock&gt; end_time = std::chrono::system_clock::now(); std::chrono::milliseconds time = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_time - start_time); cout &lt;&lt; &quot;\\ncost time = &quot; &lt;&lt; time.count() &lt;&lt; &quot; ms\\n&quot;; return 0;} benchmark_lockfree.cpp: 无锁队列性能测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//// Created by Jsss on 2022/3/13.//#include &lt;iostream&gt;#include &lt;vector&gt;#include &quot;LockFreeQueue.h&quot;#include &quot;setting.h&quot;#include &lt;thread&gt;#include &lt;chrono&gt;using std::vector;using std::thread;using std::cout;int all = producerWorks * producerNums;// 记录生产者和消费者完成数目atomic&lt;int&gt; prodFinish(0);LockFreeQueue&lt;int&gt; qu;void produce (int _id) { // 确定生产者生产编号的范围, 保证每个生产者生产的物品唯一 int L = _id * producerNums, R = (_id + 1) * producerNums - 1; for (int u = L; u &lt;= R; u ++ ) qu.enqueue(u); // 生产完毕则, finish个数 + 1 prodFinish.fetch_add(1);}void consume () { // 必须使用CAS操作判断, 如果prodFinish的值不为producerWorks的数目, 即生产者还在生产, 就继续尝试消费 int cur;// while (prodFinish.load() &lt; producerWorks) { while (prodFinish.compare_exchange_weak(producerWorks, producerWorks) == false) { // 取成功则对应位置的 out + 1 while (qu.dequeue(cur)) ; }}void lastConsume () { int cur; while (qu.dequeue(cur)) ;}void epochRunLockFree() { vector&lt;thread&gt; prod(producerWorks), cons(consumerWorks); for (int i = 0; i &lt; producerWorks; i ++ ) prod[i] = thread(produce, i); for (auto&amp; t : cons) t = thread(consume); for (auto&amp; t : prod) t.join(); for (auto&amp; t : cons) t.join(); // 当生产者生产完毕后, 添加最后一个消费者, 该消费者保证能够将剩下的物品消费完毕 lastConsume();}int main() { std::chrono::time_point&lt;std::chrono::system_clock&gt; start_time = std::chrono::system_clock::now(); for (int i = 0; i &lt; epochs; i ++ ) epochRunLockFree(); std::chrono::time_point&lt;std::chrono::system_clock&gt; end_time = std::chrono::system_clock::now(); std::chrono::milliseconds time = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_time - start_time); cout &lt;&lt; &quot;\\nepoch cost average time = &quot; &lt;&lt; time.count() / epochs &lt;&lt; &quot; ms\\n&quot;; return 0;} 测试结果 正确性测试 1234567891011produce 1 finish.produce 0 finish.produce 3 finish.produce 2 finish.error in count = 0error out count = 0cost time = 1273 msProcess finished with exit code 0 Valgrind内存检查 无锁队列性能测试 123epoch cost average time = 987 msProcess finished with exit code 0 mutex队列性能测试 123epoch cost average time = 378 msProcess finished with exit code 0 分析总结 使用无锁队列比mutex更慢的原因可能有2. 其一是无锁队列中使用了结构体, 并使用new和delete申请和释放, 频繁调用导致比mutex版本的int更慢. 其二是结构体使用了atomic&lt;Node*&gt;作为next指针. 如果使用普通的Node*并使用__sync_bool_compare_and_swap()可能会比现在更快. 实验用的机器是自己的笔记本. cpu是5800H, 八核心十六线程. 使用设置生产线程=2, 消费线程=2, 生产个数=2e6的时候耗时700ms左右; 当设置生产线程=4, 消费线程=4, 生产个数=1e6的时候耗时900ms左右; 而设置生产线程=8, 消费线程=8, 生产个数=5e5的时候耗时在1300ms左右. 相同的生产个数, 随着核心数的增加, 耗时却在增加, 这可能是多核情况下必须缓存一致性协议(MESI)来保持多核缓存一致, 而且使用了atomic, 导致耗时增加. 无锁队列可能适应于分布式场景下. 利用多设备的计算资源进行业务的分阶段处理. 参考 酷壳陈皓关于无锁队列的讲解博客 Implementing Lock-Free Queues Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms TODO 代码整理, 上传Github 解决ABA问题","link":"/2022/03/13/ConcurrencyAndDistribution/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"},{"title":"286","text":"Rank : 91/20339Solved : 4/4 竞赛链接 Find the Difference of Two Arrays思路模拟题意即可. 使用哈希表unordered_set可以快速判断某个数是否存在. Code12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;vector&lt;int&gt;&gt; findDifference(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { vector&lt;vector&lt;int&gt;&gt; ret; // 存储nums1 和 nums2 unordered_set&lt;int&gt; st1, st2; for (auto&amp; num : nums1) st1.insert(num); for (auto&amp; num : nums2) st2.insert(num); // 存储答案 unordered_set&lt;int&gt; ans1, ans2; for (auto&amp; num : nums1) if (st2.count(num) == 0) ans1.insert(num); for (auto&amp; num : nums2) if (st1.count(num) == 0) ans2.insert(num); vector&lt;int&gt; ret1, ret2; for (auto&amp; w : ans1) ret1.push_back(w); for (auto&amp; w : ans2) ret2.push_back(w); ret.push_back(ret1); ret.push_back(ret2); return ret; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(N)$ Minimum Deletions to Make Array Beautiful思路贪心. 假设左边已经保留了left个数字, 当前枚举到i位置. 我们从i位置开始往右找j, 直到nums[j] == nums[i]不满足为止(双指针算法). 这样我们找到了一段与nums[i]相等的子数组. 现在我们判断: 如果left为奇数: 说明i是答案中的奇数下标, 因此我们可以最多保留2个nums[i]. 它两的位置是先奇数再偶数, 这样满足题意. 如果left为偶数: 说明i是答案中的偶数下标, 因此我们只能保留1个nums[i]. 贪心选择完成后, 我们最后检查保留数组的长度是否为奇数, 如果为奇数, 去掉最后一个即可. Code12345678910111213141516171819202122class Solution {public: int minDeletion(vector&lt;int&gt;&amp; nums) { int left = 0, n = nums.size(); for (int i = 0; i &lt; n; ) { int j = i; while (j &lt; n and nums[j] == nums[i]) j ++ ; int len = j - i; if (left &amp; 1) left += min(2, len); else left += 1; i = j; } if (left &amp; 1) left -= 1; return n - left; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(1)$ Find Palindrome With Fixed Length思路模拟题意. 题目限定了回文数字的长度为intLength, 这样我们可以自由指定的长度为 $len = \\lceil intLength / 2 \\rceil$. 除了首位必须大于0之外, 我们可以任意的指定其他位置数字, 并且由于回文数字的长度相等且比较数字的时候先比较高位, 因此高位的排序就是最后回文数字的排序. 我们记录 $L = pow(10, len - 1), R = pow(10, len) - 1$. 如果我们要求第k个回文数组, 那么它的高位一定是L + k - 1, 然后我们根据长度是奇数还是偶数将高位和低位拼接在一起即可. 还需要检查 $L + k - 1 &lt; R$ 是否满足, 若不满足则不存在这样的第k个回文数字, 答案为-1. Code1234567891011121314151617181920212223242526272829using LL = long long;class Solution {public: vector&lt;long long&gt; kthPalindrome(vector&lt;int&gt;&amp; qu, int alen) { int len = (alen + 1) / 2; vector&lt;LL&gt; ans; for (auto&amp; k : qu) { // 计算L, R : 回文数字的下界和上界 int L = pow(10, len - 1), R = pow(10, len) - 1; L += k - 1; // 判断是否存在解 if (L &gt; R) { ans.push_back(-1); continue; } // 合并高位和低位构造回文数字 string s = to_string(L); string ns = s; reverse(ns.begin(), ns.end()); LL cur = 0LL; if (alen &amp; 1) cur = stoll(s + ns.substr(1)); else cur = stoll(s + ns); ans.push_back(cur); } return ans; }}; 复杂度分析 时间复杂度$O(N)$ 空间复杂度$O(1)$ Maximum Value of K Coins From Piles思路经典二维动态规划. 状态定义:$f[i][j]$表示考虑了前i个硬币桌子, 且总共拿了j个时取得的最大价值 状态转移: $f[i][j] = f[i - 1][j]$: 表示第i个桌子一个也不拿. $f[i][j] = max(f[i][j], f[i - 1][j - u] + sum), u\\in{[1, min(j, m)]}$: 表示第i个桌子上拿取前u个(其价值为sum), 且第i个桌子最多有m个. Code12345678910111213141516171819202122232425const int N = 1010, M = 2010;int f[N][M];class Solution {public: int maxValueOfCoins(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int k) { memset(f, 0, sizeof(f)); int n = nums.size(); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= k; j ++ ) { f[i][j] = f[i - 1][j]; int m = nums[i - 1].size(); for (int u = 1, sum = 0; u &lt;= min(j, m); u ++ ) { sum += nums[i - 1][u - 1]; f[i][j] = max(f[i][j], f[i - 1][j - u] + sum); } } return f[n][k]; }}; 复杂度分析 时间复杂度$O(N * K)$ 空间复杂度$O(N * K)$ 欢迎讨论指正","link":"/2022/03/27/algo/LeetCode/%E5%91%A8%E8%B5%9B/%5BLeetCode-%E5%91%A8%E8%B5%9B%5D286/"}],"tags":[{"name":"工具软件","slug":"工具软件","link":"/tags/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"字符串分割","slug":"字符串分割","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/"},{"name":"状态机","slug":"状态机","link":"/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"优先队列","slug":"优先队列","link":"/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"枚举","slug":"枚举","link":"/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"周赛","slug":"周赛","link":"/tags/%E5%91%A8%E8%B5%9B/"},{"name":"二分搜索","slug":"二分搜索","link":"/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"},{"name":"状态压缩","slug":"状态压缩","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"哈希表","slug":"哈希表","link":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"深度优先搜索","slug":"深度优先搜索","link":"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"平衡树","slug":"平衡树","link":"/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"递推","slug":"递推","link":"/tags/%E9%80%92%E6%8E%A8/"},{"name":"状态压缩动态规划","slug":"状态压缩动态规划","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"语言基础","slug":"语言基础","link":"/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"无锁队列","slug":"无锁队列","link":"/tags/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"},{"name":"进程通信","slug":"进程通信","link":"/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"},{"name":"匿名管道","slug":"匿名管道","link":"/tags/%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93/"},{"name":"命名管道","slug":"命名管道","link":"/tags/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93/"},{"name":"共享主存","slug":"共享主存","link":"/tags/%E5%85%B1%E4%BA%AB%E4%B8%BB%E5%AD%98/"},{"name":"生产者-消费者","slug":"生产者-消费者","link":"/tags/%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85/"}],"categories":[{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"cpp","slug":"cpp","link":"/categories/cpp/"},{"name":"algo","slug":"algo","link":"/categories/algo/"},{"name":"LeetCode","slug":"algo/LeetCode","link":"/categories/algo/LeetCode/"},{"name":"周赛","slug":"algo/LeetCode/周赛","link":"/categories/algo/LeetCode/%E5%91%A8%E8%B5%9B/"},{"name":"每日一题","slug":"algo/LeetCode/每日一题","link":"/categories/algo/LeetCode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"系列合集","slug":"algo/LeetCode/系列合集","link":"/categories/algo/LeetCode/%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"ConcurrencyAndDistribution","slug":"ConcurrencyAndDistribution","link":"/categories/ConcurrencyAndDistribution/"}]}